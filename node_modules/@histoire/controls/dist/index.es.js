import { defineComponent as tt, openBlock as S, createElementBlock as _, normalizeClass as gt, renderSlot as ct, createBlock as Q, resolveDynamicComponent as sa, withCtx as q, withDirectives as _t, createTextVNode as te, toDisplayString as Ct, unref as H, createElementVNode as B, computed as at, Fragment as fe, renderList as Be, watch as Ji, ref as rt, withKeys as Fe, withModifiers as ze, createVNode as kn, normalizeStyle as Pt, mergeProps as Qe, onUnmounted as ra, isRef as _o, vModelText as Wo, createCommentVNode as Jt, onMounted as oa, watchEffect as la } from "@histoire/vendors/vue";
import { VTooltip as ue, Dropdown as ha } from "@histoire/vendors/floating-vue";
import { Icon as $s } from "@histoire/vendors/iconify";
import { useClipboard as aa } from "@histoire/vendors/vue-use";
const ca = {
  name: "HstButton"
}, jo = /* @__PURE__ */ tt({
  ...ca,
  props: {
    color: null
  },
  setup(s) {
    const t = {
      default: "htw-bg-gray-200 dark:htw-bg-gray-750 htw-text-gray-900 dark:htw-text-gray-100 hover:htw-bg-primary-200 dark:hover:htw-bg-primary-900",
      primary: "htw-bg-primary-500 hover:htw-bg-primary-600 htw-text-white dark:htw-text-black",
      flat: "htw-bg-transparent hover:htw-bg-gray-500/20 htw-text-gray-900 dark:htw-text-gray-100"
    };
    return (e, i) => {
      var n;
      return S(), _("button", {
        class: gt(["histoire-button htw-cursor-pointer htw-rounded-sm", t[(n = s.color) != null ? n : "default"]])
      }, [
        ct(e.$slots, "default")
      ], 2);
    };
  }
}), fa = { class: "htw-w-28 htw-whitespace-nowrap htw-text-ellipsis htw-overflow-hidden htw-shrink-0" }, ua = { class: "htw-grow htw-max-w-full htw-flex htw-items-center htw-gap-1" }, da = { class: "htw-block htw-grow htw-max-w-full" }, pa = {
  name: "HstWrapper"
}, jt = /* @__PURE__ */ tt({
  ...pa,
  props: {
    title: { default: void 0 },
    tag: { default: "label" }
  },
  setup(s) {
    return (t, e) => (S(), Q(sa(s.tag), { class: "histoire-wrapper htw-p-2 hover:htw-bg-primary-100 dark:hover:htw-bg-primary-800 htw-flex htw-gap-2 htw-flex-wrap" }, {
      default: q(() => [
        _t((S(), _("span", fa, [
          te(Ct(s.title), 1)
        ])), [
          [H(ue), {
            content: s.title,
            placement: "left",
            distance: 12
          }]
        ]),
        B("span", ua, [
          B("span", da, [
            ct(t.$slots, "default")
          ]),
          ct(t.$slots, "actions")
        ])
      ]),
      _: 3
    }));
  }
}), ga = { class: "htw-flex htw-gap-px htw-border htw-border-solid htw-border-black/25 dark:htw-border-white/25 htw-rounded-sm htw-p-px" }, ma = {
  name: "HstButtonGroup"
}, wa = /* @__PURE__ */ tt({
  ...ma,
  props: {
    title: null,
    modelValue: null,
    options: null
  },
  emits: ["update:modelValue"],
  setup(s, { emit: t }) {
    const e = s, i = at(() => Array.isArray(e.options) ? Object.fromEntries(e.options.map((r) => typeof r == "string" ? [r, r] : [r.value, r.label])) : e.options);
    function n(r) {
      t("update:modelValue", r);
    }
    return (r, o) => (S(), Q(jt, {
      tag: "div",
      role: "group",
      title: s.title,
      class: "histoire-button-group htw-flex-nowrap htw-items-center"
    }, {
      actions: q(() => [
        ct(r.$slots, "actions")
      ]),
      default: q(() => [
        B("div", ga, [
          (S(!0), _(fe, null, Be(H(i), (l, h) => (S(), Q(jo, {
            key: h,
            class: "htw-px-1 htw-h-[22px] htw-flex-1 !htw-rounded-[3px]",
            color: h === s.modelValue ? "primary" : "flat",
            rounded: !1,
            onClick: (a) => n(h)
          }, {
            default: q(() => [
              te(Ct(l), 1)
            ]),
            _: 2
          }, 1032, ["color", "onClick"]))), 128))
        ])
      ]),
      _: 3
    }, 8, ["title"]));
  }
}), ya = {
  width: "16",
  height: "16",
  viewBox: "0 0 24 24",
  class: "htw-relative htw-z-10"
}, ba = ["stroke-dasharray", "stroke-dashoffset"], ka = {
  name: "HstSimpleCheckbox"
}, qo = /* @__PURE__ */ tt({
  ...ka,
  props: {
    modelValue: { type: Boolean },
    withToggle: { type: Boolean }
  },
  emits: {
    "update:modelValue": (s) => !0
  },
  setup(s, { emit: t }) {
    const e = s;
    function i() {
      !e.withToggle || t("update:modelValue", !e.modelValue);
    }
    Ji(() => e.modelValue, () => {
      h.value = !0;
    });
    const n = rt(), r = rt(0), o = at(() => e.modelValue ? 1 : 0), l = at(() => (1 - o.value) * r.value), h = rt(!1);
    return Ji(n, () => {
      var a, c, f;
      r.value = (f = (c = (a = n.value).getTotalLength) == null ? void 0 : c.call(a)) != null ? f : 21.21;
    }), (a, c) => (S(), _("div", {
      class: gt(["histoire-simple-checkbox htw-group htw-text-white htw-w-[16px] htw-h-[16px] htw-relative", { "htw-cursor-pointer": s.withToggle }]),
      onClick: i
    }, [
      B("div", {
        class: gt(["htw-border htw-border-solid group-active:htw-bg-gray-500/20 htw-rounded-sm htw-box-border htw-absolute htw-inset-0 htw-transition-border htw-duration-150 htw-ease-out group-hover:htw-border-primary-500 group-hover:dark:htw-border-primary-500", [
          s.modelValue ? "htw-border-primary-500 htw-border-8" : "htw-border-black/25 dark:htw-border-white/25 htw-delay-150"
        ]])
      }, null, 2),
      (S(), _("svg", ya, [
        B("path", {
          ref_key: "path",
          ref: n,
          d: "m 4 12 l 5 5 l 10 -10",
          fill: "none",
          class: gt(["htw-stroke-white htw-stroke-2 htw-duration-200 htw-ease-in-out", [
            h.value ? "htw-transition-all" : "htw-transition-none",
            {
              "htw-delay-150": s.modelValue
            }
          ]]),
          "stroke-dasharray": r.value,
          "stroke-dashoffset": H(l)
        }, null, 10, ba)
      ]))
    ], 2));
  }
}), xa = {
  name: "HstCheckbox"
}, va = /* @__PURE__ */ tt({
  ...xa,
  props: {
    modelValue: { type: Boolean },
    title: null
  },
  emits: {
    "update:modelValue": (s) => !0
  },
  setup(s, { emit: t }) {
    const e = s;
    function i() {
      t("update:modelValue", !e.modelValue);
    }
    return (n, r) => (S(), Q(jt, {
      role: "checkbox",
      tabindex: "0",
      class: "histoire-checkbox htw-cursor-pointer htw-items-center",
      title: s.title,
      onClick: r[0] || (r[0] = (o) => i()),
      onKeydown: [
        r[1] || (r[1] = Fe(ze((o) => i(), ["prevent"]), ["enter"])),
        r[2] || (r[2] = Fe(ze((o) => i(), ["prevent"]), ["space"]))
      ]
    }, {
      actions: q(() => [
        ct(n.$slots, "actions")
      ]),
      default: q(() => [
        kn(qo, { "model-value": s.modelValue }, null, 8, ["model-value"])
      ]),
      _: 3
    }, 8, ["title"]));
  }
}), Sa = { class: "-htw-my-1" }, Ca = ["for", "onKeydown", "onClick"], Aa = {
  name: "HstCheckboxList"
}, Oa = /* @__PURE__ */ tt({
  ...Aa,
  props: {
    title: null,
    modelValue: null,
    options: null
  },
  emits: ["update:modelValue"],
  setup(s, { emit: t }) {
    const e = s, i = at(() => Array.isArray(e.options) ? Object.fromEntries(e.options.map((r) => typeof r == "string" ? [r, r] : [r.value, r.label])) : e.options);
    function n(r) {
      e.modelValue.includes(r) ? t("update:modelValue", e.modelValue.filter((o) => o !== r)) : t("update:modelValue", [...e.modelValue, r]);
    }
    return (r, o) => (S(), Q(jt, {
      role: "group",
      title: s.title,
      class: gt(["histoire-checkbox-list htw-cursor-text", r.$attrs.class]),
      style: Pt(r.$attrs.style)
    }, {
      actions: q(() => [
        ct(r.$slots, "actions")
      ]),
      default: q(() => [
        B("div", Sa, [
          (S(!0), _(fe, null, Be(H(i), (l, h) => (S(), _("label", {
            key: h,
            tabindex: "0",
            for: `${h}-radio`,
            class: "htw-cursor-pointer htw-flex htw-items-center htw-relative htw-py-1 htw-group",
            onKeydown: [
              Fe(ze((a) => n(h), ["prevent"]), ["enter"]),
              Fe(ze((a) => n(h), ["prevent"]), ["space"])
            ],
            onClick: (a) => n(h)
          }, [
            kn(qo, {
              "model-value": s.modelValue.includes(h),
              class: "htw-mr-2"
            }, null, 8, ["model-value"]),
            te(" " + Ct(l), 1)
          ], 40, Ca))), 128))
        ])
      ]),
      _: 3
    }, 8, ["title", "class", "style"]));
  }
}), Ma = ["value"], Da = {
  name: "HstText"
}, Ta = /* @__PURE__ */ tt({
  ...Da,
  props: {
    title: null,
    modelValue: null
  },
  emits: {
    "update:modelValue": (s) => !0
  },
  setup(s, { emit: t }) {
    const e = rt();
    return (i, n) => (S(), Q(jt, {
      title: s.title,
      class: gt(["histoire-text htw-cursor-text htw-items-center", i.$attrs.class]),
      style: Pt(i.$attrs.style),
      onClick: n[1] || (n[1] = (r) => e.value.focus())
    }, {
      actions: q(() => [
        ct(i.$slots, "actions")
      ]),
      default: q(() => [
        B("input", Qe({
          ref_key: "input",
          ref: e
        }, { ...i.$attrs, class: null, style: null }, {
          type: "text",
          value: s.modelValue,
          class: "htw-text-inherit htw-bg-transparent htw-w-full htw-outline-none htw-px-2 htw-py-1 -htw-my-1 htw-border htw-border-solid htw-border-black/25 dark:htw-border-white/25 focus:htw-border-primary-500 dark:focus:htw-border-primary-500 htw-rounded-sm",
          onInput: n[0] || (n[0] = (r) => t("update:modelValue", r.target.value))
        }), null, 16, Ma)
      ]),
      _: 3
    }, 8, ["title", "class", "style"]));
  }
}), Pa = {
  name: "HstNumber",
  inheritAttrs: !1
}, Ba = /* @__PURE__ */ tt({
  ...Pa,
  props: {
    title: null,
    modelValue: null
  },
  emits: {
    "update:modelValue": (s) => !0
  },
  setup(s, { emit: t }) {
    const e = s, i = at({
      get: () => e.modelValue,
      set: (u) => {
        t("update:modelValue", u);
      }
    }), n = rt();
    function r() {
      n.value.focus(), n.value.select();
    }
    const o = rt(!1);
    let l, h;
    function a(u) {
      o.value = !0, l = u.clientX, h = i.value, window.addEventListener("mousemove", c), window.addEventListener("mouseup", f);
    }
    function c(u) {
      let d = parseFloat(n.value.step);
      isNaN(d) && (d = 1), i.value = h + Math.round((u.clientX - l) / 10 / d) * d;
    }
    function f() {
      o.value = !1, window.removeEventListener("mousemove", c), window.removeEventListener("mouseup", f);
    }
    return ra(() => {
      f();
    }), (u, d) => (S(), Q(jt, {
      class: gt(["histoire-number htw-cursor-ew-resize htw-items-center", [
        u.$attrs.class,
        { "htw-select-none": o.value }
      ]]),
      title: s.title,
      style: Pt(u.$attrs.style),
      onClick: r,
      onMousedown: a
    }, {
      actions: q(() => [
        ct(u.$slots, "actions")
      ]),
      default: q(() => [
        _t(B("input", Qe({
          ref_key: "input",
          ref: n
        }, { ...u.$attrs, class: null, style: null }, {
          "onUpdate:modelValue": d[0] || (d[0] = (p) => _o(i) ? i.value = p : null),
          type: "number",
          class: [{
            "htw-select-none": o.value
          }, "htw-text-inherit htw-bg-transparent htw-w-full htw-outline-none htw-pl-2 htw-py-1 -htw-my-1 htw-border htw-border-solid htw-border-black/25 dark:htw-border-white/25 focus:htw-border-primary-500 dark:focus:htw-border-primary-500 htw-rounded-sm htw-cursor-ew-resize htw-box-border"]
        }), null, 16), [
          [
            Wo,
            H(i),
            void 0,
            { number: !0 }
          ]
        ])
      ]),
      _: 3
    }, 8, ["title", "class", "style"]));
  }
});
const Ra = { class: "htw-relative htw-w-full htw-flex htw-items-center" }, La = /* @__PURE__ */ B("div", { class: "htw-absolute htw-inset-0 htw-flex htw-items-center" }, [
  /* @__PURE__ */ B("div", { class: "htw-border htw-border-black/25 dark:htw-border-white/25 htw-h-1 htw-w-full htw-rounded-full" })
], -1), Ea = {
  name: "HstSlider",
  inheritAttrs: !1
}, Na = /* @__PURE__ */ tt({
  ...Ea,
  props: {
    title: null,
    modelValue: null,
    min: null,
    max: null
  },
  emits: {
    "update:modelValue": (s) => !0
  },
  setup(s, { emit: t }) {
    const e = s, i = rt(!1), n = rt(null), r = at({
      get: () => e.modelValue,
      set: (h) => {
        t("update:modelValue", h);
      }
    }), o = at(() => (e.modelValue - e.min) / (e.max - e.min)), l = at(() => n.value ? {
      left: 8 + (n.value.clientWidth - 16) * o.value + "px"
    } : {});
    return (h, a) => (S(), Q(jt, {
      class: gt(["histoire-slider htw-items-center", h.$attrs.class]),
      title: s.title,
      style: Pt(h.$attrs.style)
    }, {
      default: q(() => [
        B("div", Ra, [
          La,
          _t(B("input", Qe({
            ref_key: "input",
            ref: n,
            "onUpdate:modelValue": a[0] || (a[0] = (c) => _o(r) ? r.value = c : null),
            class: "htw-range-input htw-appearance-none htw-border-0 htw-bg-transparent htw-cursor-pointer htw-relative htw-w-full htw-m-0 htw-text-gray-700",
            type: "range"
          }, { ...h.$attrs, class: null, style: null, min: s.min, max: s.max }, {
            onMouseover: a[1] || (a[1] = (c) => i.value = !0),
            onMouseleave: a[2] || (a[2] = (c) => i.value = !1)
          }), null, 16), [
            [
              Wo,
              H(r),
              void 0,
              { number: !0 }
            ]
          ]),
          i.value ? _t((S(), _("div", {
            key: 0,
            class: "htw-absolute",
            style: Pt(H(l))
          }, null, 4)), [
            [H(ue), { content: s.modelValue.toString(), shown: !0, distance: 16, delay: 0 }]
          ]) : Jt("", !0)
        ])
      ]),
      _: 1
    }, 8, ["title", "class", "style"]));
  }
}), Va = ["value"], Ia = {
  name: "HstTextarea",
  inheritAttrs: !1
}, Ha = /* @__PURE__ */ tt({
  ...Ia,
  props: {
    title: null,
    modelValue: null
  },
  emits: {
    "update:modelValue": (s) => !0
  },
  setup(s, { emit: t }) {
    const e = rt();
    return (i, n) => (S(), Q(jt, {
      title: s.title,
      class: gt(["histoire-textarea htw-cursor-text", i.$attrs.class]),
      style: Pt(i.$attrs.style),
      onClick: n[1] || (n[1] = (r) => e.value.focus())
    }, {
      actions: q(() => [
        ct(i.$slots, "actions")
      ]),
      default: q(() => [
        B("textarea", Qe({
          ref_key: "input",
          ref: e
        }, { ...i.$attrs, class: null, style: null }, {
          value: s.modelValue,
          class: "htw-text-inherit htw-bg-transparent htw-w-full htw-outline-none htw-px-2 htw-py-1 -htw-my-1 htw-border htw-border-solid htw-border-black/25 dark:htw-border-white/25 focus:htw-border-primary-500 dark:focus:htw-border-primary-500 htw-rounded-sm htw-box-border htw-resize-y htw-min-h-[26px]",
          onInput: n[0] || (n[0] = (r) => t("update:modelValue", r.target.value))
        }), null, 16, Va)
      ]),
      _: 3
    }, 8, ["title", "class", "style"]));
  }
});
const $a = { class: "htw-cursor-pointer htw-w-full htw-outline-none htw-px-2 htw-h-[27px] -htw-my-1 htw-border htw-border-solid htw-border-black/25 dark:htw-border-white/25 hover:htw-border-primary-500 dark:hover:htw-border-primary-500 htw-rounded-sm htw-flex htw-gap-2 htw-items-center htw-leading-normal" }, Fa = { class: "htw-flex-1 htw-truncate" }, za = { class: "htw-flex htw-flex-col htw-bg-gray-50 dark:htw-bg-gray-700" }, _a = ["onClick"], Wa = {
  name: "CustomSelect"
}, ja = /* @__PURE__ */ tt({
  ...Wa,
  props: {
    modelValue: null,
    options: null
  },
  emits: ["update:modelValue"],
  setup(s, { emit: t }) {
    const e = s, i = at(() => Array.isArray(e.options) ? e.options.map((o) => typeof o == "string" ? [o, o] : [o.value, o.label]) : Object.entries(e.options)), n = at(() => {
      var o;
      return (o = i.value.find(([l]) => l === e.modelValue)) == null ? void 0 : o[1];
    });
    function r(o, l) {
      t("update:modelValue", o), l();
    }
    return (o, l) => (S(), Q(H(ha), { "auto-size": "" }, {
      popper: q(({ hide: h }) => [
        B("div", za, [
          (S(!0), _(fe, null, Be(H(i), ([a, c]) => (S(), _("div", Qe({ ...o.$attrs, class: null, style: null }, {
            key: c,
            class: ["htw-px-2 htw-py-1 htw-cursor-pointer hover:htw-bg-primary-100 dark:hover:htw-bg-primary-700", {
              "htw-bg-primary-200 dark:htw-bg-primary-800": e.modelValue === a
            }],
            onClick: (f) => r(a, h)
          }), Ct(c), 17, _a))), 128))
        ])
      ]),
      default: q(() => [
        B("div", $a, [
          B("div", Fa, [
            ct(o.$slots, "default", { label: H(n) }, () => [
              te(Ct(H(n)), 1)
            ])
          ]),
          kn(H($s), {
            icon: "carbon:chevron-sort",
            class: "htw-w-4 htw-h-4 htw-flex-none htw-ml-auto"
          })
        ])
      ]),
      _: 3
    }));
  }
}), qa = {
  name: "HstSelect"
}, Ga = /* @__PURE__ */ tt({
  ...qa,
  props: {
    title: null,
    modelValue: null,
    options: null
  },
  emits: ["update:modelValue"],
  setup(s, { emit: t }) {
    return (e, i) => (S(), Q(jt, {
      title: s.title,
      class: gt(["histoire-select htw-cursor-text htw-items-center", e.$attrs.class]),
      style: Pt(e.$attrs.style)
    }, {
      actions: q(() => [
        ct(e.$slots, "actions")
      ]),
      default: q(() => [
        kn(ja, {
          options: s.options,
          "model-value": s.modelValue,
          "onUpdate:modelValue": i[0] || (i[0] = (n) => t("update:modelValue", n))
        }, null, 8, ["options", "model-value"])
      ]),
      _: 3
    }, 8, ["title", "class", "style"]));
  }
}), Ka = {
  name: "HstCopyIcon"
}, Me = /* @__PURE__ */ tt({
  ...Ka,
  props: {
    content: null
  },
  setup(s) {
    const t = s, { copy: e, copied: i } = aa(), n = () => e(t.content);
    return (r, o) => _t((S(), Q(H($s), {
      icon: "carbon:copy-file",
      class: "htw-w-4 htw-h-4 htw-opacity-50 hover:htw-opacity-100 hover:htw-text-primary-500 htw-cursor-pointer",
      onClick: o[0] || (o[0] = (l) => n())
    }, null, 512)), [
      [H(ue), {
        content: "Copied!",
        triggers: [],
        shown: H(i),
        distance: 12,
        delay: 0
      }]
    ]);
  }
}), Ua = {
  key: 0,
  class: "histoire-color-shades htw-grid htw-gap-4 htw-grid-cols-[repeat(auto-fill,minmax(200px,1fr))] htw-m-4"
}, Qa = ["onMouseenter"], Ja = { class: "htw-flex htw-gap-1" }, Xa = { class: "htw-my-0 htw-truncate htw-shrink" }, Ya = { class: "htw-flex htw-gap-1" }, Za = { class: "htw-my-0 htw-opacity-50 htw-truncate htw-shrink" }, tc = {
  name: "HstColorShades"
}, ec = /* @__PURE__ */ tt({
  ...tc,
  props: {
    shades: null,
    getName: null,
    search: null
  },
  setup(s) {
    const t = s, e = (o, l = "") => Object.entries(o).reduce((h, [a, c]) => {
      const f = l ? a === "DEFAULT" ? l : `${l}-${a}` : a, u = typeof c == "object" ? e(c, f) : { [f]: c };
      return { ...h, ...u };
    }, {}), i = at(() => {
      const o = t.shades, l = t.getName, h = e(o);
      return Object.entries(h).map(([a, c]) => {
        const f = l ? l(a, c) : a;
        return {
          key: a,
          color: c,
          name: f
        };
      });
    }), n = at(() => {
      let o = i.value;
      if (t.search) {
        const l = new RegExp(t.search, "i");
        o = o.filter(({ name: h }) => l.test(h));
      }
      return o;
    }), r = rt(null);
    return (o, l) => H(n).length ? (S(), _("div", Ua, [
      (S(!0), _(fe, null, Be(H(n), (h) => (S(), _("div", {
        key: h.key,
        class: "htw-flex htw-flex-col htw-gap-2",
        onMouseenter: (a) => r.value = h.key,
        onMouseleave: l[0] || (l[0] = (a) => r.value = null)
      }, [
        ct(o.$slots, "default", {
          color: h.color
        }, () => [
          B("div", {
            class: "htw-rounded-full htw-w-16 htw-h-16",
            style: Pt({
              backgroundColor: h.color
            })
          }, null, 4)
        ]),
        B("div", null, [
          B("div", Ja, [
            _t((S(), _("pre", Xa, [
              te(Ct(h.name), 1)
            ])), [
              [H(ue), h.name.length > 23 ? h.name : ""]
            ]),
            r.value === h.key ? (S(), Q(Me, {
              key: 0,
              content: h.name,
              class: "htw-flex-none"
            }, null, 8, ["content"])) : Jt("", !0)
          ]),
          B("div", Ya, [
            _t((S(), _("pre", Za, [
              te(Ct(h.color), 1)
            ])), [
              [H(ue), h.color.length > 23 ? h.color : ""]
            ]),
            r.value === h.key ? (S(), Q(Me, {
              key: 0,
              content: h.color,
              class: "htw-flex-none"
            }, null, 8, ["content"])) : Jt("", !0)
          ])
        ])
      ], 40, Qa))), 128))
    ])) : Jt("", !0);
  }
}), ic = ["onMouseenter"], nc = { class: "htw-mx-4" }, sc = { class: "htw-flex htw-gap-1" }, rc = { class: "htw-my-0 htw-truncate htw-shrink" }, oc = { class: "htw-flex htw-gap-1" }, lc = { class: "htw-my-0 htw-opacity-50 htw-truncate htw-shrink" }, hc = {
  name: "HstTokenList"
}, ac = /* @__PURE__ */ tt({
  ...hc,
  props: {
    tokens: null,
    getName: null
  },
  setup(s) {
    const t = s, e = at(() => {
      const n = t.tokens, r = t.getName;
      return Object.entries(n).map(([o, l]) => {
        const h = r ? r(o, l) : o;
        return {
          key: o,
          name: h,
          value: typeof l == "number" ? l.toString() : l
        };
      });
    }), i = rt(null);
    return (n, r) => (S(!0), _(fe, null, Be(H(e), (o) => (S(), _("div", {
      key: o.key,
      class: "histoire-token-list htw-flex htw-flex-col htw-gap-2 htw-my-8",
      onMouseenter: (l) => i.value = o.key,
      onMouseleave: r[0] || (r[0] = (l) => i.value = null)
    }, [
      ct(n.$slots, "default", { token: o }),
      B("div", nc, [
        B("div", sc, [
          B("pre", rc, Ct(o.name), 1),
          i.value === o.key ? (S(), Q(Me, {
            key: 0,
            content: o.name,
            class: "htw-flex-none"
          }, null, 8, ["content"])) : Jt("", !0)
        ]),
        B("div", oc, [
          B("pre", lc, Ct(o.value), 1),
          i.value === o.key ? (S(), Q(Me, {
            key: 0,
            content: typeof o.value == "string" ? o.value : JSON.stringify(o.value),
            class: "htw-flex-none"
          }, null, 8, ["content"])) : Jt("", !0)
        ])
      ])
    ], 40, ic))), 128));
  }
});
const cc = ["onMouseenter"], fc = { class: "htw-flex htw-gap-1" }, uc = { class: "htw-my-0 htw-truncate htw-shrink" }, dc = { class: "htw-flex htw-gap-1" }, pc = { class: "htw-my-0 htw-opacity-50 htw-truncate htw-shrink" }, gc = {
  name: "HstTokenGrid"
}, mc = /* @__PURE__ */ tt({
  ...gc,
  props: {
    tokens: null,
    colSize: { default: 180 },
    getName: { type: Function, default: null }
  },
  setup(s) {
    const t = s, e = at(() => {
      const r = t.tokens, o = t.getName;
      return Object.entries(r).map(([l, h]) => {
        const a = o ? o(l, h) : l;
        return {
          key: l,
          name: a,
          value: typeof h == "number" ? h.toString() : h
        };
      });
    }), i = at(() => `${t.colSize}px`), n = rt(null);
    return (r, o) => (S(), _("div", {
      class: "histoire-token-grid htw-bind-col-size htw-grid htw-gap-4 htw-m-4",
      style: Pt({
        "--histoire-col-size": H(i)
      })
    }, [
      (S(!0), _(fe, null, Be(H(e), (l) => (S(), _("div", {
        key: l.key,
        class: "htw-flex htw-flex-col htw-gap-2",
        onMouseenter: (h) => n.value = l.key,
        onMouseleave: o[0] || (o[0] = (h) => n.value = null)
      }, [
        ct(r.$slots, "default", { token: l }),
        B("div", null, [
          B("div", fc, [
            _t((S(), _("pre", uc, [
              te(Ct(l.name), 1)
            ])), [
              [H(ue), l.name.length > s.colSize / 8 ? l.name : ""]
            ]),
            n.value === l.key ? (S(), Q(Me, {
              key: 0,
              content: l.name,
              class: "htw-flex-none"
            }, null, 8, ["content"])) : Jt("", !0)
          ]),
          B("div", dc, [
            _t((S(), _("pre", pc, [
              te(Ct(l.value), 1)
            ])), [
              [H(ue), l.value.length > s.colSize / 8 ? l.value : ""]
            ]),
            n.value === l.key ? (S(), Q(Me, {
              key: 0,
              content: typeof l.value == "string" ? l.value : JSON.stringify(l.value),
              class: "htw-flex-none"
            }, null, 8, ["content"])) : Jt("", !0)
          ])
        ])
      ], 40, cc))), 128))
    ], 4));
  }
}), wc = { class: "-htw-my-1" }, yc = ["id", "name", "value", "checked", "onChange"], bc = ["for", "onKeydown"], kc = {
  name: "HstRadio"
}, xc = /* @__PURE__ */ tt({
  ...kc,
  props: {
    title: null,
    modelValue: null,
    options: null
  },
  emits: ["update:modelValue"],
  setup(s, { emit: t }) {
    const e = s, i = at(() => Array.isArray(e.options) ? Object.fromEntries(e.options.map((o) => typeof o == "string" ? [o, o] : [o.value, o.label])) : e.options);
    function n(o) {
      t("update:modelValue", o), r.value = !0;
    }
    const r = rt(!1);
    return (o, l) => (S(), Q(jt, {
      role: "group",
      title: s.title,
      class: gt(["histoire-radio htw-cursor-text", o.$attrs.class]),
      style: Pt(o.$attrs.style)
    }, {
      actions: q(() => [
        ct(o.$slots, "actions")
      ]),
      default: q(() => [
        B("div", wc, [
          (S(!0), _(fe, null, Be(H(i), (h, a) => (S(), _(fe, { key: a }, [
            B("input", {
              id: `${a}-radio`,
              type: "radio",
              name: `${a}-radio`,
              value: a,
              checked: a === s.modelValue,
              class: "htw-hidden",
              onChange: (c) => n(a)
            }, null, 40, yc),
            B("label", {
              tabindex: "0",
              for: `${a}-radio`,
              class: "htw-cursor-pointer htw-flex htw-items-center htw-relative htw-py-1 htw-group",
              onKeydown: [
                Fe(ze((c) => n(a), ["prevent"]), ["enter"]),
                Fe(ze((c) => n(a), ["prevent"]), ["space"])
              ]
            }, [
              (S(), _("svg", {
                width: "16",
                height: "16",
                viewBox: "-12 -12 24 24",
                class: gt(["htw-relative htw-z-10 htw-border htw-border-solid htw-text-inherit htw-rounded-full htw-box-border htw-inset-0 htw-transition-border htw-duration-150 htw-ease-out htw-mr-2 group-hover:htw-border-primary-500", [
                  s.modelValue === a ? "htw-border-primary-500" : "htw-border-black/25 dark:htw-border-white/25"
                ]])
              }, [
                B("circle", {
                  r: "7",
                  class: gt(["htw-will-change-transform", [
                    r.value ? "htw-transition-all" : "htw-transition-none",
                    {
                      "htw-delay-150": s.modelValue === a
                    },
                    s.modelValue === a ? "htw-fill-primary-500" : "htw-fill-transparent htw-scale-0"
                  ]])
                }, null, 2)
              ], 2)),
              te(" " + Ct(h), 1)
            ], 40, bc)
          ], 64))), 128))
        ])
      ]),
      _: 3
    }, 8, ["title", "class", "style"]));
  }
});
class I {
  constructor() {
  }
  lineAt(t) {
    if (t < 0 || t > this.length)
      throw new RangeError(`Invalid position ${t} in document of length ${this.length}`);
    return this.lineInner(t, !1, 1, 0);
  }
  line(t) {
    if (t < 1 || t > this.lines)
      throw new RangeError(`Invalid line number ${t} in ${this.lines}-line document`);
    return this.lineInner(t, !0, 1, 0);
  }
  replace(t, e, i) {
    let n = [];
    return this.decompose(0, t, n, 2), i.length && i.decompose(0, i.length, n, 3), this.decompose(e, this.length, n, 1), Ht.from(n, this.length - (e - t) + i.length);
  }
  append(t) {
    return this.replace(this.length, this.length, t);
  }
  slice(t, e = this.length) {
    let i = [];
    return this.decompose(t, e, i, 0), Ht.from(i, e - t);
  }
  eq(t) {
    if (t == this)
      return !0;
    if (t.length != this.length || t.lines != this.lines)
      return !1;
    let e = this.scanIdentical(t, 1), i = this.length - this.scanIdentical(t, -1), n = new ri(this), r = new ri(t);
    for (let o = e, l = e; ; ) {
      if (n.next(o), r.next(o), o = 0, n.lineBreak != r.lineBreak || n.done != r.done || n.value != r.value)
        return !1;
      if (l += n.value.length, n.done || l >= i)
        return !0;
    }
  }
  iter(t = 1) {
    return new ri(this, t);
  }
  iterRange(t, e = this.length) {
    return new Go(this, t, e);
  }
  iterLines(t, e) {
    let i;
    if (t == null)
      i = this.iter();
    else {
      e == null && (e = this.lines + 1);
      let n = this.line(t).from;
      i = this.iterRange(n, Math.max(n, e == this.lines + 1 ? this.length : e <= 1 ? 0 : this.line(e - 1).to));
    }
    return new Ko(i);
  }
  toString() {
    return this.sliceString(0);
  }
  toJSON() {
    let t = [];
    return this.flatten(t), t;
  }
  static of(t) {
    if (t.length == 0)
      throw new RangeError("A document must have at least one line");
    return t.length == 1 && !t[0] ? I.empty : t.length <= 32 ? new K(t) : Ht.from(K.split(t, []));
  }
}
class K extends I {
  constructor(t, e = vc(t)) {
    super(), this.text = t, this.length = e;
  }
  get lines() {
    return this.text.length;
  }
  get children() {
    return null;
  }
  lineInner(t, e, i, n) {
    for (let r = 0; ; r++) {
      let o = this.text[r], l = n + o.length;
      if ((e ? i : l) >= t)
        return new Sc(n, l, i, o);
      n = l + 1, i++;
    }
  }
  decompose(t, e, i, n) {
    let r = t <= 0 && e >= this.length ? this : new K(ar(this.text, t, e), Math.min(e, this.length) - Math.max(0, t));
    if (n & 1) {
      let o = i.pop(), l = $i(r.text, o.text.slice(), 0, r.length);
      if (l.length <= 32)
        i.push(new K(l, o.length + r.length));
      else {
        let h = l.length >> 1;
        i.push(new K(l.slice(0, h)), new K(l.slice(h)));
      }
    } else
      i.push(r);
  }
  replace(t, e, i) {
    if (!(i instanceof K))
      return super.replace(t, e, i);
    let n = $i(this.text, $i(i.text, ar(this.text, 0, t)), e), r = this.length + i.length - (e - t);
    return n.length <= 32 ? new K(n, r) : Ht.from(K.split(n, []), r);
  }
  sliceString(t, e = this.length, i = `
`) {
    let n = "";
    for (let r = 0, o = 0; r <= e && o < this.text.length; o++) {
      let l = this.text[o], h = r + l.length;
      r > t && o && (n += i), t < h && e > r && (n += l.slice(Math.max(0, t - r), e - r)), r = h + 1;
    }
    return n;
  }
  flatten(t) {
    for (let e of this.text)
      t.push(e);
  }
  scanIdentical() {
    return 0;
  }
  static split(t, e) {
    let i = [], n = -1;
    for (let r of t)
      i.push(r), n += r.length + 1, i.length == 32 && (e.push(new K(i, n)), i = [], n = -1);
    return n > -1 && e.push(new K(i, n)), e;
  }
}
class Ht extends I {
  constructor(t, e) {
    super(), this.children = t, this.length = e, this.lines = 0;
    for (let i of t)
      this.lines += i.lines;
  }
  lineInner(t, e, i, n) {
    for (let r = 0; ; r++) {
      let o = this.children[r], l = n + o.length, h = i + o.lines - 1;
      if ((e ? h : l) >= t)
        return o.lineInner(t, e, i, n);
      n = l + 1, i = h + 1;
    }
  }
  decompose(t, e, i, n) {
    for (let r = 0, o = 0; o <= e && r < this.children.length; r++) {
      let l = this.children[r], h = o + l.length;
      if (t <= h && e >= o) {
        let a = n & ((o <= t ? 1 : 0) | (h >= e ? 2 : 0));
        o >= t && h <= e && !a ? i.push(l) : l.decompose(t - o, e - o, i, a);
      }
      o = h + 1;
    }
  }
  replace(t, e, i) {
    if (i.lines < this.lines)
      for (let n = 0, r = 0; n < this.children.length; n++) {
        let o = this.children[n], l = r + o.length;
        if (t >= r && e <= l) {
          let h = o.replace(t - r, e - r, i), a = this.lines - o.lines + h.lines;
          if (h.lines < a >> 5 - 1 && h.lines > a >> 5 + 1) {
            let c = this.children.slice();
            return c[n] = h, new Ht(c, this.length - (e - t) + i.length);
          }
          return super.replace(r, l, h);
        }
        r = l + 1;
      }
    return super.replace(t, e, i);
  }
  sliceString(t, e = this.length, i = `
`) {
    let n = "";
    for (let r = 0, o = 0; r < this.children.length && o <= e; r++) {
      let l = this.children[r], h = o + l.length;
      o > t && r && (n += i), t < h && e > o && (n += l.sliceString(t - o, e - o, i)), o = h + 1;
    }
    return n;
  }
  flatten(t) {
    for (let e of this.children)
      e.flatten(t);
  }
  scanIdentical(t, e) {
    if (!(t instanceof Ht))
      return 0;
    let i = 0, [n, r, o, l] = e > 0 ? [0, 0, this.children.length, t.children.length] : [this.children.length - 1, t.children.length - 1, -1, -1];
    for (; ; n += e, r += e) {
      if (n == o || r == l)
        return i;
      let h = this.children[n], a = t.children[r];
      if (h != a)
        return i + h.scanIdentical(a, e);
      i += h.length + 1;
    }
  }
  static from(t, e = t.reduce((i, n) => i + n.length + 1, -1)) {
    let i = 0;
    for (let d of t)
      i += d.lines;
    if (i < 32) {
      let d = [];
      for (let p of t)
        p.flatten(d);
      return new K(d, e);
    }
    let n = Math.max(32, i >> 5), r = n << 1, o = n >> 1, l = [], h = 0, a = -1, c = [];
    function f(d) {
      let p;
      if (d.lines > r && d instanceof Ht)
        for (let w of d.children)
          f(w);
      else
        d.lines > o && (h > o || !h) ? (u(), l.push(d)) : d instanceof K && h && (p = c[c.length - 1]) instanceof K && d.lines + p.lines <= 32 ? (h += d.lines, a += d.length + 1, c[c.length - 1] = new K(p.text.concat(d.text), p.length + 1 + d.length)) : (h + d.lines > n && u(), h += d.lines, a += d.length + 1, c.push(d));
    }
    function u() {
      h != 0 && (l.push(c.length == 1 ? c[0] : Ht.from(c, a)), a = -1, h = c.length = 0);
    }
    for (let d of t)
      f(d);
    return u(), l.length == 1 ? l[0] : new Ht(l, e);
  }
}
I.empty = /* @__PURE__ */ new K([""], 0);
function vc(s) {
  let t = -1;
  for (let e of s)
    t += e.length + 1;
  return t;
}
function $i(s, t, e = 0, i = 1e9) {
  for (let n = 0, r = 0, o = !0; r < s.length && n <= i; r++) {
    let l = s[r], h = n + l.length;
    h >= e && (h > i && (l = l.slice(0, i - n)), n < e && (l = l.slice(e - n)), o ? (t[t.length - 1] += l, o = !1) : t.push(l)), n = h + 1;
  }
  return t;
}
function ar(s, t, e) {
  return $i(s, [""], t, e);
}
class ri {
  constructor(t, e = 1) {
    this.dir = e, this.done = !1, this.lineBreak = !1, this.value = "", this.nodes = [t], this.offsets = [e > 0 ? 1 : (t instanceof K ? t.text.length : t.children.length) << 1];
  }
  nextInner(t, e) {
    for (this.done = this.lineBreak = !1; ; ) {
      let i = this.nodes.length - 1, n = this.nodes[i], r = this.offsets[i], o = r >> 1, l = n instanceof K ? n.text.length : n.children.length;
      if (o == (e > 0 ? l : 0)) {
        if (i == 0)
          return this.done = !0, this.value = "", this;
        e > 0 && this.offsets[i - 1]++, this.nodes.pop(), this.offsets.pop();
      } else if ((r & 1) == (e > 0 ? 0 : 1)) {
        if (this.offsets[i] += e, t == 0)
          return this.lineBreak = !0, this.value = `
`, this;
        t--;
      } else if (n instanceof K) {
        let h = n.text[o + (e < 0 ? -1 : 0)];
        if (this.offsets[i] += e, h.length > Math.max(0, t))
          return this.value = t == 0 ? h : e > 0 ? h.slice(t) : h.slice(0, h.length - t), this;
        t -= h.length;
      } else {
        let h = n.children[o + (e < 0 ? -1 : 0)];
        t > h.length ? (t -= h.length, this.offsets[i] += e) : (e < 0 && this.offsets[i]--, this.nodes.push(h), this.offsets.push(e > 0 ? 1 : (h instanceof K ? h.text.length : h.children.length) << 1));
      }
    }
  }
  next(t = 0) {
    return t < 0 && (this.nextInner(-t, -this.dir), t = this.value.length), this.nextInner(t, this.dir);
  }
}
class Go {
  constructor(t, e, i) {
    this.value = "", this.done = !1, this.cursor = new ri(t, e > i ? -1 : 1), this.pos = e > i ? t.length : 0, this.from = Math.min(e, i), this.to = Math.max(e, i);
  }
  nextInner(t, e) {
    if (e < 0 ? this.pos <= this.from : this.pos >= this.to)
      return this.value = "", this.done = !0, this;
    t += Math.max(0, e < 0 ? this.pos - this.to : this.from - this.pos);
    let i = e < 0 ? this.pos - this.from : this.to - this.pos;
    t > i && (t = i), i -= t;
    let { value: n } = this.cursor.next(t);
    return this.pos += (n.length + t) * e, this.value = n.length <= i ? n : e < 0 ? n.slice(n.length - i) : n.slice(0, i), this.done = !this.value, this;
  }
  next(t = 0) {
    return t < 0 ? t = Math.max(t, this.from - this.pos) : t > 0 && (t = Math.min(t, this.to - this.pos)), this.nextInner(t, this.cursor.dir);
  }
  get lineBreak() {
    return this.cursor.lineBreak && this.value != "";
  }
}
class Ko {
  constructor(t) {
    this.inner = t, this.afterBreak = !0, this.value = "", this.done = !1;
  }
  next(t = 0) {
    let { done: e, lineBreak: i, value: n } = this.inner.next(t);
    return e ? (this.done = !0, this.value = "") : i ? this.afterBreak ? this.value = "" : (this.afterBreak = !0, this.next()) : (this.value = n, this.afterBreak = !1), this;
  }
  get lineBreak() {
    return !1;
  }
}
typeof Symbol < "u" && (I.prototype[Symbol.iterator] = function() {
  return this.iter();
}, ri.prototype[Symbol.iterator] = Go.prototype[Symbol.iterator] = Ko.prototype[Symbol.iterator] = function() {
  return this;
});
class Sc {
  constructor(t, e, i, n) {
    this.from = t, this.to = e, this.number = i, this.text = n;
  }
  get length() {
    return this.to - this.from;
  }
}
let Ie = /* @__PURE__ */ "lc,34,7n,7,7b,19,,,,2,,2,,,20,b,1c,l,g,,2t,7,2,6,2,2,,4,z,,u,r,2j,b,1m,9,9,,o,4,,9,,3,,5,17,3,3b,f,,w,1j,,,,4,8,4,,3,7,a,2,t,,1m,,,,2,4,8,,9,,a,2,q,,2,2,1l,,4,2,4,2,2,3,3,,u,2,3,,b,2,1l,,4,5,,2,4,,k,2,m,6,,,1m,,,2,,4,8,,7,3,a,2,u,,1n,,,,c,,9,,14,,3,,1l,3,5,3,,4,7,2,b,2,t,,1m,,2,,2,,3,,5,2,7,2,b,2,s,2,1l,2,,,2,4,8,,9,,a,2,t,,20,,4,,2,3,,,8,,29,,2,7,c,8,2q,,2,9,b,6,22,2,r,,,,,,1j,e,,5,,2,5,b,,10,9,,2u,4,,6,,2,2,2,p,2,4,3,g,4,d,,2,2,6,,f,,jj,3,qa,3,t,3,t,2,u,2,1s,2,,7,8,,2,b,9,,19,3,3b,2,y,,3a,3,4,2,9,,6,3,63,2,2,,1m,,,7,,,,,2,8,6,a,2,,1c,h,1r,4,1c,7,,,5,,14,9,c,2,w,4,2,2,,3,1k,,,2,3,,,3,1m,8,2,2,48,3,,d,,7,4,,6,,3,2,5i,1m,,5,ek,,5f,x,2da,3,3x,,2o,w,fe,6,2x,2,n9w,4,,a,w,2,28,2,7k,,3,,4,,p,2,5,,47,2,q,i,d,,12,8,p,b,1a,3,1c,,2,4,2,2,13,,1v,6,2,2,2,2,c,,8,,1b,,1f,,,3,2,2,5,2,,,16,2,8,,6m,,2,,4,,fn4,,kh,g,g,g,a6,2,gt,,6a,,45,5,1ae,3,,2,5,4,14,3,4,,4l,2,fx,4,ar,2,49,b,4w,,1i,f,1k,3,1d,4,2,2,1x,3,10,5,,8,1q,,c,2,1g,9,a,4,2,,2n,3,2,,,2,6,,4g,,3,8,l,2,1l,2,,,,,m,,e,7,3,5,5f,8,2,3,,,n,,29,,2,6,,,2,,,2,,2,6j,,2,4,6,2,,2,r,2,2d,8,2,,,2,2y,,,,2,6,,,2t,3,2,4,,5,77,9,,2,6t,,a,2,,,4,,40,4,2,2,4,,w,a,14,6,2,4,8,,9,6,2,3,1a,d,,2,ba,7,,6,,,2a,m,2,7,,2,,2,3e,6,3,,,2,,7,,,20,2,3,,,,9n,2,f0b,5,1n,7,t4,,1r,4,29,,f5k,2,43q,,,3,4,5,8,8,2,7,u,4,44,3,1iz,1j,4,1e,8,,e,,m,5,,f,11s,7,,h,2,7,,2,,5,79,7,c5,4,15s,7,31,7,240,5,gx7k,2o,3k,6o".split(",").map((s) => s ? parseInt(s, 36) : 1);
for (let s = 1; s < Ie.length; s++)
  Ie[s] += Ie[s - 1];
function Cc(s) {
  for (let t = 1; t < Ie.length; t += 2)
    if (Ie[t] > s)
      return Ie[t - 1] <= s;
  return !1;
}
function cr(s) {
  return s >= 127462 && s <= 127487;
}
const fr = 8205;
function xt(s, t, e = !0, i = !0) {
  return (e ? Uo : Ac)(s, t, i);
}
function Uo(s, t, e) {
  if (t == s.length)
    return t;
  t && Qo(s.charCodeAt(t)) && Jo(s.charCodeAt(t - 1)) && t--;
  let i = oi(s, t);
  for (t += es(i); t < s.length; ) {
    let n = oi(s, t);
    if (i == fr || n == fr || e && Cc(n))
      t += es(n), i = n;
    else if (cr(n)) {
      let r = 0, o = t - 2;
      for (; o >= 0 && cr(oi(s, o)); )
        r++, o -= 2;
      if (r % 2 == 0)
        break;
      t += 2;
    } else
      break;
  }
  return t;
}
function Ac(s, t, e) {
  for (; t > 0; ) {
    let i = Uo(s, t - 2, e);
    if (i < t)
      return i;
    t--;
  }
  return 0;
}
function Qo(s) {
  return s >= 56320 && s < 57344;
}
function Jo(s) {
  return s >= 55296 && s < 56320;
}
function oi(s, t) {
  let e = s.charCodeAt(t);
  if (!Jo(e) || t + 1 == s.length)
    return e;
  let i = s.charCodeAt(t + 1);
  return Qo(i) ? (e - 55296 << 10) + (i - 56320) + 65536 : e;
}
function es(s) {
  return s < 65536 ? 1 : 2;
}
const is = /\r\n?|\n/;
var pt = /* @__PURE__ */ function(s) {
  return s[s.Simple = 0] = "Simple", s[s.TrackDel = 1] = "TrackDel", s[s.TrackBefore = 2] = "TrackBefore", s[s.TrackAfter = 3] = "TrackAfter", s;
}(pt || (pt = {}));
class Xt {
  constructor(t) {
    this.sections = t;
  }
  get length() {
    let t = 0;
    for (let e = 0; e < this.sections.length; e += 2)
      t += this.sections[e];
    return t;
  }
  get newLength() {
    let t = 0;
    for (let e = 0; e < this.sections.length; e += 2) {
      let i = this.sections[e + 1];
      t += i < 0 ? this.sections[e] : i;
    }
    return t;
  }
  get empty() {
    return this.sections.length == 0 || this.sections.length == 2 && this.sections[1] < 0;
  }
  iterGaps(t) {
    for (let e = 0, i = 0, n = 0; e < this.sections.length; ) {
      let r = this.sections[e++], o = this.sections[e++];
      o < 0 ? (t(i, n, r), n += r) : n += o, i += r;
    }
  }
  iterChangedRanges(t, e = !1) {
    ns(this, t, e);
  }
  get invertedDesc() {
    let t = [];
    for (let e = 0; e < this.sections.length; ) {
      let i = this.sections[e++], n = this.sections[e++];
      n < 0 ? t.push(i, n) : t.push(n, i);
    }
    return new Xt(t);
  }
  composeDesc(t) {
    return this.empty ? t : t.empty ? this : Xo(this, t);
  }
  mapDesc(t, e = !1) {
    return t.empty ? this : ss(this, t, e);
  }
  mapPos(t, e = -1, i = pt.Simple) {
    let n = 0, r = 0;
    for (let o = 0; o < this.sections.length; ) {
      let l = this.sections[o++], h = this.sections[o++], a = n + l;
      if (h < 0) {
        if (a > t)
          return r + (t - n);
        r += l;
      } else {
        if (i != pt.Simple && a >= t && (i == pt.TrackDel && n < t && a > t || i == pt.TrackBefore && n < t || i == pt.TrackAfter && a > t))
          return null;
        if (a > t || a == t && e < 0 && !l)
          return t == n || e < 0 ? r : r + h;
        r += h;
      }
      n = a;
    }
    if (t > n)
      throw new RangeError(`Position ${t} is out of range for changeset of length ${n}`);
    return r;
  }
  touchesRange(t, e = t) {
    for (let i = 0, n = 0; i < this.sections.length && n <= e; ) {
      let r = this.sections[i++], o = this.sections[i++], l = n + r;
      if (o >= 0 && n <= e && l >= t)
        return n < t && l > e ? "cover" : !0;
      n = l;
    }
    return !1;
  }
  toString() {
    let t = "";
    for (let e = 0; e < this.sections.length; ) {
      let i = this.sections[e++], n = this.sections[e++];
      t += (t ? " " : "") + i + (n >= 0 ? ":" + n : "");
    }
    return t;
  }
  toJSON() {
    return this.sections;
  }
  static fromJSON(t) {
    if (!Array.isArray(t) || t.length % 2 || t.some((e) => typeof e != "number"))
      throw new RangeError("Invalid JSON representation of ChangeDesc");
    return new Xt(t);
  }
  static create(t) {
    return new Xt(t);
  }
}
class Y extends Xt {
  constructor(t, e) {
    super(t), this.inserted = e;
  }
  apply(t) {
    if (this.length != t.length)
      throw new RangeError("Applying change set to a document with the wrong length");
    return ns(this, (e, i, n, r, o) => t = t.replace(n, n + (i - e), o), !1), t;
  }
  mapDesc(t, e = !1) {
    return ss(this, t, e, !0);
  }
  invert(t) {
    let e = this.sections.slice(), i = [];
    for (let n = 0, r = 0; n < e.length; n += 2) {
      let o = e[n], l = e[n + 1];
      if (l >= 0) {
        e[n] = l, e[n + 1] = o;
        let h = n >> 1;
        for (; i.length < h; )
          i.push(I.empty);
        i.push(o ? t.slice(r, r + o) : I.empty);
      }
      r += o;
    }
    return new Y(e, i);
  }
  compose(t) {
    return this.empty ? t : t.empty ? this : Xo(this, t, !0);
  }
  map(t, e = !1) {
    return t.empty ? this : ss(this, t, e, !0);
  }
  iterChanges(t, e = !1) {
    ns(this, t, e);
  }
  get desc() {
    return Xt.create(this.sections);
  }
  filter(t) {
    let e = [], i = [], n = [], r = new ai(this);
    t:
      for (let o = 0, l = 0; ; ) {
        let h = o == t.length ? 1e9 : t[o++];
        for (; l < h || l == h && r.len == 0; ) {
          if (r.done)
            break t;
          let c = Math.min(r.len, h - l);
          ot(n, c, -1);
          let f = r.ins == -1 ? -1 : r.off == 0 ? r.ins : 0;
          ot(e, c, f), f > 0 && oe(i, e, r.text), r.forward(c), l += c;
        }
        let a = t[o++];
        for (; l < a; ) {
          if (r.done)
            break t;
          let c = Math.min(r.len, a - l);
          ot(e, c, -1), ot(n, c, r.ins == -1 ? -1 : r.off == 0 ? r.ins : 0), r.forward(c), l += c;
        }
      }
    return {
      changes: new Y(e, i),
      filtered: Xt.create(n)
    };
  }
  toJSON() {
    let t = [];
    for (let e = 0; e < this.sections.length; e += 2) {
      let i = this.sections[e], n = this.sections[e + 1];
      n < 0 ? t.push(i) : n == 0 ? t.push([i]) : t.push([i].concat(this.inserted[e >> 1].toJSON()));
    }
    return t;
  }
  static of(t, e, i) {
    let n = [], r = [], o = 0, l = null;
    function h(c = !1) {
      if (!c && !n.length)
        return;
      o < e && ot(n, e - o, -1);
      let f = new Y(n, r);
      l = l ? l.compose(f.map(l)) : f, n = [], r = [], o = 0;
    }
    function a(c) {
      if (Array.isArray(c))
        for (let f of c)
          a(f);
      else if (c instanceof Y) {
        if (c.length != e)
          throw new RangeError(`Mismatched change set length (got ${c.length}, expected ${e})`);
        h(), l = l ? l.compose(c.map(l)) : c;
      } else {
        let { from: f, to: u = f, insert: d } = c;
        if (f > u || f < 0 || u > e)
          throw new RangeError(`Invalid change range ${f} to ${u} (in doc of length ${e})`);
        let p = d ? typeof d == "string" ? I.of(d.split(i || is)) : d : I.empty, w = p.length;
        if (f == u && w == 0)
          return;
        f < o && h(), f > o && ot(n, f - o, -1), ot(n, u - f, w), oe(r, n, p), o = u;
      }
    }
    return a(t), h(!l), l;
  }
  static empty(t) {
    return new Y(t ? [t, -1] : [], []);
  }
  static fromJSON(t) {
    if (!Array.isArray(t))
      throw new RangeError("Invalid JSON representation of ChangeSet");
    let e = [], i = [];
    for (let n = 0; n < t.length; n++) {
      let r = t[n];
      if (typeof r == "number")
        e.push(r, -1);
      else {
        if (!Array.isArray(r) || typeof r[0] != "number" || r.some((o, l) => l && typeof o != "string"))
          throw new RangeError("Invalid JSON representation of ChangeSet");
        if (r.length == 1)
          e.push(r[0], 0);
        else {
          for (; i.length < n; )
            i.push(I.empty);
          i[n] = I.of(r.slice(1)), e.push(r[0], i[n].length);
        }
      }
    }
    return new Y(e, i);
  }
  static createSet(t, e) {
    return new Y(t, e);
  }
}
function ot(s, t, e, i = !1) {
  if (t == 0 && e <= 0)
    return;
  let n = s.length - 2;
  n >= 0 && e <= 0 && e == s[n + 1] ? s[n] += t : t == 0 && s[n] == 0 ? s[n + 1] += e : i ? (s[n] += t, s[n + 1] += e) : s.push(t, e);
}
function oe(s, t, e) {
  if (e.length == 0)
    return;
  let i = t.length - 2 >> 1;
  if (i < s.length)
    s[s.length - 1] = s[s.length - 1].append(e);
  else {
    for (; s.length < i; )
      s.push(I.empty);
    s.push(e);
  }
}
function ns(s, t, e) {
  let i = s.inserted;
  for (let n = 0, r = 0, o = 0; o < s.sections.length; ) {
    let l = s.sections[o++], h = s.sections[o++];
    if (h < 0)
      n += l, r += l;
    else {
      let a = n, c = r, f = I.empty;
      for (; a += l, c += h, h && i && (f = f.append(i[o - 2 >> 1])), !(e || o == s.sections.length || s.sections[o + 1] < 0); )
        l = s.sections[o++], h = s.sections[o++];
      t(n, a, r, c, f), n = a, r = c;
    }
  }
}
function ss(s, t, e, i = !1) {
  let n = [], r = i ? [] : null, o = new ai(s), l = new ai(t);
  for (let h = -1; ; )
    if (o.ins == -1 && l.ins == -1) {
      let a = Math.min(o.len, l.len);
      ot(n, a, -1), o.forward(a), l.forward(a);
    } else if (l.ins >= 0 && (o.ins < 0 || h == o.i || o.off == 0 && (l.len < o.len || l.len == o.len && !e))) {
      let a = l.len;
      for (ot(n, l.ins, -1); a; ) {
        let c = Math.min(o.len, a);
        o.ins >= 0 && h < o.i && o.len <= c && (ot(n, 0, o.ins), r && oe(r, n, o.text), h = o.i), o.forward(c), a -= c;
      }
      l.next();
    } else if (o.ins >= 0) {
      let a = 0, c = o.len;
      for (; c; )
        if (l.ins == -1) {
          let f = Math.min(c, l.len);
          a += f, c -= f, l.forward(f);
        } else if (l.ins == 0 && l.len < c)
          c -= l.len, l.next();
        else
          break;
      ot(n, a, h < o.i ? o.ins : 0), r && h < o.i && oe(r, n, o.text), h = o.i, o.forward(o.len - c);
    } else {
      if (o.done && l.done)
        return r ? Y.createSet(n, r) : Xt.create(n);
      throw new Error("Mismatched change set lengths");
    }
}
function Xo(s, t, e = !1) {
  let i = [], n = e ? [] : null, r = new ai(s), o = new ai(t);
  for (let l = !1; ; ) {
    if (r.done && o.done)
      return n ? Y.createSet(i, n) : Xt.create(i);
    if (r.ins == 0)
      ot(i, r.len, 0, l), r.next();
    else if (o.len == 0 && !o.done)
      ot(i, 0, o.ins, l), n && oe(n, i, o.text), o.next();
    else {
      if (r.done || o.done)
        throw new Error("Mismatched change set lengths");
      {
        let h = Math.min(r.len2, o.len), a = i.length;
        if (r.ins == -1) {
          let c = o.ins == -1 ? -1 : o.off ? 0 : o.ins;
          ot(i, h, c, l), n && c && oe(n, i, o.text);
        } else
          o.ins == -1 ? (ot(i, r.off ? 0 : r.len, h, l), n && oe(n, i, r.textBit(h))) : (ot(i, r.off ? 0 : r.len, o.off ? 0 : o.ins, l), n && !o.off && oe(n, i, o.text));
        l = (r.ins > h || o.ins >= 0 && o.len > h) && (l || i.length > a), r.forward2(h), o.forward(h);
      }
    }
  }
}
class ai {
  constructor(t) {
    this.set = t, this.i = 0, this.next();
  }
  next() {
    let { sections: t } = this.set;
    this.i < t.length ? (this.len = t[this.i++], this.ins = t[this.i++]) : (this.len = 0, this.ins = -2), this.off = 0;
  }
  get done() {
    return this.ins == -2;
  }
  get len2() {
    return this.ins < 0 ? this.len : this.ins;
  }
  get text() {
    let { inserted: t } = this.set, e = this.i - 2 >> 1;
    return e >= t.length ? I.empty : t[e];
  }
  textBit(t) {
    let { inserted: e } = this.set, i = this.i - 2 >> 1;
    return i >= e.length && !t ? I.empty : e[i].slice(this.off, t == null ? void 0 : this.off + t);
  }
  forward(t) {
    t == this.len ? this.next() : (this.len -= t, this.off += t);
  }
  forward2(t) {
    this.ins == -1 ? this.forward(t) : t == this.ins ? this.next() : (this.ins -= t, this.off += t);
  }
}
class Ce {
  constructor(t, e, i) {
    this.from = t, this.to = e, this.flags = i;
  }
  get anchor() {
    return this.flags & 16 ? this.to : this.from;
  }
  get head() {
    return this.flags & 16 ? this.from : this.to;
  }
  get empty() {
    return this.from == this.to;
  }
  get assoc() {
    return this.flags & 4 ? -1 : this.flags & 8 ? 1 : 0;
  }
  get bidiLevel() {
    let t = this.flags & 3;
    return t == 3 ? null : t;
  }
  get goalColumn() {
    let t = this.flags >> 5;
    return t == 33554431 ? void 0 : t;
  }
  map(t, e = -1) {
    let i, n;
    return this.empty ? i = n = t.mapPos(this.from, e) : (i = t.mapPos(this.from, 1), n = t.mapPos(this.to, -1)), i == this.from && n == this.to ? this : new Ce(i, n, this.flags);
  }
  extend(t, e = t) {
    if (t <= this.anchor && e >= this.anchor)
      return k.range(t, e);
    let i = Math.abs(t - this.anchor) > Math.abs(e - this.anchor) ? t : e;
    return k.range(this.anchor, i);
  }
  eq(t) {
    return this.anchor == t.anchor && this.head == t.head;
  }
  toJSON() {
    return { anchor: this.anchor, head: this.head };
  }
  static fromJSON(t) {
    if (!t || typeof t.anchor != "number" || typeof t.head != "number")
      throw new RangeError("Invalid JSON representation for SelectionRange");
    return k.range(t.anchor, t.head);
  }
  static create(t, e, i) {
    return new Ce(t, e, i);
  }
}
class k {
  constructor(t, e) {
    this.ranges = t, this.mainIndex = e;
  }
  map(t, e = -1) {
    return t.empty ? this : k.create(this.ranges.map((i) => i.map(t, e)), this.mainIndex);
  }
  eq(t) {
    if (this.ranges.length != t.ranges.length || this.mainIndex != t.mainIndex)
      return !1;
    for (let e = 0; e < this.ranges.length; e++)
      if (!this.ranges[e].eq(t.ranges[e]))
        return !1;
    return !0;
  }
  get main() {
    return this.ranges[this.mainIndex];
  }
  asSingle() {
    return this.ranges.length == 1 ? this : new k([this.main], 0);
  }
  addRange(t, e = !0) {
    return k.create([t].concat(this.ranges), e ? 0 : this.mainIndex + 1);
  }
  replaceRange(t, e = this.mainIndex) {
    let i = this.ranges.slice();
    return i[e] = t, k.create(i, this.mainIndex);
  }
  toJSON() {
    return { ranges: this.ranges.map((t) => t.toJSON()), main: this.mainIndex };
  }
  static fromJSON(t) {
    if (!t || !Array.isArray(t.ranges) || typeof t.main != "number" || t.main >= t.ranges.length)
      throw new RangeError("Invalid JSON representation for EditorSelection");
    return new k(t.ranges.map((e) => Ce.fromJSON(e)), t.main);
  }
  static single(t, e = t) {
    return new k([k.range(t, e)], 0);
  }
  static create(t, e = 0) {
    if (t.length == 0)
      throw new RangeError("A selection needs at least one range");
    for (let i = 0, n = 0; n < t.length; n++) {
      let r = t[n];
      if (r.empty ? r.from <= i : r.from < i)
        return k.normalized(t.slice(), e);
      i = r.to;
    }
    return new k(t, e);
  }
  static cursor(t, e = 0, i, n) {
    return Ce.create(t, t, (e == 0 ? 0 : e < 0 ? 4 : 8) | (i == null ? 3 : Math.min(2, i)) | (n != null ? n : 33554431) << 5);
  }
  static range(t, e, i) {
    let n = (i != null ? i : 33554431) << 5;
    return e < t ? Ce.create(e, t, 16 | n | 8) : Ce.create(t, e, n | (e > t ? 4 : 0));
  }
  static normalized(t, e = 0) {
    let i = t[e];
    t.sort((n, r) => n.from - r.from), e = t.indexOf(i);
    for (let n = 1; n < t.length; n++) {
      let r = t[n], o = t[n - 1];
      if (r.empty ? r.from <= o.to : r.from < o.to) {
        let l = o.from, h = Math.max(r.to, o.to);
        n <= e && e--, t.splice(--n, 2, r.anchor > r.head ? k.range(h, l) : k.range(l, h));
      }
    }
    return new k(t, e);
  }
}
function Yo(s, t) {
  for (let e of s.ranges)
    if (e.to > t)
      throw new RangeError("Selection points outside of document");
}
let Fs = 0;
class v {
  constructor(t, e, i, n, r) {
    this.combine = t, this.compareInput = e, this.compare = i, this.isStatic = n, this.id = Fs++, this.default = t([]), this.extensions = typeof r == "function" ? r(this) : r;
  }
  static define(t = {}) {
    return new v(t.combine || ((e) => e), t.compareInput || ((e, i) => e === i), t.compare || (t.combine ? (e, i) => e === i : zs), !!t.static, t.enables);
  }
  of(t) {
    return new Fi([], this, 0, t);
  }
  compute(t, e) {
    if (this.isStatic)
      throw new Error("Can't compute a static facet");
    return new Fi(t, this, 1, e);
  }
  computeN(t, e) {
    if (this.isStatic)
      throw new Error("Can't compute a static facet");
    return new Fi(t, this, 2, e);
  }
  from(t, e) {
    return e || (e = (i) => i), this.compute([t], (i) => e(i.field(t)));
  }
}
function zs(s, t) {
  return s == t || s.length == t.length && s.every((e, i) => e === t[i]);
}
class Fi {
  constructor(t, e, i, n) {
    this.dependencies = t, this.facet = e, this.type = i, this.value = n, this.id = Fs++;
  }
  dynamicSlot(t) {
    var e;
    let i = this.value, n = this.facet.compareInput, r = this.id, o = t[r] >> 1, l = this.type == 2, h = !1, a = !1, c = [];
    for (let f of this.dependencies)
      f == "doc" ? h = !0 : f == "selection" ? a = !0 : (((e = t[f.id]) !== null && e !== void 0 ? e : 1) & 1) == 0 && c.push(t[f.id]);
    return {
      create(f) {
        return f.values[o] = i(f), 1;
      },
      update(f, u) {
        if (h && u.docChanged || a && (u.docChanged || u.selection) || rs(f, c)) {
          let d = i(f);
          if (l ? !ur(d, f.values[o], n) : !n(d, f.values[o]))
            return f.values[o] = d, 1;
        }
        return 0;
      },
      reconfigure: (f, u) => {
        let d = i(f), p = u.config.address[r];
        if (p != null) {
          let w = Yi(u, p);
          if (this.dependencies.every((g) => g instanceof v ? u.facet(g) === f.facet(g) : g instanceof Bt ? u.field(g, !1) == f.field(g, !1) : !0) || (l ? ur(d, w, n) : n(d, w)))
            return f.values[o] = w, 0;
        }
        return f.values[o] = d, 1;
      }
    };
  }
}
function ur(s, t, e) {
  if (s.length != t.length)
    return !1;
  for (let i = 0; i < s.length; i++)
    if (!e(s[i], t[i]))
      return !1;
  return !0;
}
function rs(s, t) {
  let e = !1;
  for (let i of t)
    li(s, i) & 1 && (e = !0);
  return e;
}
function Oc(s, t, e) {
  let i = e.map((h) => s[h.id]), n = e.map((h) => h.type), r = i.filter((h) => !(h & 1)), o = s[t.id] >> 1;
  function l(h) {
    let a = [];
    for (let c = 0; c < i.length; c++) {
      let f = Yi(h, i[c]);
      if (n[c] == 2)
        for (let u of f)
          a.push(u);
      else
        a.push(f);
    }
    return t.combine(a);
  }
  return {
    create(h) {
      for (let a of i)
        li(h, a);
      return h.values[o] = l(h), 1;
    },
    update(h, a) {
      if (!rs(h, r))
        return 0;
      let c = l(h);
      return t.compare(c, h.values[o]) ? 0 : (h.values[o] = c, 1);
    },
    reconfigure(h, a) {
      let c = rs(h, i), f = a.config.facets[t.id], u = a.facet(t);
      if (f && !c && zs(e, f))
        return h.values[o] = u, 0;
      let d = l(h);
      return t.compare(d, u) ? (h.values[o] = u, 0) : (h.values[o] = d, 1);
    }
  };
}
const dr = /* @__PURE__ */ v.define({ static: !0 });
class Bt {
  constructor(t, e, i, n, r) {
    this.id = t, this.createF = e, this.updateF = i, this.compareF = n, this.spec = r, this.provides = void 0;
  }
  static define(t) {
    let e = new Bt(Fs++, t.create, t.update, t.compare || ((i, n) => i === n), t);
    return t.provide && (e.provides = t.provide(e)), e;
  }
  create(t) {
    let e = t.facet(dr).find((i) => i.field == this);
    return ((e == null ? void 0 : e.create) || this.createF)(t);
  }
  slot(t) {
    let e = t[this.id] >> 1;
    return {
      create: (i) => (i.values[e] = this.create(i), 1),
      update: (i, n) => {
        let r = i.values[e], o = this.updateF(r, n);
        return this.compareF(r, o) ? 0 : (i.values[e] = o, 1);
      },
      reconfigure: (i, n) => n.config.address[this.id] != null ? (i.values[e] = n.field(this), 0) : (i.values[e] = this.create(i), 1)
    };
  }
  init(t) {
    return [this, dr.of({ field: this, create: t })];
  }
  get extension() {
    return this;
  }
}
const ve = { lowest: 4, low: 3, default: 2, high: 1, highest: 0 };
function Xe(s) {
  return (t) => new Zo(t, s);
}
const _s = {
  highest: /* @__PURE__ */ Xe(ve.highest),
  high: /* @__PURE__ */ Xe(ve.high),
  default: /* @__PURE__ */ Xe(ve.default),
  low: /* @__PURE__ */ Xe(ve.low),
  lowest: /* @__PURE__ */ Xe(ve.lowest)
};
class Zo {
  constructor(t, e) {
    this.inner = t, this.prec = e;
  }
}
class yi {
  of(t) {
    return new os(this, t);
  }
  reconfigure(t) {
    return yi.reconfigure.of({ compartment: this, extension: t });
  }
  get(t) {
    return t.config.compartments.get(this);
  }
}
class os {
  constructor(t, e) {
    this.compartment = t, this.inner = e;
  }
}
class Xi {
  constructor(t, e, i, n, r, o) {
    for (this.base = t, this.compartments = e, this.dynamicSlots = i, this.address = n, this.staticValues = r, this.facets = o, this.statusTemplate = []; this.statusTemplate.length < i.length; )
      this.statusTemplate.push(0);
  }
  staticFacet(t) {
    let e = this.address[t.id];
    return e == null ? t.default : this.staticValues[e >> 1];
  }
  static resolve(t, e, i) {
    let n = [], r = /* @__PURE__ */ Object.create(null), o = /* @__PURE__ */ new Map();
    for (let u of Mc(t, e, o))
      u instanceof Bt ? n.push(u) : (r[u.facet.id] || (r[u.facet.id] = [])).push(u);
    let l = /* @__PURE__ */ Object.create(null), h = [], a = [];
    for (let u of n)
      l[u.id] = a.length << 1, a.push((d) => u.slot(d));
    let c = i == null ? void 0 : i.config.facets;
    for (let u in r) {
      let d = r[u], p = d[0].facet, w = c && c[u] || [];
      if (d.every((g) => g.type == 0))
        if (l[p.id] = h.length << 1 | 1, zs(w, d))
          h.push(i.facet(p));
        else {
          let g = p.combine(d.map((y) => y.value));
          h.push(i && p.compare(g, i.facet(p)) ? i.facet(p) : g);
        }
      else {
        for (let g of d)
          g.type == 0 ? (l[g.id] = h.length << 1 | 1, h.push(g.value)) : (l[g.id] = a.length << 1, a.push((y) => g.dynamicSlot(y)));
        l[p.id] = a.length << 1, a.push((g) => Oc(g, p, d));
      }
    }
    let f = a.map((u) => u(l));
    return new Xi(t, o, f, l, h, r);
  }
}
function Mc(s, t, e) {
  let i = [[], [], [], [], []], n = /* @__PURE__ */ new Map();
  function r(o, l) {
    let h = n.get(o);
    if (h != null) {
      if (h <= l)
        return;
      let a = i[h].indexOf(o);
      a > -1 && i[h].splice(a, 1), o instanceof os && e.delete(o.compartment);
    }
    if (n.set(o, l), Array.isArray(o))
      for (let a of o)
        r(a, l);
    else if (o instanceof os) {
      if (e.has(o.compartment))
        throw new RangeError("Duplicate use of compartment in extensions");
      let a = t.get(o.compartment) || o.inner;
      e.set(o.compartment, a), r(a, l);
    } else if (o instanceof Zo)
      r(o.inner, o.prec);
    else if (o instanceof Bt)
      i[l].push(o), o.provides && r(o.provides, l);
    else if (o instanceof Fi)
      i[l].push(o), o.facet.extensions && r(o.facet.extensions, ve.default);
    else {
      let a = o.extension;
      if (!a)
        throw new Error(`Unrecognized extension value in extension set (${o}). This sometimes happens because multiple instances of @codemirror/state are loaded, breaking instanceof checks.`);
      r(a, l);
    }
  }
  return r(s, ve.default), i.reduce((o, l) => o.concat(l));
}
function li(s, t) {
  if (t & 1)
    return 2;
  let e = t >> 1, i = s.status[e];
  if (i == 4)
    throw new Error("Cyclic dependency between fields and/or facets");
  if (i & 2)
    return i;
  s.status[e] = 4;
  let n = s.computeSlot(s, s.config.dynamicSlots[e]);
  return s.status[e] = 2 | n;
}
function Yi(s, t) {
  return t & 1 ? s.config.staticValues[t >> 1] : s.values[t >> 1];
}
const tl = /* @__PURE__ */ v.define(), el = /* @__PURE__ */ v.define({
  combine: (s) => s.some((t) => t),
  static: !0
}), il = /* @__PURE__ */ v.define({
  combine: (s) => s.length ? s[0] : void 0,
  static: !0
}), nl = /* @__PURE__ */ v.define(), sl = /* @__PURE__ */ v.define(), rl = /* @__PURE__ */ v.define(), ol = /* @__PURE__ */ v.define({
  combine: (s) => s.length ? s[0] : !1
});
class bi {
  constructor(t, e) {
    this.type = t, this.value = e;
  }
  static define() {
    return new Dc();
  }
}
class Dc {
  of(t) {
    return new bi(this, t);
  }
}
class Tc {
  constructor(t) {
    this.map = t;
  }
  of(t) {
    return new F(this, t);
  }
}
class F {
  constructor(t, e) {
    this.type = t, this.value = e;
  }
  map(t) {
    let e = this.type.map(this.value, t);
    return e === void 0 ? void 0 : e == this.value ? this : new F(this.type, e);
  }
  is(t) {
    return this.type == t;
  }
  static define(t = {}) {
    return new Tc(t.map || ((e) => e));
  }
  static mapEffects(t, e) {
    if (!t.length)
      return t;
    let i = [];
    for (let n of t) {
      let r = n.map(e);
      r && i.push(r);
    }
    return i;
  }
}
F.reconfigure = /* @__PURE__ */ F.define();
F.appendConfig = /* @__PURE__ */ F.define();
class lt {
  constructor(t, e, i, n, r, o) {
    this.startState = t, this.changes = e, this.selection = i, this.effects = n, this.annotations = r, this.scrollIntoView = o, this._doc = null, this._state = null, i && Yo(i, e.newLength), r.some((l) => l.type == lt.time) || (this.annotations = r.concat(lt.time.of(Date.now())));
  }
  static create(t, e, i, n, r, o) {
    return new lt(t, e, i, n, r, o);
  }
  get newDoc() {
    return this._doc || (this._doc = this.changes.apply(this.startState.doc));
  }
  get newSelection() {
    return this.selection || this.startState.selection.map(this.changes);
  }
  get state() {
    return this._state || this.startState.applyTransaction(this), this._state;
  }
  annotation(t) {
    for (let e of this.annotations)
      if (e.type == t)
        return e.value;
  }
  get docChanged() {
    return !this.changes.empty;
  }
  get reconfigured() {
    return this.startState.config != this.state.config;
  }
  isUserEvent(t) {
    let e = this.annotation(lt.userEvent);
    return !!(e && (e == t || e.length > t.length && e.slice(0, t.length) == t && e[t.length] == "."));
  }
}
lt.time = /* @__PURE__ */ bi.define();
lt.userEvent = /* @__PURE__ */ bi.define();
lt.addToHistory = /* @__PURE__ */ bi.define();
lt.remote = /* @__PURE__ */ bi.define();
function Pc(s, t) {
  let e = [];
  for (let i = 0, n = 0; ; ) {
    let r, o;
    if (i < s.length && (n == t.length || t[n] >= s[i]))
      r = s[i++], o = s[i++];
    else if (n < t.length)
      r = t[n++], o = t[n++];
    else
      return e;
    !e.length || e[e.length - 1] < r ? e.push(r, o) : e[e.length - 1] < o && (e[e.length - 1] = o);
  }
}
function ll(s, t, e) {
  var i;
  let n, r, o;
  return e ? (n = t.changes, r = Y.empty(t.changes.length), o = s.changes.compose(t.changes)) : (n = t.changes.map(s.changes), r = s.changes.mapDesc(t.changes, !0), o = s.changes.compose(n)), {
    changes: o,
    selection: t.selection ? t.selection.map(r) : (i = s.selection) === null || i === void 0 ? void 0 : i.map(n),
    effects: F.mapEffects(s.effects, n).concat(F.mapEffects(t.effects, r)),
    annotations: s.annotations.length ? s.annotations.concat(t.annotations) : t.annotations,
    scrollIntoView: s.scrollIntoView || t.scrollIntoView
  };
}
function ls(s, t, e) {
  let i = t.selection, n = He(t.annotations);
  return t.userEvent && (n = n.concat(lt.userEvent.of(t.userEvent))), {
    changes: t.changes instanceof Y ? t.changes : Y.of(t.changes || [], e, s.facet(il)),
    selection: i && (i instanceof k ? i : k.single(i.anchor, i.head)),
    effects: He(t.effects),
    annotations: n,
    scrollIntoView: !!t.scrollIntoView
  };
}
function hl(s, t, e) {
  let i = ls(s, t.length ? t[0] : {}, s.doc.length);
  t.length && t[0].filter === !1 && (e = !1);
  for (let r = 1; r < t.length; r++) {
    t[r].filter === !1 && (e = !1);
    let o = !!t[r].sequential;
    i = ll(i, ls(s, t[r], o ? i.changes.newLength : s.doc.length), o);
  }
  let n = lt.create(s, i.changes, i.selection, i.effects, i.annotations, i.scrollIntoView);
  return Rc(e ? Bc(n) : n);
}
function Bc(s) {
  let t = s.startState, e = !0;
  for (let n of t.facet(nl)) {
    let r = n(s);
    if (r === !1) {
      e = !1;
      break;
    }
    Array.isArray(r) && (e = e === !0 ? r : Pc(e, r));
  }
  if (e !== !0) {
    let n, r;
    if (e === !1)
      r = s.changes.invertedDesc, n = Y.empty(t.doc.length);
    else {
      let o = s.changes.filter(e);
      n = o.changes, r = o.filtered.mapDesc(o.changes).invertedDesc;
    }
    s = lt.create(t, n, s.selection && s.selection.map(r), F.mapEffects(s.effects, r), s.annotations, s.scrollIntoView);
  }
  let i = t.facet(sl);
  for (let n = i.length - 1; n >= 0; n--) {
    let r = i[n](s);
    r instanceof lt ? s = r : Array.isArray(r) && r.length == 1 && r[0] instanceof lt ? s = r[0] : s = hl(t, He(r), !1);
  }
  return s;
}
function Rc(s) {
  let t = s.startState, e = t.facet(rl), i = s;
  for (let n = e.length - 1; n >= 0; n--) {
    let r = e[n](s);
    r && Object.keys(r).length && (i = ll(i, ls(t, r, s.changes.newLength), !0));
  }
  return i == s ? s : lt.create(t, s.changes, s.selection, i.effects, i.annotations, i.scrollIntoView);
}
const Lc = [];
function He(s) {
  return s == null ? Lc : Array.isArray(s) ? s : [s];
}
var Qt = /* @__PURE__ */ function(s) {
  return s[s.Word = 0] = "Word", s[s.Space = 1] = "Space", s[s.Other = 2] = "Other", s;
}(Qt || (Qt = {}));
const Ec = /[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/;
let hs;
try {
  hs = /* @__PURE__ */ new RegExp("[\\p{Alphabetic}\\p{Number}_]", "u");
} catch {
}
function Nc(s) {
  if (hs)
    return hs.test(s);
  for (let t = 0; t < s.length; t++) {
    let e = s[t];
    if (/\w/.test(e) || e > "\x80" && (e.toUpperCase() != e.toLowerCase() || Ec.test(e)))
      return !0;
  }
  return !1;
}
function Vc(s) {
  return (t) => {
    if (!/\S/.test(t))
      return Qt.Space;
    if (Nc(t))
      return Qt.Word;
    for (let e = 0; e < s.length; e++)
      if (t.indexOf(s[e]) > -1)
        return Qt.Word;
    return Qt.Other;
  };
}
class E {
  constructor(t, e, i, n, r, o) {
    this.config = t, this.doc = e, this.selection = i, this.values = n, this.status = t.statusTemplate.slice(), this.computeSlot = r, o && (o._state = this);
    for (let l = 0; l < this.config.dynamicSlots.length; l++)
      li(this, l << 1);
    this.computeSlot = null;
  }
  field(t, e = !0) {
    let i = this.config.address[t.id];
    if (i == null) {
      if (e)
        throw new RangeError("Field is not present in this state");
      return;
    }
    return li(this, i), Yi(this, i);
  }
  update(...t) {
    return hl(this, t, !0);
  }
  applyTransaction(t) {
    let e = this.config, { base: i, compartments: n } = e;
    for (let o of t.effects)
      o.is(yi.reconfigure) ? (e && (n = /* @__PURE__ */ new Map(), e.compartments.forEach((l, h) => n.set(h, l)), e = null), n.set(o.value.compartment, o.value.extension)) : o.is(F.reconfigure) ? (e = null, i = o.value) : o.is(F.appendConfig) && (e = null, i = He(i).concat(o.value));
    let r;
    e ? r = t.startState.values.slice() : (e = Xi.resolve(i, n, this), r = new E(e, this.doc, this.selection, e.dynamicSlots.map(() => null), (l, h) => h.reconfigure(l, this), null).values), new E(e, t.newDoc, t.newSelection, r, (o, l) => l.update(o, t), t);
  }
  replaceSelection(t) {
    return typeof t == "string" && (t = this.toText(t)), this.changeByRange((e) => ({
      changes: { from: e.from, to: e.to, insert: t },
      range: k.cursor(e.from + t.length)
    }));
  }
  changeByRange(t) {
    let e = this.selection, i = t(e.ranges[0]), n = this.changes(i.changes), r = [i.range], o = He(i.effects);
    for (let l = 1; l < e.ranges.length; l++) {
      let h = t(e.ranges[l]), a = this.changes(h.changes), c = a.map(n);
      for (let u = 0; u < l; u++)
        r[u] = r[u].map(c);
      let f = n.mapDesc(a, !0);
      r.push(h.range.map(f)), n = n.compose(c), o = F.mapEffects(o, c).concat(F.mapEffects(He(h.effects), f));
    }
    return {
      changes: n,
      selection: k.create(r, e.mainIndex),
      effects: o
    };
  }
  changes(t = []) {
    return t instanceof Y ? t : Y.of(t, this.doc.length, this.facet(E.lineSeparator));
  }
  toText(t) {
    return I.of(t.split(this.facet(E.lineSeparator) || is));
  }
  sliceDoc(t = 0, e = this.doc.length) {
    return this.doc.sliceString(t, e, this.lineBreak);
  }
  facet(t) {
    let e = this.config.address[t.id];
    return e == null ? t.default : (li(this, e), Yi(this, e));
  }
  toJSON(t) {
    let e = {
      doc: this.sliceDoc(),
      selection: this.selection.toJSON()
    };
    if (t)
      for (let i in t) {
        let n = t[i];
        n instanceof Bt && this.config.address[n.id] != null && (e[i] = n.spec.toJSON(this.field(t[i]), this));
      }
    return e;
  }
  static fromJSON(t, e = {}, i) {
    if (!t || typeof t.doc != "string")
      throw new RangeError("Invalid JSON representation for EditorState");
    let n = [];
    if (i) {
      for (let r in i)
        if (Object.prototype.hasOwnProperty.call(t, r)) {
          let o = i[r], l = t[r];
          n.push(o.init((h) => o.spec.fromJSON(l, h)));
        }
    }
    return E.create({
      doc: t.doc,
      selection: k.fromJSON(t.selection),
      extensions: e.extensions ? n.concat([e.extensions]) : n
    });
  }
  static create(t = {}) {
    let e = Xi.resolve(t.extensions || [], /* @__PURE__ */ new Map()), i = t.doc instanceof I ? t.doc : I.of((t.doc || "").split(e.staticFacet(E.lineSeparator) || is)), n = t.selection ? t.selection instanceof k ? t.selection : k.single(t.selection.anchor, t.selection.head) : k.single(0);
    return Yo(n, i.length), e.staticFacet(el) || (n = n.asSingle()), new E(e, i, n, e.dynamicSlots.map(() => null), (r, o) => o.create(r), null);
  }
  get tabSize() {
    return this.facet(E.tabSize);
  }
  get lineBreak() {
    return this.facet(E.lineSeparator) || `
`;
  }
  get readOnly() {
    return this.facet(ol);
  }
  phrase(t, ...e) {
    for (let i of this.facet(E.phrases))
      if (Object.prototype.hasOwnProperty.call(i, t)) {
        t = i[t];
        break;
      }
    return e.length && (t = t.replace(/\$(\$|\d*)/g, (i, n) => {
      if (n == "$")
        return "$";
      let r = +(n || 1);
      return !r || r > e.length ? i : e[r - 1];
    })), t;
  }
  languageDataAt(t, e, i = -1) {
    let n = [];
    for (let r of this.facet(tl))
      for (let o of r(this, e, i))
        Object.prototype.hasOwnProperty.call(o, t) && n.push(o[t]);
    return n;
  }
  charCategorizer(t) {
    return Vc(this.languageDataAt("wordChars", t).join(""));
  }
  wordAt(t) {
    let { text: e, from: i, length: n } = this.doc.lineAt(t), r = this.charCategorizer(t), o = t - i, l = t - i;
    for (; o > 0; ) {
      let h = xt(e, o, !1);
      if (r(e.slice(h, o)) != Qt.Word)
        break;
      o = h;
    }
    for (; l < n; ) {
      let h = xt(e, l);
      if (r(e.slice(l, h)) != Qt.Word)
        break;
      l = h;
    }
    return o == l ? null : k.range(o + i, l + i);
  }
}
E.allowMultipleSelections = el;
E.tabSize = /* @__PURE__ */ v.define({
  combine: (s) => s.length ? s[0] : 4
});
E.lineSeparator = il;
E.readOnly = ol;
E.phrases = /* @__PURE__ */ v.define({
  compare(s, t) {
    let e = Object.keys(s), i = Object.keys(t);
    return e.length == i.length && e.every((n) => s[n] == t[n]);
  }
});
E.languageData = tl;
E.changeFilter = nl;
E.transactionFilter = sl;
E.transactionExtender = rl;
yi.reconfigure = /* @__PURE__ */ F.define();
function xn(s, t, e = {}) {
  let i = {};
  for (let n of s)
    for (let r of Object.keys(n)) {
      let o = n[r], l = i[r];
      if (l === void 0)
        i[r] = o;
      else if (!(l === o || o === void 0))
        if (Object.hasOwnProperty.call(e, r))
          i[r] = e[r](l, o);
        else
          throw new Error("Config merge conflict for field " + r);
    }
  for (let n in t)
    i[n] === void 0 && (i[n] = t[n]);
  return i;
}
class _e {
  eq(t) {
    return this == t;
  }
  range(t, e = t) {
    return ci.create(t, e, this);
  }
}
_e.prototype.startSide = _e.prototype.endSide = 0;
_e.prototype.point = !1;
_e.prototype.mapMode = pt.TrackDel;
class ci {
  constructor(t, e, i) {
    this.from = t, this.to = e, this.value = i;
  }
  static create(t, e, i) {
    return new ci(t, e, i);
  }
}
function as(s, t) {
  return s.from - t.from || s.value.startSide - t.value.startSide;
}
class Ws {
  constructor(t, e, i, n) {
    this.from = t, this.to = e, this.value = i, this.maxPoint = n;
  }
  get length() {
    return this.to[this.to.length - 1];
  }
  findIndex(t, e, i, n = 0) {
    let r = i ? this.to : this.from;
    for (let o = n, l = r.length; ; ) {
      if (o == l)
        return o;
      let h = o + l >> 1, a = r[h] - t || (i ? this.value[h].endSide : this.value[h].startSide) - e;
      if (h == o)
        return a >= 0 ? o : l;
      a >= 0 ? l = h : o = h + 1;
    }
  }
  between(t, e, i, n) {
    for (let r = this.findIndex(e, -1e9, !0), o = this.findIndex(i, 1e9, !1, r); r < o; r++)
      if (n(this.from[r] + t, this.to[r] + t, this.value[r]) === !1)
        return !1;
  }
  map(t, e) {
    let i = [], n = [], r = [], o = -1, l = -1;
    for (let h = 0; h < this.value.length; h++) {
      let a = this.value[h], c = this.from[h] + t, f = this.to[h] + t, u, d;
      if (c == f) {
        let p = e.mapPos(c, a.startSide, a.mapMode);
        if (p == null || (u = d = p, a.startSide != a.endSide && (d = e.mapPos(c, a.endSide), d < u)))
          continue;
      } else if (u = e.mapPos(c, a.startSide), d = e.mapPos(f, a.endSide), u > d || u == d && a.startSide > 0 && a.endSide <= 0)
        continue;
      (d - u || a.endSide - a.startSide) < 0 || (o < 0 && (o = u), a.point && (l = Math.max(l, d - u)), i.push(a), n.push(u - o), r.push(d - o));
    }
    return { mapped: i.length ? new Ws(n, r, i, l) : null, pos: o };
  }
}
class $ {
  constructor(t, e, i, n) {
    this.chunkPos = t, this.chunk = e, this.nextLayer = i, this.maxPoint = n;
  }
  static create(t, e, i, n) {
    return new $(t, e, i, n);
  }
  get length() {
    let t = this.chunk.length - 1;
    return t < 0 ? 0 : Math.max(this.chunkEnd(t), this.nextLayer.length);
  }
  get size() {
    if (this.isEmpty)
      return 0;
    let t = this.nextLayer.size;
    for (let e of this.chunk)
      t += e.value.length;
    return t;
  }
  chunkEnd(t) {
    return this.chunkPos[t] + this.chunk[t].length;
  }
  update(t) {
    let { add: e = [], sort: i = !1, filterFrom: n = 0, filterTo: r = this.length } = t, o = t.filter;
    if (e.length == 0 && !o)
      return this;
    if (i && (e = e.slice().sort(as)), this.isEmpty)
      return e.length ? $.of(e) : this;
    let l = new al(this, null, -1).goto(0), h = 0, a = [], c = new De();
    for (; l.value || h < e.length; )
      if (h < e.length && (l.from - e[h].from || l.startSide - e[h].value.startSide) >= 0) {
        let f = e[h++];
        c.addInner(f.from, f.to, f.value) || a.push(f);
      } else
        l.rangeIndex == 1 && l.chunkIndex < this.chunk.length && (h == e.length || this.chunkEnd(l.chunkIndex) < e[h].from) && (!o || n > this.chunkEnd(l.chunkIndex) || r < this.chunkPos[l.chunkIndex]) && c.addChunk(this.chunkPos[l.chunkIndex], this.chunk[l.chunkIndex]) ? l.nextChunk() : ((!o || n > l.to || r < l.from || o(l.from, l.to, l.value)) && (c.addInner(l.from, l.to, l.value) || a.push(ci.create(l.from, l.to, l.value))), l.next());
    return c.finishInner(this.nextLayer.isEmpty && !a.length ? $.empty : this.nextLayer.update({ add: a, filter: o, filterFrom: n, filterTo: r }));
  }
  map(t) {
    if (t.empty || this.isEmpty)
      return this;
    let e = [], i = [], n = -1;
    for (let o = 0; o < this.chunk.length; o++) {
      let l = this.chunkPos[o], h = this.chunk[o], a = t.touchesRange(l, l + h.length);
      if (a === !1)
        n = Math.max(n, h.maxPoint), e.push(h), i.push(t.mapPos(l));
      else if (a === !0) {
        let { mapped: c, pos: f } = h.map(l, t);
        c && (n = Math.max(n, c.maxPoint), e.push(c), i.push(f));
      }
    }
    let r = this.nextLayer.map(t);
    return e.length == 0 ? r : new $(i, e, r || $.empty, n);
  }
  between(t, e, i) {
    if (!this.isEmpty) {
      for (let n = 0; n < this.chunk.length; n++) {
        let r = this.chunkPos[n], o = this.chunk[n];
        if (e >= r && t <= r + o.length && o.between(r, t - r, e - r, i) === !1)
          return;
      }
      this.nextLayer.between(t, e, i);
    }
  }
  iter(t = 0) {
    return fi.from([this]).goto(t);
  }
  get isEmpty() {
    return this.nextLayer == this;
  }
  static iter(t, e = 0) {
    return fi.from(t).goto(e);
  }
  static compare(t, e, i, n, r = -1) {
    let o = t.filter((f) => f.maxPoint > 0 || !f.isEmpty && f.maxPoint >= r), l = e.filter((f) => f.maxPoint > 0 || !f.isEmpty && f.maxPoint >= r), h = pr(o, l, i), a = new Ye(o, h, r), c = new Ye(l, h, r);
    i.iterGaps((f, u, d) => gr(a, f, c, u, d, n)), i.empty && i.length == 0 && gr(a, 0, c, 0, 0, n);
  }
  static eq(t, e, i = 0, n) {
    n == null && (n = 1e9);
    let r = t.filter((c) => !c.isEmpty && e.indexOf(c) < 0), o = e.filter((c) => !c.isEmpty && t.indexOf(c) < 0);
    if (r.length != o.length)
      return !1;
    if (!r.length)
      return !0;
    let l = pr(r, o), h = new Ye(r, l, 0).goto(i), a = new Ye(o, l, 0).goto(i);
    for (; ; ) {
      if (h.to != a.to || !cs(h.active, a.active) || h.point && (!a.point || !h.point.eq(a.point)))
        return !1;
      if (h.to > n)
        return !0;
      h.next(), a.next();
    }
  }
  static spans(t, e, i, n, r = -1) {
    let o = new Ye(t, null, r).goto(e), l = e, h = o.openStart;
    for (; ; ) {
      let a = Math.min(o.to, i);
      if (o.point ? (n.point(l, a, o.point, o.activeForPoint(o.to), h, o.pointRank), h = o.openEnd(a) + (o.to > a ? 1 : 0)) : a > l && (n.span(l, a, o.active, h), h = o.openEnd(a)), o.to > i)
        break;
      l = o.to, o.next();
    }
    return h;
  }
  static of(t, e = !1) {
    let i = new De();
    for (let n of t instanceof ci ? [t] : e ? Ic(t) : t)
      i.add(n.from, n.to, n.value);
    return i.finish();
  }
}
$.empty = /* @__PURE__ */ new $([], [], null, -1);
function Ic(s) {
  if (s.length > 1)
    for (let t = s[0], e = 1; e < s.length; e++) {
      let i = s[e];
      if (as(t, i) > 0)
        return s.slice().sort(as);
      t = i;
    }
  return s;
}
$.empty.nextLayer = $.empty;
class De {
  constructor() {
    this.chunks = [], this.chunkPos = [], this.chunkStart = -1, this.last = null, this.lastFrom = -1e9, this.lastTo = -1e9, this.from = [], this.to = [], this.value = [], this.maxPoint = -1, this.setMaxPoint = -1, this.nextLayer = null;
  }
  finishChunk(t) {
    this.chunks.push(new Ws(this.from, this.to, this.value, this.maxPoint)), this.chunkPos.push(this.chunkStart), this.chunkStart = -1, this.setMaxPoint = Math.max(this.setMaxPoint, this.maxPoint), this.maxPoint = -1, t && (this.from = [], this.to = [], this.value = []);
  }
  add(t, e, i) {
    this.addInner(t, e, i) || (this.nextLayer || (this.nextLayer = new De())).add(t, e, i);
  }
  addInner(t, e, i) {
    let n = t - this.lastTo || i.startSide - this.last.endSide;
    if (n <= 0 && (t - this.lastFrom || i.startSide - this.last.startSide) < 0)
      throw new Error("Ranges must be added sorted by `from` position and `startSide`");
    return n < 0 ? !1 : (this.from.length == 250 && this.finishChunk(!0), this.chunkStart < 0 && (this.chunkStart = t), this.from.push(t - this.chunkStart), this.to.push(e - this.chunkStart), this.last = i, this.lastFrom = t, this.lastTo = e, this.value.push(i), i.point && (this.maxPoint = Math.max(this.maxPoint, e - t)), !0);
  }
  addChunk(t, e) {
    if ((t - this.lastTo || e.value[0].startSide - this.last.endSide) < 0)
      return !1;
    this.from.length && this.finishChunk(!0), this.setMaxPoint = Math.max(this.setMaxPoint, e.maxPoint), this.chunks.push(e), this.chunkPos.push(t);
    let i = e.value.length - 1;
    return this.last = e.value[i], this.lastFrom = e.from[i] + t, this.lastTo = e.to[i] + t, !0;
  }
  finish() {
    return this.finishInner($.empty);
  }
  finishInner(t) {
    if (this.from.length && this.finishChunk(!1), this.chunks.length == 0)
      return t;
    let e = $.create(this.chunkPos, this.chunks, this.nextLayer ? this.nextLayer.finishInner(t) : t, this.setMaxPoint);
    return this.from = null, e;
  }
}
function pr(s, t, e) {
  let i = /* @__PURE__ */ new Map();
  for (let r of s)
    for (let o = 0; o < r.chunk.length; o++)
      r.chunk[o].maxPoint <= 0 && i.set(r.chunk[o], r.chunkPos[o]);
  let n = /* @__PURE__ */ new Set();
  for (let r of t)
    for (let o = 0; o < r.chunk.length; o++) {
      let l = i.get(r.chunk[o]);
      l != null && (e ? e.mapPos(l) : l) == r.chunkPos[o] && !(e != null && e.touchesRange(l, l + r.chunk[o].length)) && n.add(r.chunk[o]);
    }
  return n;
}
class al {
  constructor(t, e, i, n = 0) {
    this.layer = t, this.skip = e, this.minPoint = i, this.rank = n;
  }
  get startSide() {
    return this.value ? this.value.startSide : 0;
  }
  get endSide() {
    return this.value ? this.value.endSide : 0;
  }
  goto(t, e = -1e9) {
    return this.chunkIndex = this.rangeIndex = 0, this.gotoInner(t, e, !1), this;
  }
  gotoInner(t, e, i) {
    for (; this.chunkIndex < this.layer.chunk.length; ) {
      let n = this.layer.chunk[this.chunkIndex];
      if (!(this.skip && this.skip.has(n) || this.layer.chunkEnd(this.chunkIndex) < t || n.maxPoint < this.minPoint))
        break;
      this.chunkIndex++, i = !1;
    }
    if (this.chunkIndex < this.layer.chunk.length) {
      let n = this.layer.chunk[this.chunkIndex].findIndex(t - this.layer.chunkPos[this.chunkIndex], e, !0);
      (!i || this.rangeIndex < n) && this.setRangeIndex(n);
    }
    this.next();
  }
  forward(t, e) {
    (this.to - t || this.endSide - e) < 0 && this.gotoInner(t, e, !0);
  }
  next() {
    for (; ; )
      if (this.chunkIndex == this.layer.chunk.length) {
        this.from = this.to = 1e9, this.value = null;
        break;
      } else {
        let t = this.layer.chunkPos[this.chunkIndex], e = this.layer.chunk[this.chunkIndex], i = t + e.from[this.rangeIndex];
        if (this.from = i, this.to = t + e.to[this.rangeIndex], this.value = e.value[this.rangeIndex], this.setRangeIndex(this.rangeIndex + 1), this.minPoint < 0 || this.value.point && this.to - this.from >= this.minPoint)
          break;
      }
  }
  setRangeIndex(t) {
    if (t == this.layer.chunk[this.chunkIndex].value.length) {
      if (this.chunkIndex++, this.skip)
        for (; this.chunkIndex < this.layer.chunk.length && this.skip.has(this.layer.chunk[this.chunkIndex]); )
          this.chunkIndex++;
      this.rangeIndex = 0;
    } else
      this.rangeIndex = t;
  }
  nextChunk() {
    this.chunkIndex++, this.rangeIndex = 0, this.next();
  }
  compare(t) {
    return this.from - t.from || this.startSide - t.startSide || this.rank - t.rank || this.to - t.to || this.endSide - t.endSide;
  }
}
class fi {
  constructor(t) {
    this.heap = t;
  }
  static from(t, e = null, i = -1) {
    let n = [];
    for (let r = 0; r < t.length; r++)
      for (let o = t[r]; !o.isEmpty; o = o.nextLayer)
        o.maxPoint >= i && n.push(new al(o, e, i, r));
    return n.length == 1 ? n[0] : new fi(n);
  }
  get startSide() {
    return this.value ? this.value.startSide : 0;
  }
  goto(t, e = -1e9) {
    for (let i of this.heap)
      i.goto(t, e);
    for (let i = this.heap.length >> 1; i >= 0; i--)
      En(this.heap, i);
    return this.next(), this;
  }
  forward(t, e) {
    for (let i of this.heap)
      i.forward(t, e);
    for (let i = this.heap.length >> 1; i >= 0; i--)
      En(this.heap, i);
    (this.to - t || this.value.endSide - e) < 0 && this.next();
  }
  next() {
    if (this.heap.length == 0)
      this.from = this.to = 1e9, this.value = null, this.rank = -1;
    else {
      let t = this.heap[0];
      this.from = t.from, this.to = t.to, this.value = t.value, this.rank = t.rank, t.value && t.next(), En(this.heap, 0);
    }
  }
}
function En(s, t) {
  for (let e = s[t]; ; ) {
    let i = (t << 1) + 1;
    if (i >= s.length)
      break;
    let n = s[i];
    if (i + 1 < s.length && n.compare(s[i + 1]) >= 0 && (n = s[i + 1], i++), e.compare(n) < 0)
      break;
    s[i] = e, s[t] = n, t = i;
  }
}
class Ye {
  constructor(t, e, i) {
    this.minPoint = i, this.active = [], this.activeTo = [], this.activeRank = [], this.minActive = -1, this.point = null, this.pointFrom = 0, this.pointRank = 0, this.to = -1e9, this.endSide = 0, this.openStart = -1, this.cursor = fi.from(t, e, i);
  }
  goto(t, e = -1e9) {
    return this.cursor.goto(t, e), this.active.length = this.activeTo.length = this.activeRank.length = 0, this.minActive = -1, this.to = t, this.endSide = e, this.openStart = -1, this.next(), this;
  }
  forward(t, e) {
    for (; this.minActive > -1 && (this.activeTo[this.minActive] - t || this.active[this.minActive].endSide - e) < 0; )
      this.removeActive(this.minActive);
    this.cursor.forward(t, e);
  }
  removeActive(t) {
    Ci(this.active, t), Ci(this.activeTo, t), Ci(this.activeRank, t), this.minActive = mr(this.active, this.activeTo);
  }
  addActive(t) {
    let e = 0, { value: i, to: n, rank: r } = this.cursor;
    for (; e < this.activeRank.length && this.activeRank[e] <= r; )
      e++;
    Ai(this.active, e, i), Ai(this.activeTo, e, n), Ai(this.activeRank, e, r), t && Ai(t, e, this.cursor.from), this.minActive = mr(this.active, this.activeTo);
  }
  next() {
    let t = this.to, e = this.point;
    this.point = null;
    let i = this.openStart < 0 ? [] : null, n = 0;
    for (; ; ) {
      let r = this.minActive;
      if (r > -1 && (this.activeTo[r] - this.cursor.from || this.active[r].endSide - this.cursor.startSide) < 0) {
        if (this.activeTo[r] > t) {
          this.to = this.activeTo[r], this.endSide = this.active[r].endSide;
          break;
        }
        this.removeActive(r), i && Ci(i, r);
      } else if (this.cursor.value)
        if (this.cursor.from > t) {
          this.to = this.cursor.from, this.endSide = this.cursor.startSide;
          break;
        } else {
          let o = this.cursor.value;
          if (!o.point)
            this.addActive(i), this.cursor.from < t && this.cursor.to > t && n++, this.cursor.next();
          else if (e && this.cursor.to == this.to && this.cursor.from < this.cursor.to)
            this.cursor.next();
          else {
            this.point = o, this.pointFrom = this.cursor.from, this.pointRank = this.cursor.rank, this.to = this.cursor.to, this.endSide = o.endSide, this.cursor.from < t && (n = 1), this.cursor.next(), this.forward(this.to, this.endSide);
            break;
          }
        }
      else {
        this.to = this.endSide = 1e9;
        break;
      }
    }
    if (i) {
      let r = 0;
      for (; r < i.length && i[r] < t; )
        r++;
      this.openStart = r + n;
    }
  }
  activeForPoint(t) {
    if (!this.active.length)
      return this.active;
    let e = [];
    for (let i = this.active.length - 1; i >= 0 && !(this.activeRank[i] < this.pointRank); i--)
      (this.activeTo[i] > t || this.activeTo[i] == t && this.active[i].endSide >= this.point.endSide) && e.push(this.active[i]);
    return e.reverse();
  }
  openEnd(t) {
    let e = 0;
    for (let i = this.activeTo.length - 1; i >= 0 && this.activeTo[i] > t; i--)
      e++;
    return e;
  }
}
function gr(s, t, e, i, n, r) {
  s.goto(t), e.goto(i);
  let o = i + n, l = i, h = i - t;
  for (; ; ) {
    let a = s.to + h - e.to || s.endSide - e.endSide, c = a < 0 ? s.to + h : e.to, f = Math.min(c, o);
    if (s.point || e.point ? s.point && e.point && (s.point == e.point || s.point.eq(e.point)) && cs(s.activeForPoint(s.to + h), e.activeForPoint(e.to)) || r.comparePoint(l, f, s.point, e.point) : f > l && !cs(s.active, e.active) && r.compareRange(l, f, s.active, e.active), c > o)
      break;
    l = c, a <= 0 && s.next(), a >= 0 && e.next();
  }
}
function cs(s, t) {
  if (s.length != t.length)
    return !1;
  for (let e = 0; e < s.length; e++)
    if (s[e] != t[e] && !s[e].eq(t[e]))
      return !1;
  return !0;
}
function Ci(s, t) {
  for (let e = t, i = s.length - 1; e < i; e++)
    s[e] = s[e + 1];
  s.pop();
}
function Ai(s, t, e) {
  for (let i = s.length - 1; i >= t; i--)
    s[i + 1] = s[i];
  s[t] = e;
}
function mr(s, t) {
  let e = -1, i = 1e9;
  for (let n = 0; n < t.length; n++)
    (t[n] - i || s[n].endSide - s[e].endSide) < 0 && (e = n, i = t[n]);
  return e;
}
function vn(s, t, e = s.length) {
  let i = 0;
  for (let n = 0; n < e; )
    s.charCodeAt(n) == 9 ? (i += t - i % t, n++) : (i++, n = xt(s, n));
  return i;
}
function Hc(s, t, e, i) {
  for (let n = 0, r = 0; ; ) {
    if (r >= t)
      return n;
    if (n == s.length)
      break;
    r += s.charCodeAt(n) == 9 ? e - r % e : 1, n = xt(s, n);
  }
  return i === !0 ? -1 : s.length;
}
const fs = "\u037C", wr = typeof Symbol > "u" ? "__" + fs : Symbol.for(fs), us = typeof Symbol > "u" ? "__styleSet" + Math.floor(Math.random() * 1e8) : Symbol("styleSet"), yr = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : {};
class de {
  constructor(t, e) {
    this.rules = [];
    let { finish: i } = e || {};
    function n(o) {
      return /^@/.test(o) ? [o] : o.split(/,\s*/);
    }
    function r(o, l, h, a) {
      let c = [], f = /^@(\w+)\b/.exec(o[0]), u = f && f[1] == "keyframes";
      if (f && l == null)
        return h.push(o[0] + ";");
      for (let d in l) {
        let p = l[d];
        if (/&/.test(d))
          r(
            d.split(/,\s*/).map((w) => o.map((g) => w.replace(/&/, g))).reduce((w, g) => w.concat(g)),
            p,
            h
          );
        else if (p && typeof p == "object") {
          if (!f)
            throw new RangeError("The value of a property (" + d + ") should be a primitive value.");
          r(n(d), p, c, u);
        } else
          p != null && c.push(d.replace(/_.*/, "").replace(/[A-Z]/g, (w) => "-" + w.toLowerCase()) + ": " + p + ";");
      }
      (c.length || u) && h.push((i && !f && !a ? o.map(i) : o).join(", ") + " {" + c.join(" ") + "}");
    }
    for (let o in t)
      r(n(o), t[o], this.rules);
  }
  getRules() {
    return this.rules.join(`
`);
  }
  static newName() {
    let t = yr[wr] || 1;
    return yr[wr] = t + 1, fs + t.toString(36);
  }
  static mount(t, e) {
    (t[us] || new $c(t)).mount(Array.isArray(e) ? e : [e]);
  }
}
let Oi = null;
class $c {
  constructor(t) {
    if (!t.head && t.adoptedStyleSheets && typeof CSSStyleSheet < "u") {
      if (Oi)
        return t.adoptedStyleSheets = [Oi.sheet].concat(t.adoptedStyleSheets), t[us] = Oi;
      this.sheet = new CSSStyleSheet(), t.adoptedStyleSheets = [this.sheet].concat(t.adoptedStyleSheets), Oi = this;
    } else {
      this.styleTag = (t.ownerDocument || t).createElement("style");
      let e = t.head || t;
      e.insertBefore(this.styleTag, e.firstChild);
    }
    this.modules = [], t[us] = this;
  }
  mount(t) {
    let e = this.sheet, i = 0, n = 0;
    for (let r = 0; r < t.length; r++) {
      let o = t[r], l = this.modules.indexOf(o);
      if (l < n && l > -1 && (this.modules.splice(l, 1), n--, l = -1), l == -1) {
        if (this.modules.splice(n++, 0, o), e)
          for (let h = 0; h < o.rules.length; h++)
            e.insertRule(o.rules[h], i++);
      } else {
        for (; n < l; )
          i += this.modules[n++].rules.length;
        i += o.rules.length, n++;
      }
    }
    if (!e) {
      let r = "";
      for (let o = 0; o < this.modules.length; o++)
        r += this.modules[o].getRules() + `
`;
      this.styleTag.textContent = r;
    }
  }
}
var pe = {
  8: "Backspace",
  9: "Tab",
  10: "Enter",
  12: "NumLock",
  13: "Enter",
  16: "Shift",
  17: "Control",
  18: "Alt",
  20: "CapsLock",
  27: "Escape",
  32: " ",
  33: "PageUp",
  34: "PageDown",
  35: "End",
  36: "Home",
  37: "ArrowLeft",
  38: "ArrowUp",
  39: "ArrowRight",
  40: "ArrowDown",
  44: "PrintScreen",
  45: "Insert",
  46: "Delete",
  59: ";",
  61: "=",
  91: "Meta",
  92: "Meta",
  106: "*",
  107: "+",
  108: ",",
  109: "-",
  110: ".",
  111: "/",
  144: "NumLock",
  145: "ScrollLock",
  160: "Shift",
  161: "Shift",
  162: "Control",
  163: "Control",
  164: "Alt",
  165: "Alt",
  173: "-",
  186: ";",
  187: "=",
  188: ",",
  189: "-",
  190: ".",
  191: "/",
  192: "`",
  219: "[",
  220: "\\",
  221: "]",
  222: "'"
}, ui = {
  48: ")",
  49: "!",
  50: "@",
  51: "#",
  52: "$",
  53: "%",
  54: "^",
  55: "&",
  56: "*",
  57: "(",
  59: ":",
  61: "+",
  173: "_",
  186: ":",
  187: "+",
  188: "<",
  189: "_",
  190: ">",
  191: "?",
  192: "~",
  219: "{",
  220: "|",
  221: "}",
  222: '"'
}, br = typeof navigator < "u" && /Chrome\/(\d+)/.exec(navigator.userAgent);
typeof navigator < "u" && /Gecko\/\d+/.test(navigator.userAgent);
var Fc = typeof navigator < "u" && /Mac/.test(navigator.platform), zc = typeof navigator < "u" && /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent), _c = Fc || br && +br[1] < 57;
for (var nt = 0; nt < 10; nt++)
  pe[48 + nt] = pe[96 + nt] = String(nt);
for (var nt = 1; nt <= 24; nt++)
  pe[nt + 111] = "F" + nt;
for (var nt = 65; nt <= 90; nt++)
  pe[nt] = String.fromCharCode(nt + 32), ui[nt] = String.fromCharCode(nt);
for (var Nn in pe)
  ui.hasOwnProperty(Nn) || (ui[Nn] = pe[Nn]);
function Wc(s) {
  var t = _c && (s.ctrlKey || s.altKey || s.metaKey) || zc && s.shiftKey && s.key && s.key.length == 1 || s.key == "Unidentified", e = !t && s.key || (s.shiftKey ? ui : pe)[s.keyCode] || s.key || "Unidentified";
  return e == "Esc" && (e = "Escape"), e == "Del" && (e = "Delete"), e == "Left" && (e = "ArrowLeft"), e == "Up" && (e = "ArrowUp"), e == "Right" && (e = "ArrowRight"), e == "Down" && (e = "ArrowDown"), e;
}
function Zi(s) {
  let t;
  return s.nodeType == 11 ? t = s.getSelection ? s : s.ownerDocument : t = s, t.getSelection();
}
function We(s, t) {
  return t ? s == t || s.contains(t.nodeType != 1 ? t.parentNode : t) : !1;
}
function jc(s) {
  let t = s.activeElement;
  for (; t && t.shadowRoot; )
    t = t.shadowRoot.activeElement;
  return t;
}
function zi(s, t) {
  if (!t.anchorNode)
    return !1;
  try {
    return We(s, t.anchorNode);
  } catch {
    return !1;
  }
}
function di(s) {
  return s.nodeType == 3 ? je(s, 0, s.nodeValue.length).getClientRects() : s.nodeType == 1 ? s.getClientRects() : [];
}
function tn(s, t, e, i) {
  return e ? kr(s, t, e, i, -1) || kr(s, t, e, i, 1) : !1;
}
function en(s) {
  for (var t = 0; ; t++)
    if (s = s.previousSibling, !s)
      return t;
}
function kr(s, t, e, i, n) {
  for (; ; ) {
    if (s == e && t == i)
      return !0;
    if (t == (n < 0 ? 0 : pi(s))) {
      if (s.nodeName == "DIV")
        return !1;
      let r = s.parentNode;
      if (!r || r.nodeType != 1)
        return !1;
      t = en(s) + (n < 0 ? 0 : 1), s = r;
    } else if (s.nodeType == 1) {
      if (s = s.childNodes[t + (n < 0 ? -1 : 0)], s.nodeType == 1 && s.contentEditable == "false")
        return !1;
      t = n < 0 ? pi(s) : 0;
    } else
      return !1;
  }
}
function pi(s) {
  return s.nodeType == 3 ? s.nodeValue.length : s.childNodes.length;
}
const cl = { left: 0, right: 0, top: 0, bottom: 0 };
function Sn(s, t) {
  let e = t ? s.left : s.right;
  return { left: e, right: e, top: s.top, bottom: s.bottom };
}
function qc(s) {
  return {
    left: 0,
    right: s.innerWidth,
    top: 0,
    bottom: s.innerHeight
  };
}
function Gc(s, t, e, i, n, r, o, l) {
  let h = s.ownerDocument, a = h.defaultView || window;
  for (let c = s; c; )
    if (c.nodeType == 1) {
      let f, u = c == h.body;
      if (u)
        f = qc(a);
      else {
        if (c.scrollHeight <= c.clientHeight && c.scrollWidth <= c.clientWidth) {
          c = c.assignedSlot || c.parentNode;
          continue;
        }
        let w = c.getBoundingClientRect();
        f = {
          left: w.left,
          right: w.left + c.clientWidth,
          top: w.top,
          bottom: w.top + c.clientHeight
        };
      }
      let d = 0, p = 0;
      if (n == "nearest")
        t.top < f.top ? (p = -(f.top - t.top + o), e > 0 && t.bottom > f.bottom + p && (p = t.bottom - f.bottom + p + o)) : t.bottom > f.bottom && (p = t.bottom - f.bottom + o, e < 0 && t.top - p < f.top && (p = -(f.top + p - t.top + o)));
      else {
        let w = t.bottom - t.top, g = f.bottom - f.top;
        p = (n == "center" && w <= g ? t.top + w / 2 - g / 2 : n == "start" || n == "center" && e < 0 ? t.top - o : t.bottom - g + o) - f.top;
      }
      if (i == "nearest" ? t.left < f.left ? (d = -(f.left - t.left + r), e > 0 && t.right > f.right + d && (d = t.right - f.right + d + r)) : t.right > f.right && (d = t.right - f.right + r, e < 0 && t.left < f.left + d && (d = -(f.left + d - t.left + r))) : d = (i == "center" ? t.left + (t.right - t.left) / 2 - (f.right - f.left) / 2 : i == "start" == l ? t.left - r : t.right - (f.right - f.left) + r) - f.left, d || p)
        if (u)
          a.scrollBy(d, p);
        else {
          let w = 0, g = 0;
          if (p) {
            let y = c.scrollTop;
            c.scrollTop += p, g = c.scrollTop - y;
          }
          if (d) {
            let y = c.scrollLeft;
            c.scrollLeft += d, w = c.scrollLeft - y;
          }
          t = {
            left: t.left - w,
            top: t.top - g,
            right: t.right - w,
            bottom: t.bottom - g
          }, w && Math.abs(w - d) < 1 && (i = "nearest"), g && Math.abs(g - p) < 1 && (n = "nearest");
        }
      if (u)
        break;
      c = c.assignedSlot || c.parentNode;
    } else if (c.nodeType == 11)
      c = c.host;
    else
      break;
}
class Kc {
  constructor() {
    this.anchorNode = null, this.anchorOffset = 0, this.focusNode = null, this.focusOffset = 0;
  }
  eq(t) {
    return this.anchorNode == t.anchorNode && this.anchorOffset == t.anchorOffset && this.focusNode == t.focusNode && this.focusOffset == t.focusOffset;
  }
  setRange(t) {
    this.set(t.anchorNode, t.anchorOffset, t.focusNode, t.focusOffset);
  }
  set(t, e, i, n) {
    this.anchorNode = t, this.anchorOffset = e, this.focusNode = i, this.focusOffset = n;
  }
}
let Ne = null;
function fl(s) {
  if (s.setActive)
    return s.setActive();
  if (Ne)
    return s.focus(Ne);
  let t = [];
  for (let e = s; e && (t.push(e, e.scrollTop, e.scrollLeft), e != e.ownerDocument); e = e.parentNode)
    ;
  if (s.focus(Ne == null ? {
    get preventScroll() {
      return Ne = { preventScroll: !0 }, !0;
    }
  } : void 0), !Ne) {
    Ne = !1;
    for (let e = 0; e < t.length; ) {
      let i = t[e++], n = t[e++], r = t[e++];
      i.scrollTop != n && (i.scrollTop = n), i.scrollLeft != r && (i.scrollLeft = r);
    }
  }
}
let xr;
function je(s, t, e = t) {
  let i = xr || (xr = document.createRange());
  return i.setEnd(s, e), i.setStart(s, t), i;
}
function hi(s, t, e) {
  let i = { key: t, code: t, keyCode: e, which: e, cancelable: !0 }, n = new KeyboardEvent("keydown", i);
  n.synthetic = !0, s.dispatchEvent(n);
  let r = new KeyboardEvent("keyup", i);
  return r.synthetic = !0, s.dispatchEvent(r), n.defaultPrevented || r.defaultPrevented;
}
function Uc(s) {
  for (; s; ) {
    if (s && (s.nodeType == 9 || s.nodeType == 11 && s.host))
      return s;
    s = s.assignedSlot || s.parentNode;
  }
  return null;
}
function ul(s) {
  for (; s.attributes.length; )
    s.removeAttributeNode(s.attributes[0]);
}
function Qc(s, t) {
  let e = t.focusNode, i = t.focusOffset;
  if (!e || t.anchorNode != e || t.anchorOffset != i)
    return !1;
  for (; ; )
    if (i) {
      if (e.nodeType != 1)
        return !1;
      let n = e.childNodes[i - 1];
      n.contentEditable == "false" ? i-- : (e = n, i = pi(e));
    } else {
      if (e == s)
        return !0;
      i = en(e), e = e.parentNode;
    }
}
class ht {
  constructor(t, e, i = !0) {
    this.node = t, this.offset = e, this.precise = i;
  }
  static before(t, e) {
    return new ht(t.parentNode, en(t), e);
  }
  static after(t, e) {
    return new ht(t.parentNode, en(t) + 1, e);
  }
}
const js = [];
class W {
  constructor() {
    this.parent = null, this.dom = null, this.dirty = 2;
  }
  get editorView() {
    if (!this.parent)
      throw new Error("Accessing view in orphan content view");
    return this.parent.editorView;
  }
  get overrideDOMText() {
    return null;
  }
  get posAtStart() {
    return this.parent ? this.parent.posBefore(this) : 0;
  }
  get posAtEnd() {
    return this.posAtStart + this.length;
  }
  posBefore(t) {
    let e = this.posAtStart;
    for (let i of this.children) {
      if (i == t)
        return e;
      e += i.length + i.breakAfter;
    }
    throw new RangeError("Invalid child in posBefore");
  }
  posAfter(t) {
    return this.posBefore(t) + t.length;
  }
  coordsAt(t, e) {
    return null;
  }
  sync(t) {
    if (this.dirty & 2) {
      let e = this.dom, i = null, n;
      for (let r of this.children) {
        if (r.dirty) {
          if (!r.dom && (n = i ? i.nextSibling : e.firstChild)) {
            let o = W.get(n);
            (!o || !o.parent && o.canReuseDOM(r)) && r.reuseDOM(n);
          }
          r.sync(t), r.dirty = 0;
        }
        if (n = i ? i.nextSibling : e.firstChild, t && !t.written && t.node == e && n != r.dom && (t.written = !0), r.dom.parentNode == e)
          for (; n && n != r.dom; )
            n = vr(n);
        else
          e.insertBefore(r.dom, n);
        i = r.dom;
      }
      for (n = i ? i.nextSibling : e.firstChild, n && t && t.node == e && (t.written = !0); n; )
        n = vr(n);
    } else if (this.dirty & 1)
      for (let e of this.children)
        e.dirty && (e.sync(t), e.dirty = 0);
  }
  reuseDOM(t) {
  }
  localPosFromDOM(t, e) {
    let i;
    if (t == this.dom)
      i = this.dom.childNodes[e];
    else {
      let n = pi(t) == 0 ? 0 : e == 0 ? -1 : 1;
      for (; ; ) {
        let r = t.parentNode;
        if (r == this.dom)
          break;
        n == 0 && r.firstChild != r.lastChild && (t == r.firstChild ? n = -1 : n = 1), t = r;
      }
      n < 0 ? i = t : i = t.nextSibling;
    }
    if (i == this.dom.firstChild)
      return 0;
    for (; i && !W.get(i); )
      i = i.nextSibling;
    if (!i)
      return this.length;
    for (let n = 0, r = 0; ; n++) {
      let o = this.children[n];
      if (o.dom == i)
        return r;
      r += o.length + o.breakAfter;
    }
  }
  domBoundsAround(t, e, i = 0) {
    let n = -1, r = -1, o = -1, l = -1;
    for (let h = 0, a = i, c = i; h < this.children.length; h++) {
      let f = this.children[h], u = a + f.length;
      if (a < t && u > e)
        return f.domBoundsAround(t, e, a);
      if (u >= t && n == -1 && (n = h, r = a), a > e && f.dom.parentNode == this.dom) {
        o = h, l = c;
        break;
      }
      c = u, a = u + f.breakAfter;
    }
    return {
      from: r,
      to: l < 0 ? i + this.length : l,
      startDOM: (n ? this.children[n - 1].dom.nextSibling : null) || this.dom.firstChild,
      endDOM: o < this.children.length && o >= 0 ? this.children[o].dom : null
    };
  }
  markDirty(t = !1) {
    this.dirty |= 2, this.markParentsDirty(t);
  }
  markParentsDirty(t) {
    for (let e = this.parent; e; e = e.parent) {
      if (t && (e.dirty |= 2), e.dirty & 1)
        return;
      e.dirty |= 1, t = !1;
    }
  }
  setParent(t) {
    this.parent != t && (this.parent = t, this.dirty && this.markParentsDirty(!0));
  }
  setDOM(t) {
    this.dom && (this.dom.cmView = null), this.dom = t, t.cmView = this;
  }
  get rootView() {
    for (let t = this; ; ) {
      let e = t.parent;
      if (!e)
        return t;
      t = e;
    }
  }
  replaceChildren(t, e, i = js) {
    this.markDirty();
    for (let n = t; n < e; n++) {
      let r = this.children[n];
      r.parent == this && r.destroy();
    }
    this.children.splice(t, e - t, ...i);
    for (let n = 0; n < i.length; n++)
      i[n].setParent(this);
  }
  ignoreMutation(t) {
    return !1;
  }
  ignoreEvent(t) {
    return !1;
  }
  childCursor(t = this.length) {
    return new dl(this.children, t, this.children.length);
  }
  childPos(t, e = 1) {
    return this.childCursor().findPos(t, e);
  }
  toString() {
    let t = this.constructor.name.replace("View", "");
    return t + (this.children.length ? "(" + this.children.join() + ")" : this.length ? "[" + (t == "Text" ? this.text : this.length) + "]" : "") + (this.breakAfter ? "#" : "");
  }
  static get(t) {
    return t.cmView;
  }
  get isEditable() {
    return !0;
  }
  merge(t, e, i, n, r, o) {
    return !1;
  }
  become(t) {
    return !1;
  }
  canReuseDOM(t) {
    return t.constructor == this.constructor;
  }
  getSide() {
    return 0;
  }
  destroy() {
    this.parent = null;
  }
}
W.prototype.breakAfter = 0;
function vr(s) {
  let t = s.nextSibling;
  return s.parentNode.removeChild(s), t;
}
class dl {
  constructor(t, e, i) {
    this.children = t, this.pos = e, this.i = i, this.off = 0;
  }
  findPos(t, e = 1) {
    for (; ; ) {
      if (t > this.pos || t == this.pos && (e > 0 || this.i == 0 || this.children[this.i - 1].breakAfter))
        return this.off = t - this.pos, this;
      let i = this.children[--this.i];
      this.pos -= i.length + i.breakAfter;
    }
  }
}
function pl(s, t, e, i, n, r, o, l, h) {
  let { children: a } = s, c = a.length ? a[t] : null, f = r.length ? r[r.length - 1] : null, u = f ? f.breakAfter : o;
  if (!(t == i && c && !o && !u && r.length < 2 && c.merge(e, n, r.length ? f : null, e == 0, l, h))) {
    if (i < a.length) {
      let d = a[i];
      d && n < d.length ? (t == i && (d = d.split(n), n = 0), !u && f && d.merge(0, n, f, !0, 0, h) ? r[r.length - 1] = d : (n && d.merge(0, n, null, !1, 0, h), r.push(d))) : d != null && d.breakAfter && (f ? f.breakAfter = 1 : o = 1), i++;
    }
    for (c && (c.breakAfter = o, e > 0 && (!o && r.length && c.merge(e, c.length, r[0], !1, l, 0) ? c.breakAfter = r.shift().breakAfter : (e < c.length || c.children.length && c.children[c.children.length - 1].length == 0) && c.merge(e, c.length, null, !1, l, 0), t++)); t < i && r.length; )
      if (a[i - 1].become(r[r.length - 1]))
        i--, r.pop(), h = r.length ? 0 : l;
      else if (a[t].become(r[0]))
        t++, r.shift(), l = r.length ? 0 : h;
      else
        break;
    !r.length && t && i < a.length && !a[t - 1].breakAfter && a[i].merge(0, 0, a[t - 1], !1, l, h) && t--, (t < i || r.length) && s.replaceChildren(t, i, r);
  }
}
function gl(s, t, e, i, n, r) {
  let o = s.childCursor(), { i: l, off: h } = o.findPos(e, 1), { i: a, off: c } = o.findPos(t, -1), f = t - e;
  for (let u of i)
    f += u.length;
  s.length += f, pl(s, a, c, l, h, i, 0, n, r);
}
let kt = typeof navigator < "u" ? navigator : { userAgent: "", vendor: "", platform: "" }, ds = typeof document < "u" ? document : { documentElement: { style: {} } };
const ps = /* @__PURE__ */ /Edge\/(\d+)/.exec(kt.userAgent), ml = /* @__PURE__ */ /MSIE \d/.test(kt.userAgent), gs = /* @__PURE__ */ /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(kt.userAgent), Cn = !!(ml || gs || ps), Sr = !Cn && /* @__PURE__ */ /gecko\/(\d+)/i.test(kt.userAgent), Vn = !Cn && /* @__PURE__ */ /Chrome\/(\d+)/.exec(kt.userAgent), Cr = "webkitFontSmoothing" in ds.documentElement.style, wl = !Cn && /* @__PURE__ */ /Apple Computer/.test(kt.vendor), Ar = wl && (/* @__PURE__ */ /Mobile\/\w+/.test(kt.userAgent) || kt.maxTouchPoints > 2);
var x = {
  mac: Ar || /* @__PURE__ */ /Mac/.test(kt.platform),
  windows: /* @__PURE__ */ /Win/.test(kt.platform),
  linux: /* @__PURE__ */ /Linux|X11/.test(kt.platform),
  ie: Cn,
  ie_version: ml ? ds.documentMode || 6 : gs ? +gs[1] : ps ? +ps[1] : 0,
  gecko: Sr,
  gecko_version: Sr ? +(/* @__PURE__ */ /Firefox\/(\d+)/.exec(kt.userAgent) || [0, 0])[1] : 0,
  chrome: !!Vn,
  chrome_version: Vn ? +Vn[1] : 0,
  ios: Ar,
  android: /* @__PURE__ */ /Android\b/.test(kt.userAgent),
  webkit: Cr,
  safari: wl,
  webkit_version: Cr ? +(/* @__PURE__ */ /\bAppleWebKit\/(\d+)/.exec(navigator.userAgent) || [0, 0])[1] : 0,
  tabSize: ds.documentElement.style.tabSize != null ? "tab-size" : "-moz-tab-size"
};
const Jc = 256;
class ge extends W {
  constructor(t) {
    super(), this.text = t;
  }
  get length() {
    return this.text.length;
  }
  createDOM(t) {
    this.setDOM(t || document.createTextNode(this.text));
  }
  sync(t) {
    this.dom || this.createDOM(), this.dom.nodeValue != this.text && (t && t.node == this.dom && (t.written = !0), this.dom.nodeValue = this.text);
  }
  reuseDOM(t) {
    t.nodeType == 3 && this.createDOM(t);
  }
  merge(t, e, i) {
    return i && (!(i instanceof ge) || this.length - (e - t) + i.length > Jc) ? !1 : (this.text = this.text.slice(0, t) + (i ? i.text : "") + this.text.slice(e), this.markDirty(), !0);
  }
  split(t) {
    let e = new ge(this.text.slice(t));
    return this.text = this.text.slice(0, t), this.markDirty(), e;
  }
  localPosFromDOM(t, e) {
    return t == this.dom ? e : e ? this.text.length : 0;
  }
  domAtPos(t) {
    return new ht(this.dom, t);
  }
  domBoundsAround(t, e, i) {
    return { from: i, to: i + this.length, startDOM: this.dom, endDOM: this.dom.nextSibling };
  }
  coordsAt(t, e) {
    return ms(this.dom, t, e);
  }
}
class Wt extends W {
  constructor(t, e = [], i = 0) {
    super(), this.mark = t, this.children = e, this.length = i;
    for (let n of e)
      n.setParent(this);
  }
  setAttrs(t) {
    if (ul(t), this.mark.class && (t.className = this.mark.class), this.mark.attrs)
      for (let e in this.mark.attrs)
        t.setAttribute(e, this.mark.attrs[e]);
    return t;
  }
  reuseDOM(t) {
    t.nodeName == this.mark.tagName.toUpperCase() && (this.setDOM(t), this.dirty |= 6);
  }
  sync(t) {
    this.dom ? this.dirty & 4 && this.setAttrs(this.dom) : this.setDOM(this.setAttrs(document.createElement(this.mark.tagName))), super.sync(t);
  }
  merge(t, e, i, n, r, o) {
    return i && (!(i instanceof Wt && i.mark.eq(this.mark)) || t && r <= 0 || e < this.length && o <= 0) ? !1 : (gl(this, t, e, i ? i.children : [], r - 1, o - 1), this.markDirty(), !0);
  }
  split(t) {
    let e = [], i = 0, n = -1, r = 0;
    for (let l of this.children) {
      let h = i + l.length;
      h > t && e.push(i < t ? l.split(t - i) : l), n < 0 && i >= t && (n = r), i = h, r++;
    }
    let o = this.length - t;
    return this.length = t, n > -1 && (this.children.length = n, this.markDirty()), new Wt(this.mark, e, o);
  }
  domAtPos(t) {
    return kl(this, t);
  }
  coordsAt(t, e) {
    return vl(this, t, e);
  }
}
function ms(s, t, e) {
  let i = s.nodeValue.length;
  t > i && (t = i);
  let n = t, r = t, o = 0;
  t == 0 && e < 0 || t == i && e >= 0 ? x.chrome || x.gecko || (t ? (n--, o = 1) : r < i && (r++, o = -1)) : e < 0 ? n-- : r < i && r++;
  let l = je(s, n, r).getClientRects();
  if (!l.length)
    return cl;
  let h = l[(o ? o < 0 : e >= 0) ? 0 : l.length - 1];
  return x.safari && !o && h.width == 0 && (h = Array.prototype.find.call(l, (a) => a.width) || h), o ? Sn(h, o < 0) : h || null;
}
class le extends W {
  constructor(t, e, i) {
    super(), this.widget = t, this.length = e, this.side = i, this.prevWidget = null;
  }
  static create(t, e, i) {
    return new (t.customView || le)(t, e, i);
  }
  split(t) {
    let e = le.create(this.widget, this.length - t, this.side);
    return this.length -= t, e;
  }
  sync() {
    (!this.dom || !this.widget.updateDOM(this.dom)) && (this.dom && this.prevWidget && this.prevWidget.destroy(this.dom), this.prevWidget = null, this.setDOM(this.widget.toDOM(this.editorView)), this.dom.contentEditable = "false");
  }
  getSide() {
    return this.side;
  }
  merge(t, e, i, n, r, o) {
    return i && (!(i instanceof le) || !this.widget.compare(i.widget) || t > 0 && r <= 0 || e < this.length && o <= 0) ? !1 : (this.length = t + (i ? i.length : 0) + (this.length - e), !0);
  }
  become(t) {
    return t.length == this.length && t instanceof le && t.side == this.side && this.widget.constructor == t.widget.constructor ? (this.widget.eq(t.widget) || this.markDirty(!0), this.dom && !this.prevWidget && (this.prevWidget = this.widget), this.widget = t.widget, !0) : !1;
  }
  ignoreMutation() {
    return !0;
  }
  ignoreEvent(t) {
    return this.widget.ignoreEvent(t);
  }
  get overrideDOMText() {
    if (this.length == 0)
      return I.empty;
    let t = this;
    for (; t.parent; )
      t = t.parent;
    let e = t.editorView, i = e && e.state.doc, n = this.posAtStart;
    return i ? i.slice(n, n + this.length) : I.empty;
  }
  domAtPos(t) {
    return t == 0 ? ht.before(this.dom) : ht.after(this.dom, t == this.length);
  }
  domBoundsAround() {
    return null;
  }
  coordsAt(t, e) {
    let i = this.dom.getClientRects(), n = null;
    if (!i.length)
      return cl;
    for (let r = t > 0 ? i.length - 1 : 0; n = i[r], !(t > 0 ? r == 0 : r == i.length - 1 || n.top < n.bottom); r += t > 0 ? -1 : 1)
      ;
    return t == 0 && e > 0 || t == this.length && e <= 0 ? n : Sn(n, t == 0);
  }
  get isEditable() {
    return !1;
  }
  destroy() {
    super.destroy(), this.dom && this.widget.destroy(this.dom);
  }
}
class yl extends le {
  domAtPos(t) {
    let { topView: e, text: i } = this.widget;
    return e ? ws(t, 0, e, i, (n, r) => n.domAtPos(r), (n) => new ht(i, Math.min(n, i.nodeValue.length))) : new ht(i, Math.min(t, i.nodeValue.length));
  }
  sync() {
    this.setDOM(this.widget.toDOM());
  }
  localPosFromDOM(t, e) {
    let { topView: i, text: n } = this.widget;
    return i ? bl(t, e, i, n) : Math.min(e, this.length);
  }
  ignoreMutation() {
    return !1;
  }
  get overrideDOMText() {
    return null;
  }
  coordsAt(t, e) {
    let { topView: i, text: n } = this.widget;
    return i ? ws(t, e, i, n, (r, o, l) => r.coordsAt(o, l), (r, o) => ms(n, r, o)) : ms(n, t, e);
  }
  destroy() {
    var t;
    super.destroy(), (t = this.widget.topView) === null || t === void 0 || t.destroy();
  }
  get isEditable() {
    return !0;
  }
  canReuseDOM() {
    return !0;
  }
}
function ws(s, t, e, i, n, r) {
  if (e instanceof Wt) {
    for (let o = e.dom.firstChild; o; o = o.nextSibling) {
      let l = W.get(o);
      if (!l)
        return r(s, t);
      let h = We(o, i), a = l.length + (h ? i.nodeValue.length : 0);
      if (s < a || s == a && l.getSide() <= 0)
        return h ? ws(s, t, l, i, n, r) : n(l, s, t);
      s -= a;
    }
    return n(e, e.length, -1);
  } else
    return e.dom == i ? r(s, t) : n(e, s, t);
}
function bl(s, t, e, i) {
  if (e instanceof Wt)
    for (let n of e.children) {
      let r = 0, o = We(n.dom, i);
      if (We(n.dom, s))
        return r + (o ? bl(s, t, n, i) : n.localPosFromDOM(s, t));
      r += o ? i.nodeValue.length : n.length;
    }
  else if (e.dom == i)
    return Math.min(t, i.nodeValue.length);
  return e.localPosFromDOM(s, t);
}
class qe extends W {
  constructor(t) {
    super(), this.side = t;
  }
  get length() {
    return 0;
  }
  merge() {
    return !1;
  }
  become(t) {
    return t instanceof qe && t.side == this.side;
  }
  split() {
    return new qe(this.side);
  }
  sync() {
    if (!this.dom) {
      let t = document.createElement("img");
      t.className = "cm-widgetBuffer", t.setAttribute("aria-hidden", "true"), this.setDOM(t);
    }
  }
  getSide() {
    return this.side;
  }
  domAtPos(t) {
    return ht.before(this.dom);
  }
  localPosFromDOM() {
    return 0;
  }
  domBoundsAround() {
    return null;
  }
  coordsAt(t) {
    let e = this.dom.getBoundingClientRect(), i = Xc(this, this.side > 0 ? -1 : 1);
    return i && i.top < e.bottom && i.bottom > e.top ? { left: e.left, right: e.right, top: i.top, bottom: i.bottom } : e;
  }
  get overrideDOMText() {
    return I.empty;
  }
}
ge.prototype.children = le.prototype.children = qe.prototype.children = js;
function Xc(s, t) {
  let e = s.parent, i = e ? e.children.indexOf(s) : -1;
  for (; e && i >= 0; )
    if (t < 0 ? i > 0 : i < e.children.length) {
      let n = e.children[i + t];
      if (n instanceof ge) {
        let r = n.coordsAt(t < 0 ? n.length : 0, t);
        if (r)
          return r;
      }
      i += t;
    } else if (e instanceof Wt && e.parent)
      i = e.parent.children.indexOf(e) + (t < 0 ? 0 : 1), e = e.parent;
    else {
      let n = e.dom.lastChild;
      if (n && n.nodeName == "BR")
        return n.getClientRects()[0];
      break;
    }
}
function kl(s, t) {
  let e = s.dom, { children: i } = s, n = 0;
  for (let r = 0; n < i.length; n++) {
    let o = i[n], l = r + o.length;
    if (!(l == r && o.getSide() <= 0)) {
      if (t > r && t < l && o.dom.parentNode == e)
        return o.domAtPos(t - r);
      if (t <= r)
        break;
      r = l;
    }
  }
  for (let r = n; r > 0; r--) {
    let o = i[r - 1];
    if (o.dom.parentNode == e)
      return o.domAtPos(o.length);
  }
  for (let r = n; r < i.length; r++) {
    let o = i[r];
    if (o.dom.parentNode == e)
      return o.domAtPos(0);
  }
  return new ht(e, 0);
}
function xl(s, t, e) {
  let i, { children: n } = s;
  e > 0 && t instanceof Wt && n.length && (i = n[n.length - 1]) instanceof Wt && i.mark.eq(t.mark) ? xl(i, t.children[0], e - 1) : (n.push(t), t.setParent(s)), s.length += t.length;
}
function vl(s, t, e) {
  for (let r = 0, o = 0; o < s.children.length; o++) {
    let l = s.children[o], h = r + l.length, a;
    if ((e <= 0 || h == s.length || l.getSide() > 0 ? h >= t : h > t) && (t < h || o + 1 == s.children.length || (a = s.children[o + 1]).length || a.getSide() > 0)) {
      let c = 0;
      if (h == r) {
        if (l.getSide() <= 0)
          continue;
        c = e = -l.getSide();
      }
      let f = l.coordsAt(Math.max(0, t - r), e);
      return c && f ? Sn(f, e < 0) : f;
    }
    r = h;
  }
  let i = s.dom.lastChild;
  if (!i)
    return s.dom.getBoundingClientRect();
  let n = di(i);
  return n[n.length - 1] || null;
}
function ys(s, t) {
  for (let e in s)
    e == "class" && t.class ? t.class += " " + s.class : e == "style" && t.style ? t.style += ";" + s.style : t[e] = s[e];
  return t;
}
function qs(s, t) {
  if (s == t)
    return !0;
  if (!s || !t)
    return !1;
  let e = Object.keys(s), i = Object.keys(t);
  if (e.length != i.length)
    return !1;
  for (let n of e)
    if (i.indexOf(n) == -1 || s[n] !== t[n])
      return !1;
  return !0;
}
function bs(s, t, e) {
  let i = null;
  if (t)
    for (let n in t)
      e && n in e || s.removeAttribute(i = n);
  if (e)
    for (let n in e)
      t && t[n] == e[n] || s.setAttribute(i = n, e[n]);
  return !!i;
}
class ye {
  eq(t) {
    return !1;
  }
  updateDOM(t) {
    return !1;
  }
  compare(t) {
    return this == t || this.constructor == t.constructor && this.eq(t);
  }
  get estimatedHeight() {
    return -1;
  }
  ignoreEvent(t) {
    return !0;
  }
  get customView() {
    return null;
  }
  destroy(t) {
  }
}
var U = /* @__PURE__ */ function(s) {
  return s[s.Text = 0] = "Text", s[s.WidgetBefore = 1] = "WidgetBefore", s[s.WidgetAfter = 2] = "WidgetAfter", s[s.WidgetRange = 3] = "WidgetRange", s;
}(U || (U = {}));
class D extends _e {
  constructor(t, e, i, n) {
    super(), this.startSide = t, this.endSide = e, this.widget = i, this.spec = n;
  }
  get heightRelevant() {
    return !1;
  }
  static mark(t) {
    return new An(t);
  }
  static widget(t) {
    let e = t.side || 0, i = !!t.block;
    return e += i ? e > 0 ? 3e8 : -4e8 : e > 0 ? 1e8 : -1e8, new Te(t, e, e, i, t.widget || null, !1);
  }
  static replace(t) {
    let e = !!t.block, i, n;
    if (t.isBlockGap)
      i = -5e8, n = 4e8;
    else {
      let { start: r, end: o } = Sl(t, e);
      i = (r ? e ? -3e8 : -1 : 5e8) - 1, n = (o ? e ? 2e8 : 1 : -6e8) + 1;
    }
    return new Te(t, i, n, e, t.widget || null, !0);
  }
  static line(t) {
    return new ki(t);
  }
  static set(t, e = !1) {
    return $.of(t, e);
  }
  hasHeight() {
    return this.widget ? this.widget.estimatedHeight > -1 : !1;
  }
}
D.none = $.empty;
class An extends D {
  constructor(t) {
    let { start: e, end: i } = Sl(t);
    super(e ? -1 : 5e8, i ? 1 : -6e8, null, t), this.tagName = t.tagName || "span", this.class = t.class || "", this.attrs = t.attributes || null;
  }
  eq(t) {
    return this == t || t instanceof An && this.tagName == t.tagName && this.class == t.class && qs(this.attrs, t.attrs);
  }
  range(t, e = t) {
    if (t >= e)
      throw new RangeError("Mark decorations may not be empty");
    return super.range(t, e);
  }
}
An.prototype.point = !1;
class ki extends D {
  constructor(t) {
    super(-2e8, -2e8, null, t);
  }
  eq(t) {
    return t instanceof ki && qs(this.spec.attributes, t.spec.attributes);
  }
  range(t, e = t) {
    if (e != t)
      throw new RangeError("Line decoration ranges must be zero-length");
    return super.range(t, e);
  }
}
ki.prototype.mapMode = pt.TrackBefore;
ki.prototype.point = !0;
class Te extends D {
  constructor(t, e, i, n, r, o) {
    super(e, i, r, t), this.block = n, this.isReplace = o, this.mapMode = n ? e <= 0 ? pt.TrackBefore : pt.TrackAfter : pt.TrackDel;
  }
  get type() {
    return this.startSide < this.endSide ? U.WidgetRange : this.startSide <= 0 ? U.WidgetBefore : U.WidgetAfter;
  }
  get heightRelevant() {
    return this.block || !!this.widget && this.widget.estimatedHeight >= 5;
  }
  eq(t) {
    return t instanceof Te && Yc(this.widget, t.widget) && this.block == t.block && this.startSide == t.startSide && this.endSide == t.endSide;
  }
  range(t, e = t) {
    if (this.isReplace && (t > e || t == e && this.startSide > 0 && this.endSide <= 0))
      throw new RangeError("Invalid range for replacement decoration");
    if (!this.isReplace && e != t)
      throw new RangeError("Widget decorations can only have zero-length ranges");
    return super.range(t, e);
  }
}
Te.prototype.point = !0;
function Sl(s, t = !1) {
  let { inclusiveStart: e, inclusiveEnd: i } = s;
  return e == null && (e = s.inclusive), i == null && (i = s.inclusive), { start: e != null ? e : t, end: i != null ? i : t };
}
function Yc(s, t) {
  return s == t || !!(s && t && s.compare(t));
}
function ks(s, t, e, i = 0) {
  let n = e.length - 1;
  n >= 0 && e[n] + i >= s ? e[n] = Math.max(e[n], t) : e.push(s, t);
}
class ut extends W {
  constructor() {
    super(...arguments), this.children = [], this.length = 0, this.prevAttrs = void 0, this.attrs = null, this.breakAfter = 0;
  }
  merge(t, e, i, n, r, o) {
    if (i) {
      if (!(i instanceof ut))
        return !1;
      this.dom || i.transferDOM(this);
    }
    return n && this.setDeco(i ? i.attrs : null), gl(this, t, e, i ? i.children : [], r, o), !0;
  }
  split(t) {
    let e = new ut();
    if (e.breakAfter = this.breakAfter, this.length == 0)
      return e;
    let { i, off: n } = this.childPos(t);
    n && (e.append(this.children[i].split(n), 0), this.children[i].merge(n, this.children[i].length, null, !1, 0, 0), i++);
    for (let r = i; r < this.children.length; r++)
      e.append(this.children[r], 0);
    for (; i > 0 && this.children[i - 1].length == 0; )
      this.children[--i].destroy();
    return this.children.length = i, this.markDirty(), this.length = t, e;
  }
  transferDOM(t) {
    !this.dom || (this.markDirty(), t.setDOM(this.dom), t.prevAttrs = this.prevAttrs === void 0 ? this.attrs : this.prevAttrs, this.prevAttrs = void 0, this.dom = null);
  }
  setDeco(t) {
    qs(this.attrs, t) || (this.dom && (this.prevAttrs = this.attrs, this.markDirty()), this.attrs = t);
  }
  append(t, e) {
    xl(this, t, e);
  }
  addLineDeco(t) {
    let e = t.spec.attributes, i = t.spec.class;
    e && (this.attrs = ys(e, this.attrs || {})), i && (this.attrs = ys({ class: i }, this.attrs || {}));
  }
  domAtPos(t) {
    return kl(this, t);
  }
  reuseDOM(t) {
    t.nodeName == "DIV" && (this.setDOM(t), this.dirty |= 6);
  }
  sync(t) {
    var e;
    this.dom ? this.dirty & 4 && (ul(this.dom), this.dom.className = "cm-line", this.prevAttrs = this.attrs ? null : void 0) : (this.setDOM(document.createElement("div")), this.dom.className = "cm-line", this.prevAttrs = this.attrs ? null : void 0), this.prevAttrs !== void 0 && (bs(this.dom, this.prevAttrs, this.attrs), this.dom.classList.add("cm-line"), this.prevAttrs = void 0), super.sync(t);
    let i = this.dom.lastChild;
    for (; i && W.get(i) instanceof Wt; )
      i = i.lastChild;
    if (!i || !this.length || i.nodeName != "BR" && ((e = W.get(i)) === null || e === void 0 ? void 0 : e.isEditable) == !1 && (!x.ios || !this.children.some((n) => n instanceof ge))) {
      let n = document.createElement("BR");
      n.cmIgnore = !0, this.dom.appendChild(n);
    }
  }
  measureTextSize() {
    if (this.children.length == 0 || this.length > 20)
      return null;
    let t = 0;
    for (let e of this.children) {
      if (!(e instanceof ge) || /[^ -~]/.test(e.text))
        return null;
      let i = di(e.dom);
      if (i.length != 1)
        return null;
      t += i[0].width;
    }
    return t ? {
      lineHeight: this.dom.getBoundingClientRect().height,
      charWidth: t / this.length
    } : null;
  }
  coordsAt(t, e) {
    return vl(this, t, e);
  }
  become(t) {
    return !1;
  }
  get type() {
    return U.Text;
  }
  static find(t, e) {
    for (let i = 0, n = 0; i < t.children.length; i++) {
      let r = t.children[i], o = n + r.length;
      if (o >= e) {
        if (r instanceof ut)
          return r;
        if (o > e)
          break;
      }
      n = o + r.breakAfter;
    }
    return null;
  }
}
class Ae extends W {
  constructor(t, e, i) {
    super(), this.widget = t, this.length = e, this.type = i, this.breakAfter = 0, this.prevWidget = null;
  }
  merge(t, e, i, n, r, o) {
    return i && (!(i instanceof Ae) || !this.widget.compare(i.widget) || t > 0 && r <= 0 || e < this.length && o <= 0) ? !1 : (this.length = t + (i ? i.length : 0) + (this.length - e), !0);
  }
  domAtPos(t) {
    return t == 0 ? ht.before(this.dom) : ht.after(this.dom, t == this.length);
  }
  split(t) {
    let e = this.length - t;
    this.length = t;
    let i = new Ae(this.widget, e, this.type);
    return i.breakAfter = this.breakAfter, i;
  }
  get children() {
    return js;
  }
  sync() {
    (!this.dom || !this.widget.updateDOM(this.dom)) && (this.dom && this.prevWidget && this.prevWidget.destroy(this.dom), this.prevWidget = null, this.setDOM(this.widget.toDOM(this.editorView)), this.dom.contentEditable = "false");
  }
  get overrideDOMText() {
    return this.parent ? this.parent.view.state.doc.slice(this.posAtStart, this.posAtEnd) : I.empty;
  }
  domBoundsAround() {
    return null;
  }
  become(t) {
    return t instanceof Ae && t.type == this.type && t.widget.constructor == this.widget.constructor ? (t.widget.eq(this.widget) || this.markDirty(!0), this.dom && !this.prevWidget && (this.prevWidget = this.widget), this.widget = t.widget, this.length = t.length, this.breakAfter = t.breakAfter, !0) : !1;
  }
  ignoreMutation() {
    return !0;
  }
  ignoreEvent(t) {
    return this.widget.ignoreEvent(t);
  }
  destroy() {
    super.destroy(), this.dom && this.widget.destroy(this.dom);
  }
}
class Gs {
  constructor(t, e, i, n) {
    this.doc = t, this.pos = e, this.end = i, this.disallowBlockEffectsFor = n, this.content = [], this.curLine = null, this.breakAtStart = 0, this.pendingBuffer = 0, this.atCursorPos = !0, this.openStart = -1, this.openEnd = -1, this.text = "", this.textOff = 0, this.cursor = t.iter(), this.skip = e;
  }
  posCovered() {
    if (this.content.length == 0)
      return !this.breakAtStart && this.doc.lineAt(this.pos).from != this.pos;
    let t = this.content[this.content.length - 1];
    return !t.breakAfter && !(t instanceof Ae && t.type == U.WidgetBefore);
  }
  getLine() {
    return this.curLine || (this.content.push(this.curLine = new ut()), this.atCursorPos = !0), this.curLine;
  }
  flushBuffer(t) {
    this.pendingBuffer && (this.curLine.append(Mi(new qe(-1), t), t.length), this.pendingBuffer = 0);
  }
  addBlockWidget(t) {
    this.flushBuffer([]), this.curLine = null, this.content.push(t);
  }
  finish(t) {
    t ? this.pendingBuffer = 0 : this.flushBuffer([]), this.posCovered() || this.getLine();
  }
  buildText(t, e, i) {
    for (; t > 0; ) {
      if (this.textOff == this.text.length) {
        let { value: r, lineBreak: o, done: l } = this.cursor.next(this.skip);
        if (this.skip = 0, l)
          throw new Error("Ran out of text content when drawing inline views");
        if (o) {
          this.posCovered() || this.getLine(), this.content.length ? this.content[this.content.length - 1].breakAfter = 1 : this.breakAtStart = 1, this.flushBuffer([]), this.curLine = null, t--;
          continue;
        } else
          this.text = r, this.textOff = 0;
      }
      let n = Math.min(this.text.length - this.textOff, t, 512);
      this.flushBuffer(e.slice(0, i)), this.getLine().append(Mi(new ge(this.text.slice(this.textOff, this.textOff + n)), e), i), this.atCursorPos = !0, this.textOff += n, t -= n, i = 0;
    }
  }
  span(t, e, i, n) {
    this.buildText(e - t, i, n), this.pos = e, this.openStart < 0 && (this.openStart = n);
  }
  point(t, e, i, n, r, o) {
    if (this.disallowBlockEffectsFor[o] && i instanceof Te) {
      if (i.block)
        throw new RangeError("Block decorations may not be specified via plugins");
      if (e > this.doc.lineAt(this.pos).to)
        throw new RangeError("Decorations that replace line breaks may not be specified via plugins");
    }
    let l = e - t;
    if (i instanceof Te)
      if (i.block) {
        let { type: h } = i;
        h == U.WidgetAfter && !this.posCovered() && this.getLine(), this.addBlockWidget(new Ae(i.widget || new Or("div"), l, h));
      } else {
        let h = le.create(i.widget || new Or("span"), l, i.startSide), a = this.atCursorPos && !h.isEditable && r <= n.length && (t < e || i.startSide > 0), c = !h.isEditable && (t < e || i.startSide <= 0), f = this.getLine();
        this.pendingBuffer == 2 && !a && (this.pendingBuffer = 0), this.flushBuffer(n), a && (f.append(Mi(new qe(1), n), r), r = n.length + Math.max(0, r - n.length)), f.append(Mi(h, n), r), this.atCursorPos = c, this.pendingBuffer = c ? t < e ? 1 : 2 : 0;
      }
    else
      this.doc.lineAt(this.pos).from == this.pos && this.getLine().addLineDeco(i);
    l && (this.textOff + l <= this.text.length ? this.textOff += l : (this.skip += l - (this.text.length - this.textOff), this.text = "", this.textOff = 0), this.pos = e), this.openStart < 0 && (this.openStart = r);
  }
  static build(t, e, i, n, r) {
    let o = new Gs(t, e, i, r);
    return o.openEnd = $.spans(n, e, i, o), o.openStart < 0 && (o.openStart = o.openEnd), o.finish(o.openEnd), o;
  }
}
function Mi(s, t) {
  for (let e of t)
    s = new Wt(e, [s], s.length);
  return s;
}
class Or extends ye {
  constructor(t) {
    super(), this.tag = t;
  }
  eq(t) {
    return t.tag == this.tag;
  }
  toDOM() {
    return document.createElement(this.tag);
  }
  updateDOM(t) {
    return t.nodeName.toLowerCase() == this.tag;
  }
}
const Cl = /* @__PURE__ */ v.define(), Al = /* @__PURE__ */ v.define(), Ol = /* @__PURE__ */ v.define(), Ml = /* @__PURE__ */ v.define(), xs = /* @__PURE__ */ v.define(), Dl = /* @__PURE__ */ v.define(), Tl = /* @__PURE__ */ v.define({
  combine: (s) => s.some((t) => t)
});
class nn {
  constructor(t, e = "nearest", i = "nearest", n = 5, r = 5) {
    this.range = t, this.y = e, this.x = i, this.yMargin = n, this.xMargin = r;
  }
  map(t) {
    return t.empty ? this : new nn(this.range.map(t), this.y, this.x, this.yMargin, this.xMargin);
  }
}
const Mr = /* @__PURE__ */ F.define({ map: (s, t) => s.map(t) });
function zt(s, t, e) {
  let i = s.facet(Ml);
  i.length ? i[0](t) : window.onerror ? window.onerror(String(t), e, void 0, void 0, t) : e ? console.error(e + ":", t) : console.error(t);
}
const On = /* @__PURE__ */ v.define({ combine: (s) => s.length ? s[0] : !0 });
let Zc = 0;
const ii = /* @__PURE__ */ v.define();
class wt {
  constructor(t, e, i, n) {
    this.id = t, this.create = e, this.domEventHandlers = i, this.extension = n(this);
  }
  static define(t, e) {
    const { eventHandlers: i, provide: n, decorations: r } = e || {};
    return new wt(Zc++, t, i, (o) => {
      let l = [ii.of(o)];
      return r && l.push(gi.of((h) => {
        let a = h.plugin(o);
        return a ? r(a) : D.none;
      })), n && l.push(n(o)), l;
    });
  }
  static fromClass(t, e) {
    return wt.define((i) => new t(i), e);
  }
}
class In {
  constructor(t) {
    this.spec = t, this.mustUpdate = null, this.value = null;
  }
  update(t) {
    if (this.value) {
      if (this.mustUpdate) {
        let e = this.mustUpdate;
        if (this.mustUpdate = null, this.value.update)
          try {
            this.value.update(e);
          } catch (i) {
            if (zt(e.state, i, "CodeMirror plugin crashed"), this.value.destroy)
              try {
                this.value.destroy();
              } catch {
              }
            this.deactivate();
          }
      }
    } else if (this.spec)
      try {
        this.value = this.spec.create(t);
      } catch (e) {
        zt(t.state, e, "CodeMirror plugin crashed"), this.deactivate();
      }
    return this;
  }
  destroy(t) {
    var e;
    if (!((e = this.value) === null || e === void 0) && e.destroy)
      try {
        this.value.destroy();
      } catch (i) {
        zt(t.state, i, "CodeMirror plugin crashed");
      }
  }
  deactivate() {
    this.spec = this.value = null;
  }
}
const Pl = /* @__PURE__ */ v.define(), Bl = /* @__PURE__ */ v.define(), gi = /* @__PURE__ */ v.define(), Rl = /* @__PURE__ */ v.define(), Ll = /* @__PURE__ */ v.define(), ni = /* @__PURE__ */ v.define();
class Yt {
  constructor(t, e, i, n) {
    this.fromA = t, this.toA = e, this.fromB = i, this.toB = n;
  }
  join(t) {
    return new Yt(Math.min(this.fromA, t.fromA), Math.max(this.toA, t.toA), Math.min(this.fromB, t.fromB), Math.max(this.toB, t.toB));
  }
  addToSet(t) {
    let e = t.length, i = this;
    for (; e > 0; e--) {
      let n = t[e - 1];
      if (!(n.fromA > i.toA)) {
        if (n.toA < i.fromA)
          break;
        i = i.join(n), t.splice(e - 1, 1);
      }
    }
    return t.splice(e, 0, i), t;
  }
  static extendWithRanges(t, e) {
    if (e.length == 0)
      return t;
    let i = [];
    for (let n = 0, r = 0, o = 0, l = 0; ; n++) {
      let h = n == t.length ? null : t[n], a = o - l, c = h ? h.fromB : 1e9;
      for (; r < e.length && e[r] < c; ) {
        let f = e[r], u = e[r + 1], d = Math.max(l, f), p = Math.min(c, u);
        if (d <= p && new Yt(d + a, p + a, d, p).addToSet(i), u > c)
          break;
        r += 2;
      }
      if (!h)
        return i;
      new Yt(h.fromA, h.toA, h.fromB, h.toB).addToSet(i), o = h.toA, l = h.toB;
    }
  }
}
class sn {
  constructor(t, e, i) {
    this.view = t, this.state = e, this.transactions = i, this.flags = 0, this.startState = t.state, this.changes = Y.empty(this.startState.doc.length);
    for (let o of i)
      this.changes = this.changes.compose(o.changes);
    let n = [];
    this.changes.iterChangedRanges((o, l, h, a) => n.push(new Yt(o, l, h, a))), this.changedRanges = n;
    let r = t.hasFocus;
    r != t.inputState.notifiedFocused && (t.inputState.notifiedFocused = r, this.flags |= 1);
  }
  static create(t, e, i) {
    return new sn(t, e, i);
  }
  get viewportChanged() {
    return (this.flags & 4) > 0;
  }
  get heightChanged() {
    return (this.flags & 2) > 0;
  }
  get geometryChanged() {
    return this.docChanged || (this.flags & 10) > 0;
  }
  get focusChanged() {
    return (this.flags & 1) > 0;
  }
  get docChanged() {
    return !this.changes.empty;
  }
  get selectionSet() {
    return this.transactions.some((t) => t.selection);
  }
  get empty() {
    return this.flags == 0 && this.transactions.length == 0;
  }
}
var X = /* @__PURE__ */ function(s) {
  return s[s.LTR = 0] = "LTR", s[s.RTL = 1] = "RTL", s;
}(X || (X = {}));
const vs = X.LTR, tf = X.RTL;
function El(s) {
  let t = [];
  for (let e = 0; e < s.length; e++)
    t.push(1 << +s[e]);
  return t;
}
const ef = /* @__PURE__ */ El("88888888888888888888888888888888888666888888787833333333337888888000000000000000000000000008888880000000000000000000000000088888888888888888888888888888888888887866668888088888663380888308888800000000000000000000000800000000000000000000000000000008"), nf = /* @__PURE__ */ El("4444448826627288999999999992222222222222222222222222222222222222222222222229999999999999999999994444444444644222822222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222999999949999999229989999223333333333"), Ss = /* @__PURE__ */ Object.create(null), Lt = [];
for (let s of ["()", "[]", "{}"]) {
  let t = /* @__PURE__ */ s.charCodeAt(0), e = /* @__PURE__ */ s.charCodeAt(1);
  Ss[t] = e, Ss[e] = -t;
}
function sf(s) {
  return s <= 247 ? ef[s] : 1424 <= s && s <= 1524 ? 2 : 1536 <= s && s <= 1785 ? nf[s - 1536] : 1774 <= s && s <= 2220 ? 4 : 8192 <= s && s <= 8203 ? 256 : 64336 <= s && s <= 65023 ? 4 : s == 8204 ? 256 : 1;
}
const rf = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac\ufb50-\ufdff]/;
class $e {
  constructor(t, e, i) {
    this.from = t, this.to = e, this.level = i;
  }
  get dir() {
    return this.level % 2 ? tf : vs;
  }
  side(t, e) {
    return this.dir == e == t ? this.to : this.from;
  }
  static find(t, e, i, n) {
    let r = -1;
    for (let o = 0; o < t.length; o++) {
      let l = t[o];
      if (l.from <= e && l.to >= e) {
        if (l.level == i)
          return o;
        (r < 0 || (n != 0 ? n < 0 ? l.from < e : l.to > e : t[r].level > l.level)) && (r = o);
      }
    }
    if (r < 0)
      throw new RangeError("Index out of range");
    return r;
  }
}
const j = [];
function of(s, t) {
  let e = s.length, i = t == vs ? 1 : 2, n = t == vs ? 2 : 1;
  if (!s || i == 1 && !rf.test(s))
    return Nl(e);
  for (let o = 0, l = i, h = i; o < e; o++) {
    let a = sf(s.charCodeAt(o));
    a == 512 ? a = l : a == 8 && h == 4 && (a = 16), j[o] = a == 4 ? 2 : a, a & 7 && (h = a), l = a;
  }
  for (let o = 0, l = i, h = i; o < e; o++) {
    let a = j[o];
    if (a == 128)
      o < e - 1 && l == j[o + 1] && l & 24 ? a = j[o] = l : j[o] = 256;
    else if (a == 64) {
      let c = o + 1;
      for (; c < e && j[c] == 64; )
        c++;
      let f = o && l == 8 || c < e && j[c] == 8 ? h == 1 ? 1 : 8 : 256;
      for (let u = o; u < c; u++)
        j[u] = f;
      o = c - 1;
    } else
      a == 8 && h == 1 && (j[o] = 1);
    l = a, a & 7 && (h = a);
  }
  for (let o = 0, l = 0, h = 0, a, c, f; o < e; o++)
    if (c = Ss[a = s.charCodeAt(o)])
      if (c < 0) {
        for (let u = l - 3; u >= 0; u -= 3)
          if (Lt[u + 1] == -c) {
            let d = Lt[u + 2], p = d & 2 ? i : d & 4 ? d & 1 ? n : i : 0;
            p && (j[o] = j[Lt[u]] = p), l = u;
            break;
          }
      } else {
        if (Lt.length == 189)
          break;
        Lt[l++] = o, Lt[l++] = a, Lt[l++] = h;
      }
    else if ((f = j[o]) == 2 || f == 1) {
      let u = f == i;
      h = u ? 0 : 1;
      for (let d = l - 3; d >= 0; d -= 3) {
        let p = Lt[d + 2];
        if (p & 2)
          break;
        if (u)
          Lt[d + 2] |= 2;
        else {
          if (p & 4)
            break;
          Lt[d + 2] |= 4;
        }
      }
    }
  for (let o = 0; o < e; o++)
    if (j[o] == 256) {
      let l = o + 1;
      for (; l < e && j[l] == 256; )
        l++;
      let h = (o ? j[o - 1] : i) == 1, a = (l < e ? j[l] : i) == 1, c = h == a ? h ? 1 : 2 : i;
      for (let f = o; f < l; f++)
        j[f] = c;
      o = l - 1;
    }
  let r = [];
  if (i == 1)
    for (let o = 0; o < e; ) {
      let l = o, h = j[o++] != 1;
      for (; o < e && h == (j[o] != 1); )
        o++;
      if (h)
        for (let a = o; a > l; ) {
          let c = a, f = j[--a] != 2;
          for (; a > l && f == (j[a - 1] != 2); )
            a--;
          r.push(new $e(a, c, f ? 2 : 1));
        }
      else
        r.push(new $e(l, o, 0));
    }
  else
    for (let o = 0; o < e; ) {
      let l = o, h = j[o++] == 2;
      for (; o < e && h == (j[o] == 2); )
        o++;
      r.push(new $e(l, o, h ? 1 : 2));
    }
  return r;
}
function Nl(s) {
  return [new $e(0, s, 0)];
}
let Vl = "";
function lf(s, t, e, i, n) {
  var r;
  let o = i.head - s.from, l = -1;
  if (o == 0) {
    if (!n || !s.length)
      return null;
    t[0].level != e && (o = t[0].side(!1, e), l = 0);
  } else if (o == s.length) {
    if (n)
      return null;
    let u = t[t.length - 1];
    u.level != e && (o = u.side(!0, e), l = t.length - 1);
  }
  l < 0 && (l = $e.find(t, o, (r = i.bidiLevel) !== null && r !== void 0 ? r : -1, i.assoc));
  let h = t[l];
  o == h.side(n, e) && (h = t[l += n ? 1 : -1], o = h.side(!n, e));
  let a = n == (h.dir == e), c = xt(s.text, o, a);
  if (Vl = s.text.slice(Math.min(o, c), Math.max(o, c)), c != h.side(n, e))
    return k.cursor(c + s.from, a ? -1 : 1, h.level);
  let f = l == (n ? t.length - 1 : 0) ? null : t[l + (n ? 1 : -1)];
  return !f && h.level != e ? k.cursor(n ? s.to : s.from, n ? -1 : 1, e) : f && f.level < h.level ? k.cursor(f.side(!n, e) + s.from, n ? 1 : -1, f.level) : k.cursor(c + s.from, n ? -1 : 1, h.level);
}
const he = "\uFFFF";
class Il {
  constructor(t, e) {
    this.points = t, this.text = "", this.lineSeparator = e.facet(E.lineSeparator);
  }
  append(t) {
    this.text += t;
  }
  lineBreak() {
    this.text += he;
  }
  readRange(t, e) {
    if (!t)
      return this;
    let i = t.parentNode;
    for (let n = t; ; ) {
      this.findPointBefore(i, n), this.readNode(n);
      let r = n.nextSibling;
      if (r == e)
        break;
      let o = W.get(n), l = W.get(r);
      (o && l ? o.breakAfter : (o ? o.breakAfter : Dr(n)) || Dr(r) && (n.nodeName != "BR" || n.cmIgnore)) && this.lineBreak(), n = r;
    }
    return this.findPointBefore(i, e), this;
  }
  readTextNode(t) {
    let e = t.nodeValue;
    for (let i of this.points)
      i.node == t && (i.pos = this.text.length + Math.min(i.offset, e.length));
    for (let i = 0, n = this.lineSeparator ? null : /\r\n?|\n/g; ; ) {
      let r = -1, o = 1, l;
      if (this.lineSeparator ? (r = e.indexOf(this.lineSeparator, i), o = this.lineSeparator.length) : (l = n.exec(e)) && (r = l.index, o = l[0].length), this.append(e.slice(i, r < 0 ? e.length : r)), r < 0)
        break;
      if (this.lineBreak(), o > 1)
        for (let h of this.points)
          h.node == t && h.pos > this.text.length && (h.pos -= o - 1);
      i = r + o;
    }
  }
  readNode(t) {
    if (t.cmIgnore)
      return;
    let e = W.get(t), i = e && e.overrideDOMText;
    if (i != null) {
      this.findPointInside(t, i.length);
      for (let n = i.iter(); !n.next().done; )
        n.lineBreak ? this.lineBreak() : this.append(n.value);
    } else
      t.nodeType == 3 ? this.readTextNode(t) : t.nodeName == "BR" ? t.nextSibling && this.lineBreak() : t.nodeType == 1 && this.readRange(t.firstChild, null);
  }
  findPointBefore(t, e) {
    for (let i of this.points)
      i.node == t && t.childNodes[i.offset] == e && (i.pos = this.text.length);
  }
  findPointInside(t, e) {
    for (let i of this.points)
      (t.nodeType == 3 ? i.node == t : t.contains(i.node)) && (i.pos = this.text.length + Math.min(e, i.offset));
  }
}
function Dr(s) {
  return s.nodeType == 1 && /^(DIV|P|LI|UL|OL|BLOCKQUOTE|DD|DT|H\d|SECTION|PRE)$/.test(s.nodeName);
}
class Tr {
  constructor(t, e) {
    this.node = t, this.offset = e, this.pos = -1;
  }
}
class Pr extends W {
  constructor(t) {
    super(), this.view = t, this.compositionDeco = D.none, this.decorations = [], this.dynamicDecorationMap = [], this.minWidth = 0, this.minWidthFrom = 0, this.minWidthTo = 0, this.impreciseAnchor = null, this.impreciseHead = null, this.forceSelection = !1, this.lastUpdate = Date.now(), this.setDOM(t.contentDOM), this.children = [new ut()], this.children[0].setParent(this), this.updateDeco(), this.updateInner([new Yt(0, 0, 0, t.state.doc.length)], 0);
  }
  get editorView() {
    return this.view;
  }
  get length() {
    return this.view.state.doc.length;
  }
  update(t) {
    let e = t.changedRanges;
    this.minWidth > 0 && e.length && (e.every(({ fromA: o, toA: l }) => l < this.minWidthFrom || o > this.minWidthTo) ? (this.minWidthFrom = t.changes.mapPos(this.minWidthFrom, 1), this.minWidthTo = t.changes.mapPos(this.minWidthTo, 1)) : this.minWidth = this.minWidthFrom = this.minWidthTo = 0), this.view.inputState.composing < 0 ? this.compositionDeco = D.none : (t.transactions.length || this.dirty) && (this.compositionDeco = af(this.view, t.changes)), (x.ie || x.chrome) && !this.compositionDeco.size && t && t.state.doc.lines != t.startState.doc.lines && (this.forceSelection = !0);
    let i = this.decorations, n = this.updateDeco(), r = df(i, n, t.changes);
    return e = Yt.extendWithRanges(e, r), this.dirty == 0 && e.length == 0 ? !1 : (this.updateInner(e, t.startState.doc.length), t.transactions.length && (this.lastUpdate = Date.now()), !0);
  }
  updateInner(t, e) {
    this.view.viewState.mustMeasureContent = !0, this.updateChildren(t, e);
    let { observer: i } = this.view;
    i.ignore(() => {
      this.dom.style.height = this.view.viewState.contentHeight + "px", this.dom.style.flexBasis = this.minWidth ? this.minWidth + "px" : "";
      let r = x.chrome || x.ios ? { node: i.selectionRange.focusNode, written: !1 } : void 0;
      this.sync(r), this.dirty = 0, r && (r.written || i.selectionRange.focusNode != r.node) && (this.forceSelection = !0), this.dom.style.height = "";
    });
    let n = [];
    if (this.view.viewport.from || this.view.viewport.to < this.view.state.doc.length)
      for (let r of this.children)
        r instanceof Ae && r.widget instanceof Br && n.push(r.dom);
    i.updateGaps(n);
  }
  updateChildren(t, e) {
    let i = this.childCursor(e);
    for (let n = t.length - 1; ; n--) {
      let r = n >= 0 ? t[n] : null;
      if (!r)
        break;
      let { fromA: o, toA: l, fromB: h, toB: a } = r, { content: c, breakAtStart: f, openStart: u, openEnd: d } = Gs.build(this.view.state.doc, h, a, this.decorations, this.dynamicDecorationMap), { i: p, off: w } = i.findPos(l, 1), { i: g, off: y } = i.findPos(o, -1);
      pl(this, g, y, p, w, c, f, u, d);
    }
  }
  updateSelection(t = !1, e = !1) {
    if ((t || !this.view.observer.selectionRange.focusNode) && this.view.observer.readSelectionRange(), !(e || this.mayControlSelection()))
      return;
    let i = this.forceSelection;
    this.forceSelection = !1;
    let n = this.view.state.selection.main, r = this.domAtPos(n.anchor), o = n.empty ? r : this.domAtPos(n.head);
    if (x.gecko && n.empty && hf(r)) {
      let h = document.createTextNode("");
      this.view.observer.ignore(() => r.node.insertBefore(h, r.node.childNodes[r.offset] || null)), r = o = new ht(h, 0), i = !0;
    }
    let l = this.view.observer.selectionRange;
    (i || !l.focusNode || !tn(r.node, r.offset, l.anchorNode, l.anchorOffset) || !tn(o.node, o.offset, l.focusNode, l.focusOffset)) && (this.view.observer.ignore(() => {
      x.android && x.chrome && this.dom.contains(l.focusNode) && pf(l.focusNode, this.dom) && (this.dom.blur(), this.dom.focus({ preventScroll: !0 }));
      let h = Zi(this.view.root);
      if (h)
        if (n.empty) {
          if (x.gecko) {
            let a = ff(r.node, r.offset);
            if (a && a != 3) {
              let c = $l(r.node, r.offset, a == 1 ? 1 : -1);
              c && (r = new ht(c, a == 1 ? 0 : c.nodeValue.length));
            }
          }
          h.collapse(r.node, r.offset), n.bidiLevel != null && l.cursorBidiLevel != null && (l.cursorBidiLevel = n.bidiLevel);
        } else if (h.extend) {
          h.collapse(r.node, r.offset);
          try {
            h.extend(o.node, o.offset);
          } catch {
          }
        } else {
          let a = document.createRange();
          n.anchor > n.head && ([r, o] = [o, r]), a.setEnd(o.node, o.offset), a.setStart(r.node, r.offset), h.removeAllRanges(), h.addRange(a);
        }
    }), this.view.observer.setSelectionRange(r, o)), this.impreciseAnchor = r.precise ? null : new ht(l.anchorNode, l.anchorOffset), this.impreciseHead = o.precise ? null : new ht(l.focusNode, l.focusOffset);
  }
  enforceCursorAssoc() {
    if (this.compositionDeco.size)
      return;
    let t = this.view.state.selection.main, e = Zi(this.view.root);
    if (!e || !t.empty || !t.assoc || !e.modify)
      return;
    let i = ut.find(this, t.head);
    if (!i)
      return;
    let n = i.posAtStart;
    if (t.head == n || t.head == n + i.length)
      return;
    let r = this.coordsAt(t.head, -1), o = this.coordsAt(t.head, 1);
    if (!r || !o || r.bottom > o.top)
      return;
    let l = this.domAtPos(t.head + t.assoc);
    e.collapse(l.node, l.offset), e.modify("move", t.assoc < 0 ? "forward" : "backward", "lineboundary");
  }
  mayControlSelection() {
    let t = this.view.root.activeElement;
    return t == this.dom || zi(this.dom, this.view.observer.selectionRange) && !(t && this.dom.contains(t));
  }
  nearest(t) {
    for (let e = t; e; ) {
      let i = W.get(e);
      if (i && i.rootView == this)
        return i;
      e = e.parentNode;
    }
    return null;
  }
  posFromDOM(t, e) {
    let i = this.nearest(t);
    if (!i)
      throw new RangeError("Trying to find position for a DOM position outside of the document");
    return i.localPosFromDOM(t, e) + i.posAtStart;
  }
  domAtPos(t) {
    let { i: e, off: i } = this.childCursor().findPos(t, -1);
    for (; e < this.children.length - 1; ) {
      let n = this.children[e];
      if (i < n.length || n instanceof ut)
        break;
      e++, i = 0;
    }
    return this.children[e].domAtPos(i);
  }
  coordsAt(t, e) {
    for (let i = this.length, n = this.children.length - 1; ; n--) {
      let r = this.children[n], o = i - r.breakAfter - r.length;
      if (t > o || t == o && r.type != U.WidgetBefore && r.type != U.WidgetAfter && (!n || e == 2 || this.children[n - 1].breakAfter || this.children[n - 1].type == U.WidgetBefore && e > -2))
        return r.coordsAt(t - o, e);
      i = o;
    }
  }
  measureVisibleLineHeights(t) {
    let e = [], { from: i, to: n } = t, r = this.view.contentDOM.clientWidth, o = r > Math.max(this.view.scrollDOM.clientWidth, this.minWidth) + 1, l = -1, h = this.view.textDirection == X.LTR;
    for (let a = 0, c = 0; c < this.children.length; c++) {
      let f = this.children[c], u = a + f.length;
      if (u > n)
        break;
      if (a >= i) {
        let d = f.dom.getBoundingClientRect();
        if (e.push(d.height), o) {
          let p = f.dom.lastChild, w = p ? di(p) : [];
          if (w.length) {
            let g = w[w.length - 1], y = h ? g.right - d.left : d.right - g.left;
            y > l && (l = y, this.minWidth = r, this.minWidthFrom = a, this.minWidthTo = u);
          }
        }
      }
      a = u + f.breakAfter;
    }
    return e;
  }
  textDirectionAt(t) {
    let { i: e } = this.childPos(t, 1);
    return getComputedStyle(this.children[e].dom).direction == "rtl" ? X.RTL : X.LTR;
  }
  measureTextSize() {
    for (let n of this.children)
      if (n instanceof ut) {
        let r = n.measureTextSize();
        if (r)
          return r;
      }
    let t = document.createElement("div"), e, i;
    return t.className = "cm-line", t.style.width = "99999px", t.textContent = "abc def ghi jkl mno pqr stu", this.view.observer.ignore(() => {
      this.dom.appendChild(t);
      let n = di(t.firstChild)[0];
      e = t.getBoundingClientRect().height, i = n ? n.width / 27 : 7, t.remove();
    }), { lineHeight: e, charWidth: i };
  }
  childCursor(t = this.length) {
    let e = this.children.length;
    return e && (t -= this.children[--e].length), new dl(this.children, t, e);
  }
  computeBlockGapDeco() {
    let t = [], e = this.view.viewState;
    for (let i = 0, n = 0; ; n++) {
      let r = n == e.viewports.length ? null : e.viewports[n], o = r ? r.from - 1 : this.length;
      if (o > i) {
        let l = e.lineBlockAt(o).bottom - e.lineBlockAt(i).top;
        t.push(D.replace({
          widget: new Br(l),
          block: !0,
          inclusive: !0,
          isBlockGap: !0
        }).range(i, o));
      }
      if (!r)
        break;
      i = r.to + 1;
    }
    return D.set(t);
  }
  updateDeco() {
    let t = this.view.state.facet(gi).map((e, i) => (this.dynamicDecorationMap[i] = typeof e == "function") ? e(this.view) : e);
    for (let e = t.length; e < t.length + 3; e++)
      this.dynamicDecorationMap[e] = !1;
    return this.decorations = [
      ...t,
      this.compositionDeco,
      this.computeBlockGapDeco(),
      this.view.viewState.lineGapDeco
    ];
  }
  scrollIntoView(t) {
    let { range: e } = t, i = this.coordsAt(e.head, e.empty ? e.assoc : e.head > e.anchor ? -1 : 1), n;
    if (!i)
      return;
    !e.empty && (n = this.coordsAt(e.anchor, e.anchor > e.head ? -1 : 1)) && (i = {
      left: Math.min(i.left, n.left),
      top: Math.min(i.top, n.top),
      right: Math.max(i.right, n.right),
      bottom: Math.max(i.bottom, n.bottom)
    });
    let r = 0, o = 0, l = 0, h = 0;
    for (let c of this.view.state.facet(Ll).map((f) => f(this.view)))
      if (c) {
        let { left: f, right: u, top: d, bottom: p } = c;
        f != null && (r = Math.max(r, f)), u != null && (o = Math.max(o, u)), d != null && (l = Math.max(l, d)), p != null && (h = Math.max(h, p));
      }
    let a = {
      left: i.left - r,
      top: i.top - l,
      right: i.right + o,
      bottom: i.bottom + h
    };
    Gc(this.view.scrollDOM, a, e.head < e.anchor ? -1 : 1, t.x, t.y, t.xMargin, t.yMargin, this.view.textDirection == X.LTR);
  }
}
function hf(s) {
  return s.node.nodeType == 1 && s.node.firstChild && (s.offset == 0 || s.node.childNodes[s.offset - 1].contentEditable == "false") && (s.offset == s.node.childNodes.length || s.node.childNodes[s.offset].contentEditable == "false");
}
class Br extends ye {
  constructor(t) {
    super(), this.height = t;
  }
  toDOM() {
    let t = document.createElement("div");
    return this.updateDOM(t), t;
  }
  eq(t) {
    return t.height == this.height;
  }
  updateDOM(t) {
    return t.style.height = this.height + "px", !0;
  }
  get estimatedHeight() {
    return this.height;
  }
}
function Hl(s) {
  let t = s.observer.selectionRange, e = t.focusNode && $l(t.focusNode, t.focusOffset, 0);
  if (!e)
    return null;
  let i = s.docView.nearest(e);
  if (!i)
    return null;
  if (i instanceof ut) {
    let n = e;
    for (; n.parentNode != i.dom; )
      n = n.parentNode;
    let r = n.previousSibling;
    for (; r && !W.get(r); )
      r = r.previousSibling;
    let o = r ? W.get(r).posAtEnd : i.posAtStart;
    return { from: o, to: o, node: n, text: e };
  } else {
    for (; ; ) {
      let { parent: r } = i;
      if (!r)
        return null;
      if (r instanceof ut)
        break;
      i = r;
    }
    let n = i.posAtStart;
    return { from: n, to: n + i.length, node: i.dom, text: e };
  }
}
function af(s, t) {
  let e = Hl(s);
  if (!e)
    return D.none;
  let { from: i, to: n, node: r, text: o } = e, l = t.mapPos(i, 1), h = Math.max(l, t.mapPos(n, -1)), { state: a } = s, c = r.nodeType == 3 ? r.nodeValue : new Il([], a).readRange(r.firstChild, null).text;
  if (h - l < c.length)
    if (a.doc.sliceString(l, Math.min(a.doc.length, l + c.length), he) == c)
      h = l + c.length;
    else if (a.doc.sliceString(Math.max(0, h - c.length), h, he) == c)
      l = h - c.length;
    else
      return D.none;
  else if (a.doc.sliceString(l, h, he) != c)
    return D.none;
  let f = W.get(r);
  return f instanceof yl ? f = f.widget.topView : f && (f.parent = null), D.set(D.replace({ widget: new cf(r, o, f), inclusive: !0 }).range(l, h));
}
class cf extends ye {
  constructor(t, e, i) {
    super(), this.top = t, this.text = e, this.topView = i;
  }
  eq(t) {
    return this.top == t.top && this.text == t.text;
  }
  toDOM() {
    return this.top;
  }
  ignoreEvent() {
    return !1;
  }
  get customView() {
    return yl;
  }
}
function $l(s, t, e) {
  for (; ; ) {
    if (s.nodeType == 3)
      return s;
    if (s.nodeType == 1 && t > 0 && e <= 0)
      s = s.childNodes[t - 1], t = pi(s);
    else if (s.nodeType == 1 && t < s.childNodes.length && e >= 0)
      s = s.childNodes[t], t = 0;
    else
      return null;
  }
}
function ff(s, t) {
  return s.nodeType != 1 ? 0 : (t && s.childNodes[t - 1].contentEditable == "false" ? 1 : 0) | (t < s.childNodes.length && s.childNodes[t].contentEditable == "false" ? 2 : 0);
}
class uf {
  constructor() {
    this.changes = [];
  }
  compareRange(t, e) {
    ks(t, e, this.changes);
  }
  comparePoint(t, e) {
    ks(t, e, this.changes);
  }
}
function df(s, t, e) {
  let i = new uf();
  return $.compare(s, t, e, i), i.changes;
}
function pf(s, t) {
  for (let e = s; e && e != t; e = e.assignedSlot || e.parentNode)
    if (e.nodeType == 1 && e.contentEditable == "false")
      return !0;
  return !1;
}
function gf(s, t, e = 1) {
  let i = s.charCategorizer(t), n = s.doc.lineAt(t), r = t - n.from;
  if (n.length == 0)
    return k.cursor(t);
  r == 0 ? e = 1 : r == n.length && (e = -1);
  let o = r, l = r;
  e < 0 ? o = xt(n.text, r, !1) : l = xt(n.text, r);
  let h = i(n.text.slice(o, l));
  for (; o > 0; ) {
    let a = xt(n.text, o, !1);
    if (i(n.text.slice(a, o)) != h)
      break;
    o = a;
  }
  for (; l < n.length; ) {
    let a = xt(n.text, l);
    if (i(n.text.slice(l, a)) != h)
      break;
    l = a;
  }
  return k.range(o + n.from, l + n.from);
}
function mf(s, t) {
  return t.left > s ? t.left - s : Math.max(0, s - t.right);
}
function wf(s, t) {
  return t.top > s ? t.top - s : Math.max(0, s - t.bottom);
}
function Hn(s, t) {
  return s.top < t.bottom - 1 && s.bottom > t.top + 1;
}
function Rr(s, t) {
  return t < s.top ? { top: t, left: s.left, right: s.right, bottom: s.bottom } : s;
}
function Lr(s, t) {
  return t > s.bottom ? { top: s.top, left: s.left, right: s.right, bottom: t } : s;
}
function Cs(s, t, e) {
  let i, n, r, o, l = !1, h, a, c, f;
  for (let p = s.firstChild; p; p = p.nextSibling) {
    let w = di(p);
    for (let g = 0; g < w.length; g++) {
      let y = w[g];
      n && Hn(n, y) && (y = Rr(Lr(y, n.bottom), n.top));
      let O = mf(t, y), T = wf(e, y);
      if (O == 0 && T == 0)
        return p.nodeType == 3 ? Er(p, t, e) : Cs(p, t, e);
      (!i || o > T || o == T && r > O) && (i = p, n = y, r = O, o = T, l = !O || (O > 0 ? g < w.length - 1 : g > 0)), O == 0 ? e > y.bottom && (!c || c.bottom < y.bottom) ? (h = p, c = y) : e < y.top && (!f || f.top > y.top) && (a = p, f = y) : c && Hn(c, y) ? c = Lr(c, y.bottom) : f && Hn(f, y) && (f = Rr(f, y.top));
    }
  }
  if (c && c.bottom >= e ? (i = h, n = c) : f && f.top <= e && (i = a, n = f), !i)
    return { node: s, offset: 0 };
  let u = Math.max(n.left, Math.min(n.right, t));
  if (i.nodeType == 3)
    return Er(i, u, e);
  if (l && i.contentEditable != "false")
    return Cs(i, u, e);
  let d = Array.prototype.indexOf.call(s.childNodes, i) + (t >= (n.left + n.right) / 2 ? 1 : 0);
  return { node: s, offset: d };
}
function Er(s, t, e) {
  let i = s.nodeValue.length, n = -1, r = 1e9, o = 0;
  for (let l = 0; l < i; l++) {
    let h = je(s, l, l + 1).getClientRects();
    for (let a = 0; a < h.length; a++) {
      let c = h[a];
      if (c.top == c.bottom)
        continue;
      o || (o = t - c.left);
      let f = (c.top > e ? c.top - e : e - c.bottom) - 1;
      if (c.left - 1 <= t && c.right + 1 >= t && f < r) {
        let u = t >= (c.left + c.right) / 2, d = u;
        if ((x.chrome || x.gecko) && je(s, l).getBoundingClientRect().left == c.right && (d = !u), f <= 0)
          return { node: s, offset: l + (d ? 1 : 0) };
        n = l + (d ? 1 : 0), r = f;
      }
    }
  }
  return { node: s, offset: n > -1 ? n : o > 0 ? s.nodeValue.length : 0 };
}
function Fl(s, { x: t, y: e }, i, n = -1) {
  var r;
  let o = s.contentDOM.getBoundingClientRect(), l = o.top + s.viewState.paddingTop, h, { docHeight: a } = s.viewState, c = e - l;
  if (c < 0)
    return 0;
  if (c > a)
    return s.state.doc.length;
  for (let y = s.defaultLineHeight / 2, O = !1; h = s.elementAtHeight(c), h.type != U.Text; )
    for (; c = n > 0 ? h.bottom + y : h.top - y, !(c >= 0 && c <= a); ) {
      if (O)
        return i ? null : 0;
      O = !0, n = -n;
    }
  e = l + c;
  let f = h.from;
  if (f < s.viewport.from)
    return s.viewport.from == 0 ? 0 : i ? null : Nr(s, o, h, t, e);
  if (f > s.viewport.to)
    return s.viewport.to == s.state.doc.length ? s.state.doc.length : i ? null : Nr(s, o, h, t, e);
  let u = s.dom.ownerDocument, d = s.root.elementFromPoint ? s.root : u, p = d.elementFromPoint(t, e);
  p && !s.contentDOM.contains(p) && (p = null), p || (t = Math.max(o.left + 1, Math.min(o.right - 1, t)), p = d.elementFromPoint(t, e), p && !s.contentDOM.contains(p) && (p = null));
  let w, g = -1;
  if (p && ((r = s.docView.nearest(p)) === null || r === void 0 ? void 0 : r.isEditable) != !1) {
    if (u.caretPositionFromPoint) {
      let y = u.caretPositionFromPoint(t, e);
      y && ({ offsetNode: w, offset: g } = y);
    } else if (u.caretRangeFromPoint) {
      let y = u.caretRangeFromPoint(t, e);
      y && ({ startContainer: w, startOffset: g } = y, (!s.contentDOM.contains(w) || x.safari && yf(w, g, t) || x.chrome && bf(w, g, t)) && (w = void 0));
    }
  }
  if (!w || !s.docView.dom.contains(w)) {
    let y = ut.find(s.docView, f);
    if (!y)
      return c > h.top + h.height / 2 ? h.to : h.from;
    ({ node: w, offset: g } = Cs(y.dom, t, e));
  }
  return s.docView.posFromDOM(w, g);
}
function Nr(s, t, e, i, n) {
  let r = Math.round((i - t.left) * s.defaultCharacterWidth);
  s.lineWrapping && e.height > s.defaultLineHeight * 1.5 && (r += Math.floor((n - e.top) / s.defaultLineHeight) * s.viewState.heightOracle.lineLength);
  let o = s.state.sliceDoc(e.from, e.to);
  return e.from + Hc(o, r, s.state.tabSize);
}
function yf(s, t, e) {
  let i;
  if (s.nodeType != 3 || t != (i = s.nodeValue.length))
    return !1;
  for (let n = s.nextSibling; n; n = n.nextSibling)
    if (n.nodeType != 1 || n.nodeName != "BR")
      return !1;
  return je(s, i - 1, i).getBoundingClientRect().left > e;
}
function bf(s, t, e) {
  if (t != 0)
    return !1;
  for (let n = s; ; ) {
    let r = n.parentNode;
    if (!r || r.nodeType != 1 || r.firstChild != n)
      return !1;
    if (r.classList.contains("cm-line"))
      break;
    n = r;
  }
  let i = s.nodeType == 1 ? s.getBoundingClientRect() : je(s, 0, Math.max(s.nodeValue.length, 1)).getBoundingClientRect();
  return e - i.left > 5;
}
function kf(s, t, e, i) {
  let n = s.state.doc.lineAt(t.head), r = !i || !s.lineWrapping ? null : s.coordsAtPos(t.assoc < 0 && t.head > n.from ? t.head - 1 : t.head);
  if (r) {
    let h = s.dom.getBoundingClientRect(), a = s.textDirectionAt(n.from), c = s.posAtCoords({
      x: e == (a == X.LTR) ? h.right - 1 : h.left + 1,
      y: (r.top + r.bottom) / 2
    });
    if (c != null)
      return k.cursor(c, e ? -1 : 1);
  }
  let o = ut.find(s.docView, t.head), l = o ? e ? o.posAtEnd : o.posAtStart : e ? n.to : n.from;
  return k.cursor(l, e ? -1 : 1);
}
function Vr(s, t, e, i) {
  let n = s.state.doc.lineAt(t.head), r = s.bidiSpans(n), o = s.textDirectionAt(n.from);
  for (let l = t, h = null; ; ) {
    let a = lf(n, r, o, l, e), c = Vl;
    if (!a) {
      if (n.number == (e ? s.state.doc.lines : 1))
        return l;
      c = `
`, n = s.state.doc.line(n.number + (e ? 1 : -1)), r = s.bidiSpans(n), a = k.cursor(e ? n.from : n.to);
    }
    if (h) {
      if (!h(c))
        return l;
    } else {
      if (!i)
        return a;
      h = i(c);
    }
    l = a;
  }
}
function xf(s, t, e) {
  let i = s.state.charCategorizer(t), n = i(e);
  return (r) => {
    let o = i(r);
    return n == Qt.Space && (n = o), n == o;
  };
}
function vf(s, t, e, i) {
  let n = t.head, r = e ? 1 : -1;
  if (n == (e ? s.state.doc.length : 0))
    return k.cursor(n, t.assoc);
  let o = t.goalColumn, l, h = s.contentDOM.getBoundingClientRect(), a = s.coordsAtPos(n), c = s.documentTop;
  if (a)
    o == null && (o = a.left - h.left), l = r < 0 ? a.top : a.bottom;
  else {
    let d = s.viewState.lineBlockAt(n);
    o == null && (o = Math.min(h.right - h.left, s.defaultCharacterWidth * (n - d.from))), l = (r < 0 ? d.top : d.bottom) + c;
  }
  let f = h.left + o, u = i != null ? i : s.defaultLineHeight >> 1;
  for (let d = 0; ; d += 10) {
    let p = l + (u + d) * r, w = Fl(s, { x: f, y: p }, !1, r);
    if (p < h.top || p > h.bottom || (r < 0 ? w < n : w > n))
      return k.cursor(w, t.assoc, void 0, o);
  }
}
function $n(s, t, e) {
  let i = s.state.facet(Rl).map((n) => n(s));
  for (; ; ) {
    let n = !1;
    for (let r of i)
      r.between(e.from - 1, e.from + 1, (o, l, h) => {
        e.from > o && e.from < l && (e = t.head > e.from ? k.cursor(o, 1) : k.cursor(l, -1), n = !0);
      });
    if (!n)
      return e;
  }
}
class Sf {
  constructor(t) {
    this.lastKeyCode = 0, this.lastKeyTime = 0, this.lastTouchTime = 0, this.lastFocusTime = 0, this.lastScrollTop = 0, this.lastScrollLeft = 0, this.chromeScrollHack = -1, this.pendingIOSKey = void 0, this.lastSelectionOrigin = null, this.lastSelectionTime = 0, this.lastEscPress = 0, this.lastContextMenu = 0, this.scrollHandlers = [], this.registeredEvents = [], this.customHandlers = [], this.composing = -1, this.compositionFirstChange = null, this.compositionEndedAt = 0, this.mouseSelection = null;
    for (let e in Z) {
      let i = Z[e];
      t.contentDOM.addEventListener(e, (n) => {
        !Ir(t, n) || this.ignoreDuringComposition(n) || e == "keydown" && this.keydown(t, n) || (this.mustFlushObserver(n) && t.observer.forceFlush(), this.runCustomHandlers(e, t, n) ? n.preventDefault() : i(t, n));
      }, As[e]), this.registeredEvents.push(e);
    }
    x.chrome && x.chrome_version == 102 && t.scrollDOM.addEventListener("wheel", () => {
      this.chromeScrollHack < 0 ? t.contentDOM.style.pointerEvents = "none" : window.clearTimeout(this.chromeScrollHack), this.chromeScrollHack = setTimeout(() => {
        this.chromeScrollHack = -1, t.contentDOM.style.pointerEvents = "";
      }, 100);
    }, { passive: !0 }), this.notifiedFocused = t.hasFocus, x.safari && t.contentDOM.addEventListener("input", () => null);
  }
  setSelectionOrigin(t) {
    this.lastSelectionOrigin = t, this.lastSelectionTime = Date.now();
  }
  ensureHandlers(t, e) {
    var i;
    let n;
    this.customHandlers = [];
    for (let r of e)
      if (n = (i = r.update(t).spec) === null || i === void 0 ? void 0 : i.domEventHandlers) {
        this.customHandlers.push({ plugin: r.value, handlers: n });
        for (let o in n)
          this.registeredEvents.indexOf(o) < 0 && o != "scroll" && (this.registeredEvents.push(o), t.contentDOM.addEventListener(o, (l) => {
            !Ir(t, l) || this.runCustomHandlers(o, t, l) && l.preventDefault();
          }));
      }
  }
  runCustomHandlers(t, e, i) {
    for (let n of this.customHandlers) {
      let r = n.handlers[t];
      if (r)
        try {
          if (r.call(n.plugin, i, e) || i.defaultPrevented)
            return !0;
        } catch (o) {
          zt(e.state, o);
        }
    }
    return !1;
  }
  runScrollHandlers(t, e) {
    this.lastScrollTop = t.scrollDOM.scrollTop, this.lastScrollLeft = t.scrollDOM.scrollLeft;
    for (let i of this.customHandlers) {
      let n = i.handlers.scroll;
      if (n)
        try {
          n.call(i.plugin, e, t);
        } catch (r) {
          zt(t.state, r);
        }
    }
  }
  keydown(t, e) {
    if (this.lastKeyCode = e.keyCode, this.lastKeyTime = Date.now(), e.keyCode == 9 && Date.now() < this.lastEscPress + 2e3)
      return !0;
    if (x.android && x.chrome && !e.synthetic && (e.keyCode == 13 || e.keyCode == 8))
      return t.observer.delayAndroidKey(e.key, e.keyCode), !0;
    let i;
    return x.ios && !e.synthetic && !e.altKey && !e.metaKey && ((i = zl.find((n) => n.keyCode == e.keyCode)) && !e.ctrlKey || Cf.indexOf(e.key) > -1 && e.ctrlKey && !e.shiftKey) ? (this.pendingIOSKey = i || e, setTimeout(() => this.flushIOSKey(t), 250), !0) : !1;
  }
  flushIOSKey(t) {
    let e = this.pendingIOSKey;
    return e ? (this.pendingIOSKey = void 0, hi(t.contentDOM, e.key, e.keyCode)) : !1;
  }
  ignoreDuringComposition(t) {
    return /^key/.test(t.type) ? this.composing > 0 ? !0 : x.safari && !x.ios && Date.now() - this.compositionEndedAt < 100 ? (this.compositionEndedAt = 0, !0) : !1 : !1;
  }
  mustFlushObserver(t) {
    return t.type == "keydown" && t.keyCode != 229;
  }
  startMouseSelection(t) {
    this.mouseSelection && this.mouseSelection.destroy(), this.mouseSelection = t;
  }
  update(t) {
    this.mouseSelection && this.mouseSelection.update(t), t.transactions.length && (this.lastKeyCode = this.lastSelectionTime = 0);
  }
  destroy() {
    this.mouseSelection && this.mouseSelection.destroy();
  }
}
const zl = [
  { key: "Backspace", keyCode: 8, inputType: "deleteContentBackward" },
  { key: "Enter", keyCode: 13, inputType: "insertParagraph" },
  { key: "Delete", keyCode: 46, inputType: "deleteContentForward" }
], Cf = "dthko", _l = [16, 17, 18, 20, 91, 92, 224, 225];
class Af {
  constructor(t, e, i, n) {
    this.view = t, this.style = i, this.mustSelect = n, this.lastEvent = e;
    let r = t.contentDOM.ownerDocument;
    r.addEventListener("mousemove", this.move = this.move.bind(this)), r.addEventListener("mouseup", this.up = this.up.bind(this)), this.extend = e.shiftKey, this.multiple = t.state.facet(E.allowMultipleSelections) && Of(t, e), this.dragMove = Mf(t, e), this.dragging = Df(t, e) && Gl(e) == 1 ? null : !1, this.dragging === !1 && (e.preventDefault(), this.select(e));
  }
  move(t) {
    if (t.buttons == 0)
      return this.destroy();
    this.dragging === !1 && this.select(this.lastEvent = t);
  }
  up(t) {
    this.dragging == null && this.select(this.lastEvent), this.dragging || t.preventDefault(), this.destroy();
  }
  destroy() {
    let t = this.view.contentDOM.ownerDocument;
    t.removeEventListener("mousemove", this.move), t.removeEventListener("mouseup", this.up), this.view.inputState.mouseSelection = null;
  }
  select(t) {
    let e = this.style.get(t, this.extend, this.multiple);
    (this.mustSelect || !e.eq(this.view.state.selection) || e.main.assoc != this.view.state.selection.main.assoc) && this.view.dispatch({
      selection: e,
      userEvent: "select.pointer",
      scrollIntoView: !0
    }), this.mustSelect = !1;
  }
  update(t) {
    t.docChanged && this.dragging && (this.dragging = this.dragging.map(t.changes)), this.style.update(t) && setTimeout(() => this.select(this.lastEvent), 20);
  }
}
function Of(s, t) {
  let e = s.state.facet(Cl);
  return e.length ? e[0](t) : x.mac ? t.metaKey : t.ctrlKey;
}
function Mf(s, t) {
  let e = s.state.facet(Al);
  return e.length ? e[0](t) : x.mac ? !t.altKey : !t.ctrlKey;
}
function Df(s, t) {
  let { main: e } = s.state.selection;
  if (e.empty)
    return !1;
  let i = Zi(s.root);
  if (!i || i.rangeCount == 0)
    return !0;
  let n = i.getRangeAt(0).getClientRects();
  for (let r = 0; r < n.length; r++) {
    let o = n[r];
    if (o.left <= t.clientX && o.right >= t.clientX && o.top <= t.clientY && o.bottom >= t.clientY)
      return !0;
  }
  return !1;
}
function Ir(s, t) {
  if (!t.bubbles)
    return !0;
  if (t.defaultPrevented)
    return !1;
  for (let e = t.target, i; e != s.contentDOM; e = e.parentNode)
    if (!e || e.nodeType == 11 || (i = W.get(e)) && i.ignoreEvent(t))
      return !1;
  return !0;
}
const Z = /* @__PURE__ */ Object.create(null), As = /* @__PURE__ */ Object.create(null), Wl = x.ie && x.ie_version < 15 || x.ios && x.webkit_version < 604;
function Tf(s) {
  let t = s.dom.parentNode;
  if (!t)
    return;
  let e = t.appendChild(document.createElement("textarea"));
  e.style.cssText = "position: fixed; left: -10000px; top: 10px", e.focus(), setTimeout(() => {
    s.focus(), e.remove(), jl(s, e.value);
  }, 50);
}
function jl(s, t) {
  let { state: e } = s, i, n = 1, r = e.toText(t), o = r.lines == e.selection.ranges.length;
  if (Os != null && e.selection.ranges.every((h) => h.empty) && Os == r.toString()) {
    let h = -1;
    i = e.changeByRange((a) => {
      let c = e.doc.lineAt(a.from);
      if (c.from == h)
        return { range: a };
      h = c.from;
      let f = e.toText((o ? r.line(n++).text : t) + e.lineBreak);
      return {
        changes: { from: c.from, insert: f },
        range: k.cursor(a.from + f.length)
      };
    });
  } else
    o ? i = e.changeByRange((h) => {
      let a = r.line(n++);
      return {
        changes: { from: h.from, to: h.to, insert: a.text },
        range: k.cursor(h.from + a.length)
      };
    }) : i = e.replaceSelection(r);
  s.dispatch(i, {
    userEvent: "input.paste",
    scrollIntoView: !0
  });
}
Z.keydown = (s, t) => {
  s.inputState.setSelectionOrigin("select"), t.keyCode == 27 ? s.inputState.lastEscPress = Date.now() : _l.indexOf(t.keyCode) < 0 && (s.inputState.lastEscPress = 0);
};
Z.touchstart = (s, t) => {
  s.inputState.lastTouchTime = Date.now(), s.inputState.setSelectionOrigin("select.pointer");
};
Z.touchmove = (s) => {
  s.inputState.setSelectionOrigin("select.pointer");
};
As.touchstart = As.touchmove = { passive: !0 };
Z.mousedown = (s, t) => {
  if (s.observer.flush(), s.inputState.lastTouchTime > Date.now() - 2e3)
    return;
  let e = null;
  for (let i of s.state.facet(Ol))
    if (e = i(s, t), e)
      break;
  if (!e && t.button == 0 && (e = Rf(s, t)), e) {
    let i = s.root.activeElement != s.contentDOM;
    i && s.observer.ignore(() => fl(s.contentDOM)), s.inputState.startMouseSelection(new Af(s, t, e, i));
  }
};
function Hr(s, t, e, i) {
  if (i == 1)
    return k.cursor(t, e);
  if (i == 2)
    return gf(s.state, t, e);
  {
    let n = ut.find(s.docView, t), r = s.state.doc.lineAt(n ? n.posAtEnd : t), o = n ? n.posAtStart : r.from, l = n ? n.posAtEnd : r.to;
    return l < s.state.doc.length && l == r.to && l++, k.range(o, l);
  }
}
let ql = (s, t) => s >= t.top && s <= t.bottom, $r = (s, t, e) => ql(t, e) && s >= e.left && s <= e.right;
function Pf(s, t, e, i) {
  let n = ut.find(s.docView, t);
  if (!n)
    return 1;
  let r = t - n.posAtStart;
  if (r == 0)
    return 1;
  if (r == n.length)
    return -1;
  let o = n.coordsAt(r, -1);
  if (o && $r(e, i, o))
    return -1;
  let l = n.coordsAt(r, 1);
  return l && $r(e, i, l) ? 1 : o && ql(i, o) ? -1 : 1;
}
function Fr(s, t) {
  let e = s.posAtCoords({ x: t.clientX, y: t.clientY }, !1);
  return { pos: e, bias: Pf(s, e, t.clientX, t.clientY) };
}
const Bf = x.ie && x.ie_version <= 11;
let zr = null, _r = 0, Wr = 0;
function Gl(s) {
  if (!Bf)
    return s.detail;
  let t = zr, e = Wr;
  return zr = s, Wr = Date.now(), _r = !t || e > Date.now() - 400 && Math.abs(t.clientX - s.clientX) < 2 && Math.abs(t.clientY - s.clientY) < 2 ? (_r + 1) % 3 : 1;
}
function Rf(s, t) {
  let e = Fr(s, t), i = Gl(t), n = s.state.selection, r = e, o = t;
  return {
    update(l) {
      l.docChanged && (e.pos = l.changes.mapPos(e.pos), n = n.map(l.changes), o = null);
    },
    get(l, h, a) {
      let c;
      o && l.clientX == o.clientX && l.clientY == o.clientY ? c = r : (c = r = Fr(s, l), o = l);
      let f = Hr(s, c.pos, c.bias, i);
      if (e.pos != c.pos && !h) {
        let u = Hr(s, e.pos, e.bias, i), d = Math.min(u.from, f.from), p = Math.max(u.to, f.to);
        f = d < f.from ? k.range(d, p) : k.range(p, d);
      }
      return h ? n.replaceRange(n.main.extend(f.from, f.to)) : a && n.ranges.length > 1 && n.ranges.some((u) => u.eq(f)) ? Lf(n, f) : a ? n.addRange(f) : k.create([f]);
    }
  };
}
function Lf(s, t) {
  for (let e = 0; ; e++)
    if (s.ranges[e].eq(t))
      return k.create(s.ranges.slice(0, e).concat(s.ranges.slice(e + 1)), s.mainIndex == e ? 0 : s.mainIndex - (s.mainIndex > e ? 1 : 0));
}
Z.dragstart = (s, t) => {
  let { selection: { main: e } } = s.state, { mouseSelection: i } = s.inputState;
  i && (i.dragging = e), t.dataTransfer && (t.dataTransfer.setData("Text", s.state.sliceDoc(e.from, e.to)), t.dataTransfer.effectAllowed = "copyMove");
};
function jr(s, t, e, i) {
  if (!e)
    return;
  let n = s.posAtCoords({ x: t.clientX, y: t.clientY }, !1);
  t.preventDefault();
  let { mouseSelection: r } = s.inputState, o = i && r && r.dragging && r.dragMove ? { from: r.dragging.from, to: r.dragging.to } : null, l = { from: n, insert: e }, h = s.state.changes(o ? [o, l] : l);
  s.focus(), s.dispatch({
    changes: h,
    selection: { anchor: h.mapPos(n, -1), head: h.mapPos(n, 1) },
    userEvent: o ? "move.drop" : "input.drop"
  });
}
Z.drop = (s, t) => {
  if (!t.dataTransfer)
    return;
  if (s.state.readOnly)
    return t.preventDefault();
  let e = t.dataTransfer.files;
  if (e && e.length) {
    t.preventDefault();
    let i = Array(e.length), n = 0, r = () => {
      ++n == e.length && jr(s, t, i.filter((o) => o != null).join(s.state.lineBreak), !1);
    };
    for (let o = 0; o < e.length; o++) {
      let l = new FileReader();
      l.onerror = r, l.onload = () => {
        /[\x00-\x08\x0e-\x1f]{2}/.test(l.result) || (i[o] = l.result), r();
      }, l.readAsText(e[o]);
    }
  } else
    jr(s, t, t.dataTransfer.getData("Text"), !0);
};
Z.paste = (s, t) => {
  if (s.state.readOnly)
    return t.preventDefault();
  s.observer.flush();
  let e = Wl ? null : t.clipboardData;
  e ? (jl(s, e.getData("text/plain")), t.preventDefault()) : Tf(s);
};
function Ef(s, t) {
  let e = s.dom.parentNode;
  if (!e)
    return;
  let i = e.appendChild(document.createElement("textarea"));
  i.style.cssText = "position: fixed; left: -10000px; top: 10px", i.value = t, i.focus(), i.selectionEnd = t.length, i.selectionStart = 0, setTimeout(() => {
    i.remove(), s.focus();
  }, 50);
}
function Nf(s) {
  let t = [], e = [], i = !1;
  for (let n of s.selection.ranges)
    n.empty || (t.push(s.sliceDoc(n.from, n.to)), e.push(n));
  if (!t.length) {
    let n = -1;
    for (let { from: r } of s.selection.ranges) {
      let o = s.doc.lineAt(r);
      o.number > n && (t.push(o.text), e.push({ from: o.from, to: Math.min(s.doc.length, o.to + 1) })), n = o.number;
    }
    i = !0;
  }
  return { text: t.join(s.lineBreak), ranges: e, linewise: i };
}
let Os = null;
Z.copy = Z.cut = (s, t) => {
  let { text: e, ranges: i, linewise: n } = Nf(s.state);
  if (!e && !n)
    return;
  Os = n ? e : null;
  let r = Wl ? null : t.clipboardData;
  r ? (t.preventDefault(), r.clearData(), r.setData("text/plain", e)) : Ef(s, e), t.type == "cut" && !s.state.readOnly && s.dispatch({
    changes: i,
    scrollIntoView: !0,
    userEvent: "delete.cut"
  });
};
function Kl(s) {
  setTimeout(() => {
    s.hasFocus != s.inputState.notifiedFocused && s.update([]);
  }, 10);
}
Z.focus = (s) => {
  s.inputState.lastFocusTime = Date.now(), !s.scrollDOM.scrollTop && (s.inputState.lastScrollTop || s.inputState.lastScrollLeft) && (s.scrollDOM.scrollTop = s.inputState.lastScrollTop, s.scrollDOM.scrollLeft = s.inputState.lastScrollLeft), Kl(s);
};
Z.blur = (s) => {
  s.observer.clearSelectionRange(), Kl(s);
};
Z.compositionstart = Z.compositionupdate = (s) => {
  s.inputState.compositionFirstChange == null && (s.inputState.compositionFirstChange = !0), s.inputState.composing < 0 && (s.inputState.composing = 0);
};
Z.compositionend = (s) => {
  s.inputState.composing = -1, s.inputState.compositionEndedAt = Date.now(), s.inputState.compositionFirstChange = null, x.chrome && x.android && s.observer.flushSoon(), setTimeout(() => {
    s.inputState.composing < 0 && s.docView.compositionDeco.size && s.update([]);
  }, 50);
};
Z.contextmenu = (s) => {
  s.inputState.lastContextMenu = Date.now();
};
Z.beforeinput = (s, t) => {
  var e;
  let i;
  if (x.chrome && x.android && (i = zl.find((n) => n.inputType == t.inputType)) && (s.observer.delayAndroidKey(i.key, i.keyCode), i.key == "Backspace" || i.key == "Delete")) {
    let n = ((e = window.visualViewport) === null || e === void 0 ? void 0 : e.height) || 0;
    setTimeout(() => {
      var r;
      (((r = window.visualViewport) === null || r === void 0 ? void 0 : r.height) || 0) > n + 10 && s.hasFocus && (s.contentDOM.blur(), s.focus());
    }, 100);
  }
};
const qr = ["pre-wrap", "normal", "pre-line", "break-spaces"];
class Vf {
  constructor() {
    this.doc = I.empty, this.lineWrapping = !1, this.heightSamples = {}, this.lineHeight = 14, this.charWidth = 7, this.lineLength = 30, this.heightChanged = !1;
  }
  heightForGap(t, e) {
    let i = this.doc.lineAt(e).number - this.doc.lineAt(t).number + 1;
    return this.lineWrapping && (i += Math.ceil((e - t - i * this.lineLength * 0.5) / this.lineLength)), this.lineHeight * i;
  }
  heightForLine(t) {
    return this.lineWrapping ? (1 + Math.max(0, Math.ceil((t - this.lineLength) / (this.lineLength - 5)))) * this.lineHeight : this.lineHeight;
  }
  setDoc(t) {
    return this.doc = t, this;
  }
  mustRefreshForWrapping(t) {
    return qr.indexOf(t) > -1 != this.lineWrapping;
  }
  mustRefreshForHeights(t) {
    let e = !1;
    for (let i = 0; i < t.length; i++) {
      let n = t[i];
      n < 0 ? i++ : this.heightSamples[Math.floor(n * 10)] || (e = !0, this.heightSamples[Math.floor(n * 10)] = !0);
    }
    return e;
  }
  refresh(t, e, i, n, r) {
    let o = qr.indexOf(t) > -1, l = Math.round(e) != Math.round(this.lineHeight) || this.lineWrapping != o;
    if (this.lineWrapping = o, this.lineHeight = e, this.charWidth = i, this.lineLength = n, l) {
      this.heightSamples = {};
      for (let h = 0; h < r.length; h++) {
        let a = r[h];
        a < 0 ? h++ : this.heightSamples[Math.floor(a * 10)] = !0;
      }
    }
    return l;
  }
}
class If {
  constructor(t, e) {
    this.from = t, this.heights = e, this.index = 0;
  }
  get more() {
    return this.index < this.heights.length;
  }
}
class ae {
  constructor(t, e, i, n, r) {
    this.from = t, this.length = e, this.top = i, this.height = n, this.type = r;
  }
  get to() {
    return this.from + this.length;
  }
  get bottom() {
    return this.top + this.height;
  }
  join(t) {
    let e = (Array.isArray(this.type) ? this.type : [this]).concat(Array.isArray(t.type) ? t.type : [t]);
    return new ae(this.from, this.length + t.length, this.top, this.height + t.height, e);
  }
}
var z = /* @__PURE__ */ function(s) {
  return s[s.ByPos = 0] = "ByPos", s[s.ByHeight = 1] = "ByHeight", s[s.ByPosNoHeight = 2] = "ByPosNoHeight", s;
}(z || (z = {}));
const _i = 1e-3;
class mt {
  constructor(t, e, i = 2) {
    this.length = t, this.height = e, this.flags = i;
  }
  get outdated() {
    return (this.flags & 2) > 0;
  }
  set outdated(t) {
    this.flags = (t ? 2 : 0) | this.flags & -3;
  }
  setHeight(t, e) {
    this.height != e && (Math.abs(this.height - e) > _i && (t.heightChanged = !0), this.height = e);
  }
  replace(t, e, i) {
    return mt.of(i);
  }
  decomposeLeft(t, e) {
    e.push(this);
  }
  decomposeRight(t, e) {
    e.push(this);
  }
  applyChanges(t, e, i, n) {
    let r = this;
    for (let o = n.length - 1; o >= 0; o--) {
      let { fromA: l, toA: h, fromB: a, toB: c } = n[o], f = r.lineAt(l, z.ByPosNoHeight, e, 0, 0), u = f.to >= h ? f : r.lineAt(h, z.ByPosNoHeight, e, 0, 0);
      for (c += u.to - h, h = u.to; o > 0 && f.from <= n[o - 1].toA; )
        l = n[o - 1].fromA, a = n[o - 1].fromB, o--, l < f.from && (f = r.lineAt(l, z.ByPosNoHeight, e, 0, 0));
      a += f.from - l, l = f.from;
      let d = Ks.build(i, t, a, c);
      r = r.replace(l, h, d);
    }
    return r.updateHeight(i, 0);
  }
  static empty() {
    return new bt(0, 0);
  }
  static of(t) {
    if (t.length == 1)
      return t[0];
    let e = 0, i = t.length, n = 0, r = 0;
    for (; ; )
      if (e == i)
        if (n > r * 2) {
          let l = t[e - 1];
          l.break ? t.splice(--e, 1, l.left, null, l.right) : t.splice(--e, 1, l.left, l.right), i += 1 + l.break, n -= l.size;
        } else if (r > n * 2) {
          let l = t[i];
          l.break ? t.splice(i, 1, l.left, null, l.right) : t.splice(i, 1, l.left, l.right), i += 2 + l.break, r -= l.size;
        } else
          break;
      else if (n < r) {
        let l = t[e++];
        l && (n += l.size);
      } else {
        let l = t[--i];
        l && (r += l.size);
      }
    let o = 0;
    return t[e - 1] == null ? (o = 1, e--) : t[e] == null && (o = 1, i++), new Hf(mt.of(t.slice(0, e)), o, mt.of(t.slice(i)));
  }
}
mt.prototype.size = 1;
class Ul extends mt {
  constructor(t, e, i) {
    super(t, e), this.type = i;
  }
  blockAt(t, e, i, n) {
    return new ae(n, this.length, i, this.height, this.type);
  }
  lineAt(t, e, i, n, r) {
    return this.blockAt(0, i, n, r);
  }
  forEachLine(t, e, i, n, r, o) {
    t <= r + this.length && e >= r && o(this.blockAt(0, i, n, r));
  }
  updateHeight(t, e = 0, i = !1, n) {
    return n && n.from <= e && n.more && this.setHeight(t, n.heights[n.index++]), this.outdated = !1, this;
  }
  toString() {
    return `block(${this.length})`;
  }
}
class bt extends Ul {
  constructor(t, e) {
    super(t, e, U.Text), this.collapsed = 0, this.widgetHeight = 0;
  }
  replace(t, e, i) {
    let n = i[0];
    return i.length == 1 && (n instanceof bt || n instanceof it && n.flags & 4) && Math.abs(this.length - n.length) < 10 ? (n instanceof it ? n = new bt(n.length, this.height) : n.height = this.height, this.outdated || (n.outdated = !1), n) : mt.of(i);
  }
  updateHeight(t, e = 0, i = !1, n) {
    return n && n.from <= e && n.more ? this.setHeight(t, n.heights[n.index++]) : (i || this.outdated) && this.setHeight(t, Math.max(this.widgetHeight, t.heightForLine(this.length - this.collapsed))), this.outdated = !1, this;
  }
  toString() {
    return `line(${this.length}${this.collapsed ? -this.collapsed : ""}${this.widgetHeight ? ":" + this.widgetHeight : ""})`;
  }
}
class it extends mt {
  constructor(t) {
    super(t, 0);
  }
  lines(t, e) {
    let i = t.lineAt(e).number, n = t.lineAt(e + this.length).number;
    return { firstLine: i, lastLine: n, lineHeight: this.height / (n - i + 1) };
  }
  blockAt(t, e, i, n) {
    let { firstLine: r, lastLine: o, lineHeight: l } = this.lines(e, n), h = Math.max(0, Math.min(o - r, Math.floor((t - i) / l))), { from: a, length: c } = e.line(r + h);
    return new ae(a, c, i + l * h, l, U.Text);
  }
  lineAt(t, e, i, n, r) {
    if (e == z.ByHeight)
      return this.blockAt(t, i, n, r);
    if (e == z.ByPosNoHeight) {
      let { from: f, to: u } = i.lineAt(t);
      return new ae(f, u - f, 0, 0, U.Text);
    }
    let { firstLine: o, lineHeight: l } = this.lines(i, r), { from: h, length: a, number: c } = i.lineAt(t);
    return new ae(h, a, n + l * (c - o), l, U.Text);
  }
  forEachLine(t, e, i, n, r, o) {
    let { firstLine: l, lineHeight: h } = this.lines(i, r);
    for (let a = Math.max(t, r), c = Math.min(r + this.length, e); a <= c; ) {
      let f = i.lineAt(a);
      a == t && (n += h * (f.number - l)), o(new ae(f.from, f.length, n, h, U.Text)), n += h, a = f.to + 1;
    }
  }
  replace(t, e, i) {
    let n = this.length - e;
    if (n > 0) {
      let r = i[i.length - 1];
      r instanceof it ? i[i.length - 1] = new it(r.length + n) : i.push(null, new it(n - 1));
    }
    if (t > 0) {
      let r = i[0];
      r instanceof it ? i[0] = new it(t + r.length) : i.unshift(new it(t - 1), null);
    }
    return mt.of(i);
  }
  decomposeLeft(t, e) {
    e.push(new it(t - 1), null);
  }
  decomposeRight(t, e) {
    e.push(null, new it(this.length - t - 1));
  }
  updateHeight(t, e = 0, i = !1, n) {
    let r = e + this.length;
    if (n && n.from <= e + this.length && n.more) {
      let o = [], l = Math.max(e, n.from), h = -1, a = t.heightChanged;
      for (n.from > e && o.push(new it(n.from - e - 1).updateHeight(t, e)); l <= r && n.more; ) {
        let f = t.doc.lineAt(l).length;
        o.length && o.push(null);
        let u = n.heights[n.index++];
        h == -1 ? h = u : Math.abs(u - h) >= _i && (h = -2);
        let d = new bt(f, u);
        d.outdated = !1, o.push(d), l += f + 1;
      }
      l <= r && o.push(null, new it(r - l).updateHeight(t, l));
      let c = mt.of(o);
      return t.heightChanged = a || h < 0 || Math.abs(c.height - this.height) >= _i || Math.abs(h - this.lines(t.doc, e).lineHeight) >= _i, c;
    } else
      (i || this.outdated) && (this.setHeight(t, t.heightForGap(e, e + this.length)), this.outdated = !1);
    return this;
  }
  toString() {
    return `gap(${this.length})`;
  }
}
class Hf extends mt {
  constructor(t, e, i) {
    super(t.length + e + i.length, t.height + i.height, e | (t.outdated || i.outdated ? 2 : 0)), this.left = t, this.right = i, this.size = t.size + i.size;
  }
  get break() {
    return this.flags & 1;
  }
  blockAt(t, e, i, n) {
    let r = i + this.left.height;
    return t < r ? this.left.blockAt(t, e, i, n) : this.right.blockAt(t, e, r, n + this.left.length + this.break);
  }
  lineAt(t, e, i, n, r) {
    let o = n + this.left.height, l = r + this.left.length + this.break, h = e == z.ByHeight ? t < o : t < l, a = h ? this.left.lineAt(t, e, i, n, r) : this.right.lineAt(t, e, i, o, l);
    if (this.break || (h ? a.to < l : a.from > l))
      return a;
    let c = e == z.ByPosNoHeight ? z.ByPosNoHeight : z.ByPos;
    return h ? a.join(this.right.lineAt(l, c, i, o, l)) : this.left.lineAt(l, c, i, n, r).join(a);
  }
  forEachLine(t, e, i, n, r, o) {
    let l = n + this.left.height, h = r + this.left.length + this.break;
    if (this.break)
      t < h && this.left.forEachLine(t, e, i, n, r, o), e >= h && this.right.forEachLine(t, e, i, l, h, o);
    else {
      let a = this.lineAt(h, z.ByPos, i, n, r);
      t < a.from && this.left.forEachLine(t, a.from - 1, i, n, r, o), a.to >= t && a.from <= e && o(a), e > a.to && this.right.forEachLine(a.to + 1, e, i, l, h, o);
    }
  }
  replace(t, e, i) {
    let n = this.left.length + this.break;
    if (e < n)
      return this.balanced(this.left.replace(t, e, i), this.right);
    if (t > this.left.length)
      return this.balanced(this.left, this.right.replace(t - n, e - n, i));
    let r = [];
    t > 0 && this.decomposeLeft(t, r);
    let o = r.length;
    for (let l of i)
      r.push(l);
    if (t > 0 && Gr(r, o - 1), e < this.length) {
      let l = r.length;
      this.decomposeRight(e, r), Gr(r, l);
    }
    return mt.of(r);
  }
  decomposeLeft(t, e) {
    let i = this.left.length;
    if (t <= i)
      return this.left.decomposeLeft(t, e);
    e.push(this.left), this.break && (i++, t >= i && e.push(null)), t > i && this.right.decomposeLeft(t - i, e);
  }
  decomposeRight(t, e) {
    let i = this.left.length, n = i + this.break;
    if (t >= n)
      return this.right.decomposeRight(t - n, e);
    t < i && this.left.decomposeRight(t, e), this.break && t < n && e.push(null), e.push(this.right);
  }
  balanced(t, e) {
    return t.size > 2 * e.size || e.size > 2 * t.size ? mt.of(this.break ? [t, null, e] : [t, e]) : (this.left = t, this.right = e, this.height = t.height + e.height, this.outdated = t.outdated || e.outdated, this.size = t.size + e.size, this.length = t.length + this.break + e.length, this);
  }
  updateHeight(t, e = 0, i = !1, n) {
    let { left: r, right: o } = this, l = e + r.length + this.break, h = null;
    return n && n.from <= e + r.length && n.more ? h = r = r.updateHeight(t, e, i, n) : r.updateHeight(t, e, i), n && n.from <= l + o.length && n.more ? h = o = o.updateHeight(t, l, i, n) : o.updateHeight(t, l, i), h ? this.balanced(r, o) : (this.height = this.left.height + this.right.height, this.outdated = !1, this);
  }
  toString() {
    return this.left + (this.break ? " " : "-") + this.right;
  }
}
function Gr(s, t) {
  let e, i;
  s[t] == null && (e = s[t - 1]) instanceof it && (i = s[t + 1]) instanceof it && s.splice(t - 1, 3, new it(e.length + 1 + i.length));
}
const $f = 5;
class Ks {
  constructor(t, e) {
    this.pos = t, this.oracle = e, this.nodes = [], this.lineStart = -1, this.lineEnd = -1, this.covering = null, this.writtenTo = t;
  }
  get isCovered() {
    return this.covering && this.nodes[this.nodes.length - 1] == this.covering;
  }
  span(t, e) {
    if (this.lineStart > -1) {
      let i = Math.min(e, this.lineEnd), n = this.nodes[this.nodes.length - 1];
      n instanceof bt ? n.length += i - this.pos : (i > this.pos || !this.isCovered) && this.nodes.push(new bt(i - this.pos, -1)), this.writtenTo = i, e > i && (this.nodes.push(null), this.writtenTo++, this.lineStart = -1);
    }
    this.pos = e;
  }
  point(t, e, i) {
    if (t < e || i.heightRelevant) {
      let n = i.widget ? i.widget.estimatedHeight : 0;
      n < 0 && (n = this.oracle.lineHeight);
      let r = e - t;
      i.block ? this.addBlock(new Ul(r, n, i.type)) : (r || n >= $f) && this.addLineDeco(n, r);
    } else
      e > t && this.span(t, e);
    this.lineEnd > -1 && this.lineEnd < this.pos && (this.lineEnd = this.oracle.doc.lineAt(this.pos).to);
  }
  enterLine() {
    if (this.lineStart > -1)
      return;
    let { from: t, to: e } = this.oracle.doc.lineAt(this.pos);
    this.lineStart = t, this.lineEnd = e, this.writtenTo < t && ((this.writtenTo < t - 1 || this.nodes[this.nodes.length - 1] == null) && this.nodes.push(this.blankContent(this.writtenTo, t - 1)), this.nodes.push(null)), this.pos > t && this.nodes.push(new bt(this.pos - t, -1)), this.writtenTo = this.pos;
  }
  blankContent(t, e) {
    let i = new it(e - t);
    return this.oracle.doc.lineAt(t).to == e && (i.flags |= 4), i;
  }
  ensureLine() {
    this.enterLine();
    let t = this.nodes.length ? this.nodes[this.nodes.length - 1] : null;
    if (t instanceof bt)
      return t;
    let e = new bt(0, -1);
    return this.nodes.push(e), e;
  }
  addBlock(t) {
    this.enterLine(), t.type == U.WidgetAfter && !this.isCovered && this.ensureLine(), this.nodes.push(t), this.writtenTo = this.pos = this.pos + t.length, t.type != U.WidgetBefore && (this.covering = t);
  }
  addLineDeco(t, e) {
    let i = this.ensureLine();
    i.length += e, i.collapsed += e, i.widgetHeight = Math.max(i.widgetHeight, t), this.writtenTo = this.pos = this.pos + e;
  }
  finish(t) {
    let e = this.nodes.length == 0 ? null : this.nodes[this.nodes.length - 1];
    this.lineStart > -1 && !(e instanceof bt) && !this.isCovered ? this.nodes.push(new bt(0, -1)) : (this.writtenTo < this.pos || e == null) && this.nodes.push(this.blankContent(this.writtenTo, this.pos));
    let i = t;
    for (let n of this.nodes)
      n instanceof bt && n.updateHeight(this.oracle, i), i += n ? n.length : 1;
    return this.nodes;
  }
  static build(t, e, i, n) {
    let r = new Ks(i, t);
    return $.spans(e, i, n, r, 0), r.finish(i);
  }
}
function Ff(s, t, e) {
  let i = new zf();
  return $.compare(s, t, e, i, 0), i.changes;
}
class zf {
  constructor() {
    this.changes = [];
  }
  compareRange() {
  }
  comparePoint(t, e, i, n) {
    (t < e || i && i.heightRelevant || n && n.heightRelevant) && ks(t, e, this.changes, 5);
  }
}
function _f(s, t) {
  let e = s.getBoundingClientRect(), i = s.ownerDocument, n = i.defaultView || window, r = Math.max(0, e.left), o = Math.min(n.innerWidth, e.right), l = Math.max(0, e.top), h = Math.min(n.innerHeight, e.bottom);
  for (let a = s.parentNode; a && a != i.body; )
    if (a.nodeType == 1) {
      let c = a, f = window.getComputedStyle(c);
      if ((c.scrollHeight > c.clientHeight || c.scrollWidth > c.clientWidth) && f.overflow != "visible") {
        let u = c.getBoundingClientRect();
        r = Math.max(r, u.left), o = Math.min(o, u.right), l = Math.max(l, u.top), h = a == s.parentNode ? u.bottom : Math.min(h, u.bottom);
      }
      a = f.position == "absolute" || f.position == "fixed" ? c.offsetParent : c.parentNode;
    } else if (a.nodeType == 11)
      a = a.host;
    else
      break;
  return {
    left: r - e.left,
    right: Math.max(r, o) - e.left,
    top: l - (e.top + t),
    bottom: Math.max(l, h) - (e.top + t)
  };
}
function Wf(s, t) {
  let e = s.getBoundingClientRect();
  return {
    left: 0,
    right: e.right - e.left,
    top: t,
    bottom: e.bottom - (e.top + t)
  };
}
class Fn {
  constructor(t, e, i) {
    this.from = t, this.to = e, this.size = i;
  }
  static same(t, e) {
    if (t.length != e.length)
      return !1;
    for (let i = 0; i < t.length; i++) {
      let n = t[i], r = e[i];
      if (n.from != r.from || n.to != r.to || n.size != r.size)
        return !1;
    }
    return !0;
  }
  draw(t) {
    return D.replace({ widget: new jf(this.size, t) }).range(this.from, this.to);
  }
}
class jf extends ye {
  constructor(t, e) {
    super(), this.size = t, this.vertical = e;
  }
  eq(t) {
    return t.size == this.size && t.vertical == this.vertical;
  }
  toDOM() {
    let t = document.createElement("div");
    return this.vertical ? t.style.height = this.size + "px" : (t.style.width = this.size + "px", t.style.height = "2px", t.style.display = "inline-block"), t;
  }
  get estimatedHeight() {
    return this.vertical ? this.size : -1;
  }
}
class Kr {
  constructor(t) {
    this.state = t, this.pixelViewport = { left: 0, right: window.innerWidth, top: 0, bottom: 0 }, this.inView = !0, this.paddingTop = 0, this.paddingBottom = 0, this.contentDOMWidth = 0, this.contentDOMHeight = 0, this.editorHeight = 0, this.editorWidth = 0, this.heightOracle = new Vf(), this.scaler = Qr, this.scrollTarget = null, this.printing = !1, this.mustMeasureContent = !0, this.defaultTextDirection = X.RTL, this.visibleRanges = [], this.mustEnforceCursorAssoc = !1, this.stateDeco = t.facet(gi).filter((e) => typeof e != "function"), this.heightMap = mt.empty().applyChanges(this.stateDeco, I.empty, this.heightOracle.setDoc(t.doc), [new Yt(0, 0, 0, t.doc.length)]), this.viewport = this.getViewport(0, null), this.updateViewportLines(), this.updateForViewport(), this.lineGaps = this.ensureLineGaps([]), this.lineGapDeco = D.set(this.lineGaps.map((e) => e.draw(!1))), this.computeVisibleRanges();
  }
  updateForViewport() {
    let t = [this.viewport], { main: e } = this.state.selection;
    for (let i = 0; i <= 1; i++) {
      let n = i ? e.head : e.anchor;
      if (!t.some(({ from: r, to: o }) => n >= r && n <= o)) {
        let { from: r, to: o } = this.lineBlockAt(n);
        t.push(new Di(r, o));
      }
    }
    this.viewports = t.sort((i, n) => i.from - n.from), this.scaler = this.heightMap.height <= 7e6 ? Qr : new Kf(this.heightOracle.doc, this.heightMap, this.viewports);
  }
  updateViewportLines() {
    this.viewportLines = [], this.heightMap.forEachLine(this.viewport.from, this.viewport.to, this.state.doc, 0, 0, (t) => {
      this.viewportLines.push(this.scaler.scale == 1 ? t : si(t, this.scaler));
    });
  }
  update(t, e = null) {
    this.state = t.state;
    let i = this.stateDeco;
    this.stateDeco = this.state.facet(gi).filter((a) => typeof a != "function");
    let n = t.changedRanges, r = Yt.extendWithRanges(n, Ff(i, this.stateDeco, t ? t.changes : Y.empty(this.state.doc.length))), o = this.heightMap.height;
    this.heightMap = this.heightMap.applyChanges(this.stateDeco, t.startState.doc, this.heightOracle.setDoc(this.state.doc), r), this.heightMap.height != o && (t.flags |= 2);
    let l = r.length ? this.mapViewport(this.viewport, t.changes) : this.viewport;
    (e && (e.range.head < l.from || e.range.head > l.to) || !this.viewportIsAppropriate(l)) && (l = this.getViewport(0, e));
    let h = !t.changes.empty || t.flags & 2 || l.from != this.viewport.from || l.to != this.viewport.to;
    this.viewport = l, this.updateForViewport(), h && this.updateViewportLines(), (this.lineGaps.length || this.viewport.to - this.viewport.from > 2e3 << 1) && this.updateLineGaps(this.ensureLineGaps(this.mapLineGaps(this.lineGaps, t.changes))), t.flags |= this.computeVisibleRanges(), e && (this.scrollTarget = e), !this.mustEnforceCursorAssoc && t.selectionSet && t.view.lineWrapping && t.state.selection.main.empty && t.state.selection.main.assoc && (this.mustEnforceCursorAssoc = !0);
  }
  measure(t) {
    let e = t.contentDOM, i = window.getComputedStyle(e), n = this.heightOracle, r = i.whiteSpace;
    this.defaultTextDirection = i.direction == "rtl" ? X.RTL : X.LTR;
    let o = this.heightOracle.mustRefreshForWrapping(r), l = o || this.mustMeasureContent || this.contentDOMHeight != e.clientHeight;
    this.contentDOMHeight = e.clientHeight, this.mustMeasureContent = !1;
    let h = 0, a = 0, c = parseInt(i.paddingTop) || 0, f = parseInt(i.paddingBottom) || 0;
    (this.paddingTop != c || this.paddingBottom != f) && (this.paddingTop = c, this.paddingBottom = f, h |= 10), this.editorWidth != t.scrollDOM.clientWidth && (n.lineWrapping && (l = !0), this.editorWidth = t.scrollDOM.clientWidth, h |= 8);
    let u = (this.printing ? Wf : _f)(e, this.paddingTop), d = u.top - this.pixelViewport.top, p = u.bottom - this.pixelViewport.bottom;
    this.pixelViewport = u;
    let w = this.pixelViewport.bottom > this.pixelViewport.top && this.pixelViewport.right > this.pixelViewport.left;
    if (w != this.inView && (this.inView = w, w && (l = !0)), !this.inView && !this.scrollTarget)
      return 0;
    let g = e.clientWidth;
    if ((this.contentDOMWidth != g || this.editorHeight != t.scrollDOM.clientHeight) && (this.contentDOMWidth = g, this.editorHeight = t.scrollDOM.clientHeight, h |= 8), l) {
      let O = t.docView.measureVisibleLineHeights(this.viewport);
      if (n.mustRefreshForHeights(O) && (o = !0), o || n.lineWrapping && Math.abs(g - this.contentDOMWidth) > n.charWidth) {
        let { lineHeight: T, charWidth: C } = t.docView.measureTextSize();
        o = n.refresh(r, T, C, g / C, O), o && (t.docView.minWidth = 0, h |= 8);
      }
      d > 0 && p > 0 ? a = Math.max(d, p) : d < 0 && p < 0 && (a = Math.min(d, p)), n.heightChanged = !1;
      for (let T of this.viewports) {
        let C = T.from == this.viewport.from ? O : t.docView.measureVisibleLineHeights(T);
        this.heightMap = this.heightMap.updateHeight(n, 0, o, new If(T.from, C));
      }
      n.heightChanged && (h |= 2);
    }
    let y = !this.viewportIsAppropriate(this.viewport, a) || this.scrollTarget && (this.scrollTarget.range.head < this.viewport.from || this.scrollTarget.range.head > this.viewport.to);
    return y && (this.viewport = this.getViewport(a, this.scrollTarget)), this.updateForViewport(), (h & 2 || y) && this.updateViewportLines(), (this.lineGaps.length || this.viewport.to - this.viewport.from > 2e3 << 1) && this.updateLineGaps(this.ensureLineGaps(o ? [] : this.lineGaps, t)), h |= this.computeVisibleRanges(), this.mustEnforceCursorAssoc && (this.mustEnforceCursorAssoc = !1, t.docView.enforceCursorAssoc()), h;
  }
  get visibleTop() {
    return this.scaler.fromDOM(this.pixelViewport.top);
  }
  get visibleBottom() {
    return this.scaler.fromDOM(this.pixelViewport.bottom);
  }
  getViewport(t, e) {
    let i = 0.5 - Math.max(-0.5, Math.min(0.5, t / 1e3 / 2)), n = this.heightMap, r = this.state.doc, { visibleTop: o, visibleBottom: l } = this, h = new Di(n.lineAt(o - i * 1e3, z.ByHeight, r, 0, 0).from, n.lineAt(l + (1 - i) * 1e3, z.ByHeight, r, 0, 0).to);
    if (e) {
      let { head: a } = e.range;
      if (a < h.from || a > h.to) {
        let c = Math.min(this.editorHeight, this.pixelViewport.bottom - this.pixelViewport.top), f = n.lineAt(a, z.ByPos, r, 0, 0), u;
        e.y == "center" ? u = (f.top + f.bottom) / 2 - c / 2 : e.y == "start" || e.y == "nearest" && a < h.from ? u = f.top : u = f.bottom - c, h = new Di(n.lineAt(u - 1e3 / 2, z.ByHeight, r, 0, 0).from, n.lineAt(u + c + 1e3 / 2, z.ByHeight, r, 0, 0).to);
      }
    }
    return h;
  }
  mapViewport(t, e) {
    let i = e.mapPos(t.from, -1), n = e.mapPos(t.to, 1);
    return new Di(this.heightMap.lineAt(i, z.ByPos, this.state.doc, 0, 0).from, this.heightMap.lineAt(n, z.ByPos, this.state.doc, 0, 0).to);
  }
  viewportIsAppropriate({ from: t, to: e }, i = 0) {
    if (!this.inView)
      return !0;
    let { top: n } = this.heightMap.lineAt(t, z.ByPos, this.state.doc, 0, 0), { bottom: r } = this.heightMap.lineAt(e, z.ByPos, this.state.doc, 0, 0), { visibleTop: o, visibleBottom: l } = this;
    return (t == 0 || n <= o - Math.max(10, Math.min(-i, 250))) && (e == this.state.doc.length || r >= l + Math.max(10, Math.min(i, 250))) && n > o - 2 * 1e3 && r < l + 2 * 1e3;
  }
  mapLineGaps(t, e) {
    if (!t.length || e.empty)
      return t;
    let i = [];
    for (let n of t)
      e.touchesRange(n.from, n.to) || i.push(new Fn(e.mapPos(n.from), e.mapPos(n.to), n.size));
    return i;
  }
  ensureLineGaps(t, e) {
    let i = this.heightOracle.lineWrapping, n = i ? 1e4 : 2e3, r = n >> 1, o = n << 1;
    if (this.defaultTextDirection != X.LTR && !i)
      return [];
    let l = [], h = (a, c, f, u) => {
      if (c - a < r)
        return;
      let d = this.state.selection.main, p = [d.from];
      d.empty || p.push(d.to);
      for (let g of p)
        if (g > a && g < c) {
          h(a, g - 10, f, u), h(g + 10, c, f, u);
          return;
        }
      let w = Gf(t, (g) => g.from >= f.from && g.to <= f.to && Math.abs(g.from - a) < r && Math.abs(g.to - c) < r && !p.some((y) => g.from < y && g.to > y));
      if (!w) {
        if (c < f.to && e && i && e.visibleRanges.some((g) => g.from <= c && g.to >= c)) {
          let g = e.moveToLineBoundary(k.cursor(c), !1, !0).head;
          g > a && (c = g);
        }
        w = new Fn(a, c, this.gapSize(f, a, c, u));
      }
      l.push(w);
    };
    for (let a of this.viewportLines) {
      if (a.length < o)
        continue;
      let c = qf(a.from, a.to, this.stateDeco);
      if (c.total < o)
        continue;
      let f = this.scrollTarget ? this.scrollTarget.range.head : null, u, d;
      if (i) {
        let p = n / this.heightOracle.lineLength * this.heightOracle.lineHeight, w, g;
        f != null ? (w = Math.max(a.from, f - n), g = Math.min(a.to, f + n)) : (w = (this.visibleTop - a.top - p) / a.height, g = (this.visibleBottom - a.top + p) / a.height), u = Ti(c, w), d = Ti(c, g);
      } else {
        let p, w;
        if (f != null)
          p = Math.max(a.from, f - o), w = Math.min(a.to, f + o);
        else {
          let g = c.total * this.heightOracle.charWidth, y = n * this.heightOracle.charWidth;
          p = (this.pixelViewport.left - y) / g, w = (this.pixelViewport.right + y) / g;
        }
        u = Ti(c, p), d = Ti(c, w);
      }
      u > a.from && h(a.from, u, a, c), d < a.to && h(d, a.to, a, c);
    }
    return l;
  }
  gapSize(t, e, i, n) {
    let r = Ur(n, i) - Ur(n, e);
    return this.heightOracle.lineWrapping ? t.height * r : n.total * this.heightOracle.charWidth * r;
  }
  updateLineGaps(t) {
    Fn.same(t, this.lineGaps) || (this.lineGaps = t, this.lineGapDeco = D.set(t.map((e) => e.draw(this.heightOracle.lineWrapping))));
  }
  computeVisibleRanges() {
    let t = this.stateDeco;
    this.lineGaps.length && (t = t.concat(this.lineGapDeco));
    let e = [];
    $.spans(t, this.viewport.from, this.viewport.to, {
      span(n, r) {
        e.push({ from: n, to: r });
      },
      point() {
      }
    }, 20);
    let i = e.length != this.visibleRanges.length || this.visibleRanges.some((n, r) => n.from != e[r].from || n.to != e[r].to);
    return this.visibleRanges = e, i ? 4 : 0;
  }
  lineBlockAt(t) {
    return t >= this.viewport.from && t <= this.viewport.to && this.viewportLines.find((e) => e.from <= t && e.to >= t) || si(this.heightMap.lineAt(t, z.ByPos, this.state.doc, 0, 0), this.scaler);
  }
  lineBlockAtHeight(t) {
    return si(this.heightMap.lineAt(this.scaler.fromDOM(t), z.ByHeight, this.state.doc, 0, 0), this.scaler);
  }
  elementAtHeight(t) {
    return si(this.heightMap.blockAt(this.scaler.fromDOM(t), this.state.doc, 0, 0), this.scaler);
  }
  get docHeight() {
    return this.scaler.toDOM(this.heightMap.height);
  }
  get contentHeight() {
    return this.docHeight + this.paddingTop + this.paddingBottom;
  }
}
class Di {
  constructor(t, e) {
    this.from = t, this.to = e;
  }
}
function qf(s, t, e) {
  let i = [], n = s, r = 0;
  return $.spans(e, s, t, {
    span() {
    },
    point(o, l) {
      o > n && (i.push({ from: n, to: o }), r += o - n), n = l;
    }
  }, 20), n < t && (i.push({ from: n, to: t }), r += t - n), { total: r, ranges: i };
}
function Ti({ total: s, ranges: t }, e) {
  if (e <= 0)
    return t[0].from;
  if (e >= 1)
    return t[t.length - 1].to;
  let i = Math.floor(s * e);
  for (let n = 0; ; n++) {
    let { from: r, to: o } = t[n], l = o - r;
    if (i <= l)
      return r + i;
    i -= l;
  }
}
function Ur(s, t) {
  let e = 0;
  for (let { from: i, to: n } of s.ranges) {
    if (t <= n) {
      e += t - i;
      break;
    }
    e += n - i;
  }
  return e / s.total;
}
function Gf(s, t) {
  for (let e of s)
    if (t(e))
      return e;
}
const Qr = {
  toDOM(s) {
    return s;
  },
  fromDOM(s) {
    return s;
  },
  scale: 1
};
class Kf {
  constructor(t, e, i) {
    let n = 0, r = 0, o = 0;
    this.viewports = i.map(({ from: l, to: h }) => {
      let a = e.lineAt(l, z.ByPos, t, 0, 0).top, c = e.lineAt(h, z.ByPos, t, 0, 0).bottom;
      return n += c - a, { from: l, to: h, top: a, bottom: c, domTop: 0, domBottom: 0 };
    }), this.scale = (7e6 - n) / (e.height - n);
    for (let l of this.viewports)
      l.domTop = o + (l.top - r) * this.scale, o = l.domBottom = l.domTop + (l.bottom - l.top), r = l.bottom;
  }
  toDOM(t) {
    for (let e = 0, i = 0, n = 0; ; e++) {
      let r = e < this.viewports.length ? this.viewports[e] : null;
      if (!r || t < r.top)
        return n + (t - i) * this.scale;
      if (t <= r.bottom)
        return r.domTop + (t - r.top);
      i = r.bottom, n = r.domBottom;
    }
  }
  fromDOM(t) {
    for (let e = 0, i = 0, n = 0; ; e++) {
      let r = e < this.viewports.length ? this.viewports[e] : null;
      if (!r || t < r.domTop)
        return i + (t - n) / this.scale;
      if (t <= r.domBottom)
        return r.top + (t - r.domTop);
      i = r.bottom, n = r.domBottom;
    }
  }
}
function si(s, t) {
  if (t.scale == 1)
    return s;
  let e = t.toDOM(s.top), i = t.toDOM(s.bottom);
  return new ae(s.from, s.length, e, i - e, Array.isArray(s.type) ? s.type.map((n) => si(n, t)) : s.type);
}
const Pi = /* @__PURE__ */ v.define({ combine: (s) => s.join(" ") }), Ms = /* @__PURE__ */ v.define({ combine: (s) => s.indexOf(!0) > -1 }), Ds = /* @__PURE__ */ de.newName(), Ql = /* @__PURE__ */ de.newName(), Jl = /* @__PURE__ */ de.newName(), Xl = { "&light": "." + Ql, "&dark": "." + Jl };
function Ts(s, t, e) {
  return new de(t, {
    finish(i) {
      return /&/.test(i) ? i.replace(/&\w*/, (n) => {
        if (n == "&")
          return s;
        if (!e || !e[n])
          throw new RangeError(`Unsupported selector: ${n}`);
        return e[n];
      }) : s + " " + i;
    }
  });
}
const Uf = /* @__PURE__ */ Ts("." + Ds, {
  "&.cm-editor": {
    position: "relative !important",
    boxSizing: "border-box",
    "&.cm-focused": {
      outline: "1px dotted #212121"
    },
    display: "flex !important",
    flexDirection: "column"
  },
  ".cm-scroller": {
    display: "flex !important",
    alignItems: "flex-start !important",
    fontFamily: "monospace",
    lineHeight: 1.4,
    height: "100%",
    overflowX: "auto",
    position: "relative",
    zIndex: 0
  },
  ".cm-content": {
    margin: 0,
    flexGrow: 2,
    flexShrink: 0,
    minHeight: "100%",
    display: "block",
    whiteSpace: "pre",
    wordWrap: "normal",
    boxSizing: "border-box",
    padding: "4px 0",
    outline: "none",
    "&[contenteditable=true]": {
      WebkitUserModify: "read-write-plaintext-only"
    }
  },
  ".cm-lineWrapping": {
    whiteSpace_fallback: "pre-wrap",
    whiteSpace: "break-spaces",
    wordBreak: "break-word",
    overflowWrap: "anywhere",
    flexShrink: 1
  },
  "&light .cm-content": { caretColor: "black" },
  "&dark .cm-content": { caretColor: "white" },
  ".cm-line": {
    display: "block",
    padding: "0 2px 0 4px"
  },
  ".cm-selectionLayer": {
    zIndex: -1,
    contain: "size style"
  },
  ".cm-selectionBackground": {
    position: "absolute"
  },
  "&light .cm-selectionBackground": {
    background: "#d9d9d9"
  },
  "&dark .cm-selectionBackground": {
    background: "#222"
  },
  "&light.cm-focused .cm-selectionBackground": {
    background: "#d7d4f0"
  },
  "&dark.cm-focused .cm-selectionBackground": {
    background: "#233"
  },
  ".cm-cursorLayer": {
    zIndex: 100,
    contain: "size style",
    pointerEvents: "none"
  },
  "&.cm-focused .cm-cursorLayer": {
    animation: "steps(1) cm-blink 1.2s infinite"
  },
  "@keyframes cm-blink": { "0%": {}, "50%": { opacity: 0 }, "100%": {} },
  "@keyframes cm-blink2": { "0%": {}, "50%": { opacity: 0 }, "100%": {} },
  ".cm-cursor, .cm-dropCursor": {
    position: "absolute",
    borderLeft: "1.2px solid black",
    marginLeft: "-0.6px",
    pointerEvents: "none"
  },
  ".cm-cursor": {
    display: "none"
  },
  "&dark .cm-cursor": {
    borderLeftColor: "#444"
  },
  "&.cm-focused .cm-cursor": {
    display: "block"
  },
  "&light .cm-activeLine": { backgroundColor: "#cceeff44" },
  "&dark .cm-activeLine": { backgroundColor: "#99eeff33" },
  "&light .cm-specialChar": { color: "red" },
  "&dark .cm-specialChar": { color: "#f78" },
  ".cm-gutters": {
    flexShrink: 0,
    display: "flex",
    height: "100%",
    boxSizing: "border-box",
    left: 0,
    zIndex: 200
  },
  "&light .cm-gutters": {
    backgroundColor: "#f5f5f5",
    color: "#6c6c6c",
    borderRight: "1px solid #ddd"
  },
  "&dark .cm-gutters": {
    backgroundColor: "#333338",
    color: "#ccc"
  },
  ".cm-gutter": {
    display: "flex !important",
    flexDirection: "column",
    flexShrink: 0,
    boxSizing: "border-box",
    minHeight: "100%",
    overflow: "hidden"
  },
  ".cm-gutterElement": {
    boxSizing: "border-box"
  },
  ".cm-lineNumbers .cm-gutterElement": {
    padding: "0 3px 0 5px",
    minWidth: "20px",
    textAlign: "right",
    whiteSpace: "nowrap"
  },
  "&light .cm-activeLineGutter": {
    backgroundColor: "#e2f2ff"
  },
  "&dark .cm-activeLineGutter": {
    backgroundColor: "#222227"
  },
  ".cm-panels": {
    boxSizing: "border-box",
    position: "sticky",
    left: 0,
    right: 0
  },
  "&light .cm-panels": {
    backgroundColor: "#f5f5f5",
    color: "black"
  },
  "&light .cm-panels-top": {
    borderBottom: "1px solid #ddd"
  },
  "&light .cm-panels-bottom": {
    borderTop: "1px solid #ddd"
  },
  "&dark .cm-panels": {
    backgroundColor: "#333338",
    color: "white"
  },
  ".cm-tab": {
    display: "inline-block",
    overflow: "hidden",
    verticalAlign: "bottom"
  },
  ".cm-widgetBuffer": {
    verticalAlign: "text-top",
    height: "1em",
    width: 0,
    display: "inline"
  },
  ".cm-placeholder": {
    color: "#888",
    display: "inline-block",
    verticalAlign: "top"
  },
  ".cm-button": {
    verticalAlign: "middle",
    color: "inherit",
    fontSize: "70%",
    padding: ".2em 1em",
    borderRadius: "1px"
  },
  "&light .cm-button": {
    backgroundImage: "linear-gradient(#eff1f5, #d9d9df)",
    border: "1px solid #888",
    "&:active": {
      backgroundImage: "linear-gradient(#b4b4b4, #d0d3d6)"
    }
  },
  "&dark .cm-button": {
    backgroundImage: "linear-gradient(#393939, #111)",
    border: "1px solid #888",
    "&:active": {
      backgroundImage: "linear-gradient(#111, #333)"
    }
  },
  ".cm-textfield": {
    verticalAlign: "middle",
    color: "inherit",
    fontSize: "70%",
    border: "1px solid silver",
    padding: ".2em .5em"
  },
  "&light .cm-textfield": {
    backgroundColor: "white"
  },
  "&dark .cm-textfield": {
    border: "1px solid #555",
    backgroundColor: "inherit"
  }
}, Xl), Qf = {
  childList: !0,
  characterData: !0,
  subtree: !0,
  attributes: !0,
  characterDataOldValue: !0
}, zn = x.ie && x.ie_version <= 11;
class Jf {
  constructor(t, e, i) {
    this.view = t, this.onChange = e, this.onScrollChanged = i, this.active = !1, this.selectionRange = new Kc(), this.selectionChanged = !1, this.delayedFlush = -1, this.resizeTimeout = -1, this.queue = [], this.delayedAndroidKey = null, this.lastChange = 0, this.scrollTargets = [], this.intersection = null, this.resize = null, this.intersecting = !1, this.gapIntersection = null, this.gaps = [], this.parentCheck = -1, this.dom = t.contentDOM, this.observer = new MutationObserver((n) => {
      for (let r of n)
        this.queue.push(r);
      (x.ie && x.ie_version <= 11 || x.ios && t.composing) && n.some((r) => r.type == "childList" && r.removedNodes.length || r.type == "characterData" && r.oldValue.length > r.target.nodeValue.length) ? this.flushSoon() : this.flush();
    }), zn && (this.onCharData = (n) => {
      this.queue.push({
        target: n.target,
        type: "characterData",
        oldValue: n.prevValue
      }), this.flushSoon();
    }), this.onSelectionChange = this.onSelectionChange.bind(this), this.onResize = this.onResize.bind(this), this.onPrint = this.onPrint.bind(this), this.onScroll = this.onScroll.bind(this), typeof ResizeObserver == "function" && (this.resize = new ResizeObserver(() => {
      this.view.docView.lastUpdate < Date.now() - 75 && this.onResize();
    }), this.resize.observe(t.scrollDOM)), this.addWindowListeners(this.win = t.win), this.start(), typeof IntersectionObserver == "function" && (this.intersection = new IntersectionObserver((n) => {
      this.parentCheck < 0 && (this.parentCheck = setTimeout(this.listenForScroll.bind(this), 1e3)), n.length > 0 && n[n.length - 1].intersectionRatio > 0 != this.intersecting && (this.intersecting = !this.intersecting, this.intersecting != this.view.inView && this.onScrollChanged(document.createEvent("Event")));
    }, {}), this.intersection.observe(this.dom), this.gapIntersection = new IntersectionObserver((n) => {
      n.length > 0 && n[n.length - 1].intersectionRatio > 0 && this.onScrollChanged(document.createEvent("Event"));
    }, {})), this.listenForScroll(), this.readSelectionRange();
  }
  onScroll(t) {
    this.intersecting && this.flush(!1), this.onScrollChanged(t);
  }
  onResize() {
    this.resizeTimeout < 0 && (this.resizeTimeout = setTimeout(() => {
      this.resizeTimeout = -1, this.view.requestMeasure();
    }, 50));
  }
  onPrint() {
    this.view.viewState.printing = !0, this.view.measure(), setTimeout(() => {
      this.view.viewState.printing = !1, this.view.requestMeasure();
    }, 500);
  }
  updateGaps(t) {
    if (this.gapIntersection && (t.length != this.gaps.length || this.gaps.some((e, i) => e != t[i]))) {
      this.gapIntersection.disconnect();
      for (let e of t)
        this.gapIntersection.observe(e);
      this.gaps = t;
    }
  }
  onSelectionChange(t) {
    let e = this.selectionChanged;
    if (!this.readSelectionRange() || this.delayedAndroidKey)
      return;
    let { view: i } = this, n = this.selectionRange;
    if (i.state.facet(On) ? i.root.activeElement != this.dom : !zi(i.dom, n))
      return;
    let r = n.anchorNode && i.docView.nearest(n.anchorNode);
    if (r && r.ignoreEvent(t)) {
      e || (this.selectionChanged = !1);
      return;
    }
    (x.ie && x.ie_version <= 11 || x.android && x.chrome) && !i.state.selection.main.empty && n.focusNode && tn(n.focusNode, n.focusOffset, n.anchorNode, n.anchorOffset) ? this.flushSoon() : this.flush(!1);
  }
  readSelectionRange() {
    let { view: t } = this, e = x.safari && t.root.nodeType == 11 && jc(this.dom.ownerDocument) == this.dom && Xf(this.view) || Zi(t.root);
    if (!e || this.selectionRange.eq(e))
      return !1;
    let i = zi(this.dom, e);
    return i && !this.selectionChanged && t.inputState.lastFocusTime > Date.now() - 200 && t.inputState.lastTouchTime < Date.now() - 300 && Qc(this.dom, e) ? (this.view.inputState.lastFocusTime = 0, t.docView.updateSelection(), !1) : (this.selectionRange.setRange(e), i && (this.selectionChanged = !0), !0);
  }
  setSelectionRange(t, e) {
    this.selectionRange.set(t.node, t.offset, e.node, e.offset), this.selectionChanged = !1;
  }
  clearSelectionRange() {
    this.selectionRange.set(null, 0, null, 0);
  }
  listenForScroll() {
    this.parentCheck = -1;
    let t = 0, e = null;
    for (let i = this.dom; i; )
      if (i.nodeType == 1)
        !e && t < this.scrollTargets.length && this.scrollTargets[t] == i ? t++ : e || (e = this.scrollTargets.slice(0, t)), e && e.push(i), i = i.assignedSlot || i.parentNode;
      else if (i.nodeType == 11)
        i = i.host;
      else
        break;
    if (t < this.scrollTargets.length && !e && (e = this.scrollTargets.slice(0, t)), e) {
      for (let i of this.scrollTargets)
        i.removeEventListener("scroll", this.onScroll);
      for (let i of this.scrollTargets = e)
        i.addEventListener("scroll", this.onScroll);
    }
  }
  ignore(t) {
    if (!this.active)
      return t();
    try {
      return this.stop(), t();
    } finally {
      this.start(), this.clear();
    }
  }
  start() {
    this.active || (this.observer.observe(this.dom, Qf), zn && this.dom.addEventListener("DOMCharacterDataModified", this.onCharData), this.active = !0);
  }
  stop() {
    !this.active || (this.active = !1, this.observer.disconnect(), zn && this.dom.removeEventListener("DOMCharacterDataModified", this.onCharData));
  }
  clear() {
    this.processRecords(), this.queue.length = 0, this.selectionChanged = !1;
  }
  delayAndroidKey(t, e) {
    var i;
    this.delayedAndroidKey || this.view.win.requestAnimationFrame(() => {
      let n = this.delayedAndroidKey;
      this.delayedAndroidKey = null, this.delayedFlush = -1, !this.flush() && n.force && hi(this.dom, n.key, n.keyCode);
    }), (!this.delayedAndroidKey || t == "Enter") && (this.delayedAndroidKey = {
      key: t,
      keyCode: e,
      force: this.lastChange < Date.now() - 50 || !!(!((i = this.delayedAndroidKey) === null || i === void 0) && i.force)
    });
  }
  flushSoon() {
    this.delayedFlush < 0 && (this.delayedFlush = this.view.win.requestAnimationFrame(() => {
      this.delayedFlush = -1, this.flush();
    }));
  }
  forceFlush() {
    this.delayedFlush >= 0 && (this.view.win.cancelAnimationFrame(this.delayedFlush), this.delayedFlush = -1), this.flush();
  }
  processRecords() {
    let t = this.queue;
    for (let r of this.observer.takeRecords())
      t.push(r);
    t.length && (this.queue = []);
    let e = -1, i = -1, n = !1;
    for (let r of t) {
      let o = this.readMutation(r);
      !o || (o.typeOver && (n = !0), e == -1 ? { from: e, to: i } = o : (e = Math.min(o.from, e), i = Math.max(o.to, i)));
    }
    return { from: e, to: i, typeOver: n };
  }
  flush(t = !0) {
    if (this.delayedFlush >= 0 || this.delayedAndroidKey)
      return !1;
    t && this.readSelectionRange();
    let { from: e, to: i, typeOver: n } = this.processRecords(), r = this.selectionChanged && zi(this.dom, this.selectionRange);
    if (e < 0 && !r)
      return !1;
    e > -1 && (this.lastChange = Date.now()), this.view.inputState.lastFocusTime = 0, this.selectionChanged = !1;
    let o = this.view.state, l = this.onChange(e, i, n);
    return this.view.state == o && this.view.update([]), l;
  }
  readMutation(t) {
    let e = this.view.docView.nearest(t.target);
    if (!e || e.ignoreMutation(t))
      return null;
    if (e.markDirty(t.type == "attributes"), t.type == "attributes" && (e.dirty |= 4), t.type == "childList") {
      let i = Jr(e, t.previousSibling || t.target.previousSibling, -1), n = Jr(e, t.nextSibling || t.target.nextSibling, 1);
      return {
        from: i ? e.posAfter(i) : e.posAtStart,
        to: n ? e.posBefore(n) : e.posAtEnd,
        typeOver: !1
      };
    } else
      return t.type == "characterData" ? { from: e.posAtStart, to: e.posAtEnd, typeOver: t.target.nodeValue == t.oldValue } : null;
  }
  setWindow(t) {
    t != this.win && (this.removeWindowListeners(this.win), this.win = t, this.addWindowListeners(this.win));
  }
  addWindowListeners(t) {
    t.addEventListener("resize", this.onResize), t.addEventListener("beforeprint", this.onPrint), t.addEventListener("scroll", this.onScroll), t.document.addEventListener("selectionchange", this.onSelectionChange);
  }
  removeWindowListeners(t) {
    t.removeEventListener("scroll", this.onScroll), t.removeEventListener("resize", this.onResize), t.removeEventListener("beforeprint", this.onPrint), t.document.removeEventListener("selectionchange", this.onSelectionChange);
  }
  destroy() {
    var t, e, i;
    this.stop(), (t = this.intersection) === null || t === void 0 || t.disconnect(), (e = this.gapIntersection) === null || e === void 0 || e.disconnect(), (i = this.resize) === null || i === void 0 || i.disconnect();
    for (let n of this.scrollTargets)
      n.removeEventListener("scroll", this.onScroll);
    this.removeWindowListeners(this.win), clearTimeout(this.parentCheck), clearTimeout(this.resizeTimeout);
  }
}
function Jr(s, t, e) {
  for (; t; ) {
    let i = W.get(t);
    if (i && i.parent == s)
      return i;
    let n = t.parentNode;
    t = n != s.dom ? n : e > 0 ? t.nextSibling : t.previousSibling;
  }
  return null;
}
function Xf(s) {
  let t = null;
  function e(h) {
    h.preventDefault(), h.stopImmediatePropagation(), t = h.getTargetRanges()[0];
  }
  if (s.contentDOM.addEventListener("beforeinput", e, !0), s.dom.ownerDocument.execCommand("indent"), s.contentDOM.removeEventListener("beforeinput", e, !0), !t)
    return null;
  let i = t.startContainer, n = t.startOffset, r = t.endContainer, o = t.endOffset, l = s.docView.domAtPos(s.state.selection.main.anchor);
  return tn(l.node, l.offset, r, o) && ([i, n, r, o] = [r, o, i, n]), { anchorNode: i, anchorOffset: n, focusNode: r, focusOffset: o };
}
function Yf(s, t, e, i) {
  let n, r, o = s.state.selection.main;
  if (t > -1) {
    let l = s.docView.domBoundsAround(t, e, 0);
    if (!l || s.state.readOnly)
      return !1;
    let { from: h, to: a } = l, c = s.docView.impreciseHead || s.docView.impreciseAnchor ? [] : tu(s), f = new Il(c, s.state);
    f.readRange(l.startDOM, l.endDOM);
    let u = o.from, d = null;
    (s.inputState.lastKeyCode === 8 && s.inputState.lastKeyTime > Date.now() - 100 || x.android && f.text.length < a - h) && (u = o.to, d = "end");
    let p = Zf(s.state.doc.sliceString(h, a, he), f.text, u - h, d);
    p && (x.chrome && s.inputState.lastKeyCode == 13 && p.toB == p.from + 2 && f.text.slice(p.from, p.toB) == he + he && p.toB--, n = {
      from: h + p.from,
      to: h + p.toA,
      insert: I.of(f.text.slice(p.from, p.toB).split(he))
    }), r = eu(c, h);
  } else if (s.hasFocus || !s.state.facet(On)) {
    let l = s.observer.selectionRange, { impreciseHead: h, impreciseAnchor: a } = s.docView, c = h && h.node == l.focusNode && h.offset == l.focusOffset || !We(s.contentDOM, l.focusNode) ? s.state.selection.main.head : s.docView.posFromDOM(l.focusNode, l.focusOffset), f = a && a.node == l.anchorNode && a.offset == l.anchorOffset || !We(s.contentDOM, l.anchorNode) ? s.state.selection.main.anchor : s.docView.posFromDOM(l.anchorNode, l.anchorOffset);
    (c != o.head || f != o.anchor) && (r = k.single(f, c));
  }
  if (!n && !r)
    return !1;
  if (!n && i && !o.empty && r && r.main.empty ? n = { from: o.from, to: o.to, insert: s.state.doc.slice(o.from, o.to) } : n && n.from >= o.from && n.to <= o.to && (n.from != o.from || n.to != o.to) && o.to - o.from - (n.to - n.from) <= 4 ? n = {
    from: o.from,
    to: o.to,
    insert: s.state.doc.slice(o.from, n.from).append(n.insert).append(s.state.doc.slice(n.to, o.to))
  } : (x.mac || x.android) && n && n.from == n.to && n.from == o.head - 1 && /^\. ?$/.test(n.insert.toString()) && (r && n.insert.length == 2 && (r = k.single(r.main.anchor - 1, r.main.head - 1)), n = { from: o.from, to: o.to, insert: I.of([" "]) }), n) {
    let l = s.state;
    if (x.ios && s.inputState.flushIOSKey(s) || x.android && (n.from == o.from && n.to == o.to && n.insert.length == 1 && n.insert.lines == 2 && hi(s.contentDOM, "Enter", 13) || n.from == o.from - 1 && n.to == o.to && n.insert.length == 0 && hi(s.contentDOM, "Backspace", 8) || n.from == o.from && n.to == o.to + 1 && n.insert.length == 0 && hi(s.contentDOM, "Delete", 46)))
      return !0;
    let h = n.insert.toString();
    if (s.state.facet(Dl).some((f) => f(s, n.from, n.to, h)))
      return !0;
    s.inputState.composing >= 0 && s.inputState.composing++;
    let a;
    if (n.from >= o.from && n.to <= o.to && n.to - n.from >= (o.to - o.from) / 3 && (!r || r.main.empty && r.main.from == n.from + n.insert.length) && s.inputState.composing < 0) {
      let f = o.from < n.from ? l.sliceDoc(o.from, n.from) : "", u = o.to > n.to ? l.sliceDoc(n.to, o.to) : "";
      a = l.replaceSelection(s.state.toText(f + n.insert.sliceString(0, void 0, s.state.lineBreak) + u));
    } else {
      let f = l.changes(n), u = r && !l.selection.main.eq(r.main) && r.main.to <= f.newLength ? r.main : void 0;
      if (l.selection.ranges.length > 1 && s.inputState.composing >= 0 && n.to <= o.to && n.to >= o.to - 10) {
        let d = s.state.sliceDoc(n.from, n.to), p = Hl(s) || s.state.doc.lineAt(o.head), w = o.to - n.to, g = o.to - o.from;
        a = l.changeByRange((y) => {
          if (y.from == o.from && y.to == o.to)
            return { changes: f, range: u || y.map(f) };
          let O = y.to - w, T = O - d.length;
          if (y.to - y.from != g || s.state.sliceDoc(T, O) != d || p && y.to >= p.from && y.from <= p.to)
            return { range: y };
          let C = l.changes({ from: T, to: O, insert: n.insert }), L = y.to - o.to;
          return {
            changes: C,
            range: u ? k.range(Math.max(0, u.anchor + L), Math.max(0, u.head + L)) : y.map(C)
          };
        });
      } else
        a = {
          changes: f,
          selection: u && l.selection.replaceRange(u)
        };
    }
    let c = "input.type";
    return s.composing && (c += ".compose", s.inputState.compositionFirstChange && (c += ".start", s.inputState.compositionFirstChange = !1)), s.dispatch(a, { scrollIntoView: !0, userEvent: c }), !0;
  } else if (r && !r.main.eq(o)) {
    let l = !1, h = "select";
    return s.inputState.lastSelectionTime > Date.now() - 50 && (s.inputState.lastSelectionOrigin == "select" && (l = !0), h = s.inputState.lastSelectionOrigin), s.dispatch({ selection: r, scrollIntoView: l, userEvent: h }), !0;
  } else
    return !1;
}
function Zf(s, t, e, i) {
  let n = Math.min(s.length, t.length), r = 0;
  for (; r < n && s.charCodeAt(r) == t.charCodeAt(r); )
    r++;
  if (r == n && s.length == t.length)
    return null;
  let o = s.length, l = t.length;
  for (; o > 0 && l > 0 && s.charCodeAt(o - 1) == t.charCodeAt(l - 1); )
    o--, l--;
  if (i == "end") {
    let h = Math.max(0, r - Math.min(o, l));
    e -= o + h - r;
  }
  return o < r && s.length < t.length ? (r -= e <= r && e >= o ? r - e : 0, l = r + (l - o), o = r) : l < r && (r -= e <= r && e >= l ? r - e : 0, o = r + (o - l), l = r), { from: r, toA: o, toB: l };
}
function tu(s) {
  let t = [];
  if (s.root.activeElement != s.contentDOM)
    return t;
  let { anchorNode: e, anchorOffset: i, focusNode: n, focusOffset: r } = s.observer.selectionRange;
  return e && (t.push(new Tr(e, i)), (n != e || r != i) && t.push(new Tr(n, r))), t;
}
function eu(s, t) {
  if (s.length == 0)
    return null;
  let e = s[0].pos, i = s.length == 2 ? s[1].pos : e;
  return e > -1 && i > -1 ? k.single(e + t, i + t) : null;
}
class A {
  constructor(t = {}) {
    this.plugins = [], this.pluginMap = /* @__PURE__ */ new Map(), this.editorAttrs = {}, this.contentAttrs = {}, this.bidiCache = [], this.destroyed = !1, this.updateState = 2, this.measureScheduled = -1, this.measureRequests = [], this.contentDOM = document.createElement("div"), this.scrollDOM = document.createElement("div"), this.scrollDOM.tabIndex = -1, this.scrollDOM.className = "cm-scroller", this.scrollDOM.appendChild(this.contentDOM), this.announceDOM = document.createElement("div"), this.announceDOM.style.cssText = "position: absolute; top: -10000px", this.announceDOM.setAttribute("aria-live", "polite"), this.dom = document.createElement("div"), this.dom.appendChild(this.announceDOM), this.dom.appendChild(this.scrollDOM), this._dispatch = t.dispatch || ((e) => this.update([e])), this.dispatch = this.dispatch.bind(this), this._root = t.root || Uc(t.parent) || document, this.viewState = new Kr(t.state || E.create(t)), this.plugins = this.state.facet(ii).map((e) => new In(e));
    for (let e of this.plugins)
      e.update(this);
    this.observer = new Jf(this, (e, i, n) => Yf(this, e, i, n), (e) => {
      this.inputState.runScrollHandlers(this, e), this.observer.intersecting && this.measure();
    }), this.inputState = new Sf(this), this.inputState.ensureHandlers(this, this.plugins), this.docView = new Pr(this), this.mountStyles(), this.updateAttrs(), this.updateState = 0, this.requestMeasure(), t.parent && t.parent.appendChild(this.dom);
  }
  get state() {
    return this.viewState.state;
  }
  get viewport() {
    return this.viewState.viewport;
  }
  get visibleRanges() {
    return this.viewState.visibleRanges;
  }
  get inView() {
    return this.viewState.inView;
  }
  get composing() {
    return this.inputState.composing > 0;
  }
  get compositionStarted() {
    return this.inputState.composing >= 0;
  }
  get root() {
    return this._root;
  }
  get win() {
    return this.dom.ownerDocument.defaultView || window;
  }
  dispatch(...t) {
    this._dispatch(t.length == 1 && t[0] instanceof lt ? t[0] : this.state.update(...t));
  }
  update(t) {
    if (this.updateState != 0)
      throw new Error("Calls to EditorView.update are not allowed while an update is in progress");
    let e = !1, i = !1, n, r = this.state;
    for (let l of t) {
      if (l.startState != r)
        throw new RangeError("Trying to update state with a transaction that doesn't start from the previous state.");
      r = l.state;
    }
    if (this.destroyed) {
      this.viewState.state = r;
      return;
    }
    if (this.observer.clear(), r.facet(E.phrases) != this.state.facet(E.phrases))
      return this.setState(r);
    n = sn.create(this, r, t);
    let o = this.viewState.scrollTarget;
    try {
      this.updateState = 2;
      for (let l of t) {
        if (o && (o = o.map(l.changes)), l.scrollIntoView) {
          let { main: h } = l.state.selection;
          o = new nn(h.empty ? h : k.cursor(h.head, h.head > h.anchor ? -1 : 1));
        }
        for (let h of l.effects)
          h.is(Mr) && (o = h.value);
      }
      this.viewState.update(n, o), this.bidiCache = rn.update(this.bidiCache, n.changes), n.empty || (this.updatePlugins(n), this.inputState.update(n)), e = this.docView.update(n), this.state.facet(ni) != this.styleModules && this.mountStyles(), i = this.updateAttrs(), this.showAnnouncements(t), this.docView.updateSelection(e, t.some((l) => l.isUserEvent("select.pointer")));
    } finally {
      this.updateState = 0;
    }
    if (n.startState.facet(Pi) != n.state.facet(Pi) && (this.viewState.mustMeasureContent = !0), (e || i || o || this.viewState.mustEnforceCursorAssoc || this.viewState.mustMeasureContent) && this.requestMeasure(), !n.empty)
      for (let l of this.state.facet(xs))
        l(n);
  }
  setState(t) {
    if (this.updateState != 0)
      throw new Error("Calls to EditorView.setState are not allowed while an update is in progress");
    if (this.destroyed) {
      this.viewState.state = t;
      return;
    }
    this.updateState = 2;
    let e = this.hasFocus;
    try {
      for (let i of this.plugins)
        i.destroy(this);
      this.viewState = new Kr(t), this.plugins = t.facet(ii).map((i) => new In(i)), this.pluginMap.clear();
      for (let i of this.plugins)
        i.update(this);
      this.docView = new Pr(this), this.inputState.ensureHandlers(this, this.plugins), this.mountStyles(), this.updateAttrs(), this.bidiCache = [];
    } finally {
      this.updateState = 0;
    }
    e && this.focus(), this.requestMeasure();
  }
  updatePlugins(t) {
    let e = t.startState.facet(ii), i = t.state.facet(ii);
    if (e != i) {
      let n = [];
      for (let r of i) {
        let o = e.indexOf(r);
        if (o < 0)
          n.push(new In(r));
        else {
          let l = this.plugins[o];
          l.mustUpdate = t, n.push(l);
        }
      }
      for (let r of this.plugins)
        r.mustUpdate != t && r.destroy(this);
      this.plugins = n, this.pluginMap.clear(), this.inputState.ensureHandlers(this, this.plugins);
    } else
      for (let n of this.plugins)
        n.mustUpdate = t;
    for (let n = 0; n < this.plugins.length; n++)
      this.plugins[n].update(this);
  }
  measure(t = !0) {
    if (this.destroyed)
      return;
    this.measureScheduled > -1 && cancelAnimationFrame(this.measureScheduled), this.measureScheduled = 0, t && this.observer.forceFlush();
    let e = null, { scrollHeight: i, scrollTop: n, clientHeight: r } = this.scrollDOM, o = n > i - r - 4 ? i : n;
    try {
      for (let l = 0; ; l++) {
        this.updateState = 1;
        let h = this.viewport, a = this.viewState.lineBlockAtHeight(o), c = this.viewState.measure(this);
        if (!c && !this.measureRequests.length && this.viewState.scrollTarget == null)
          break;
        if (l > 5) {
          console.warn(this.measureRequests.length ? "Measure loop restarted more than 5 times" : "Viewport failed to stabilize");
          break;
        }
        let f = [];
        c & 4 || ([this.measureRequests, f] = [f, this.measureRequests]);
        let u = f.map((g) => {
          try {
            return g.read(this);
          } catch (y) {
            return zt(this.state, y), Xr;
          }
        }), d = sn.create(this, this.state, []), p = !1, w = !1;
        d.flags |= c, e ? e.flags |= c : e = d, this.updateState = 2, d.empty || (this.updatePlugins(d), this.inputState.update(d), this.updateAttrs(), p = this.docView.update(d));
        for (let g = 0; g < f.length; g++)
          if (u[g] != Xr)
            try {
              let y = f[g];
              y.write && y.write(u[g], this);
            } catch (y) {
              zt(this.state, y);
            }
        if (this.viewState.scrollTarget)
          this.docView.scrollIntoView(this.viewState.scrollTarget), this.viewState.scrollTarget = null, w = !0;
        else {
          let g = this.viewState.lineBlockAt(a.from).top - a.top;
          (g > 1 || g < -1) && (this.scrollDOM.scrollTop += g, w = !0);
        }
        if (p && this.docView.updateSelection(!0), this.viewport.from == h.from && this.viewport.to == h.to && !w && this.measureRequests.length == 0)
          break;
      }
    } finally {
      this.updateState = 0, this.measureScheduled = -1;
    }
    if (e && !e.empty)
      for (let l of this.state.facet(xs))
        l(e);
  }
  get themeClasses() {
    return Ds + " " + (this.state.facet(Ms) ? Jl : Ql) + " " + this.state.facet(Pi);
  }
  updateAttrs() {
    let t = Yr(this, Pl, {
      class: "cm-editor" + (this.hasFocus ? " cm-focused " : " ") + this.themeClasses
    }), e = {
      spellcheck: "false",
      autocorrect: "off",
      autocapitalize: "off",
      translate: "no",
      contenteditable: this.state.facet(On) ? "true" : "false",
      class: "cm-content",
      style: `${x.tabSize}: ${this.state.tabSize}`,
      role: "textbox",
      "aria-multiline": "true"
    };
    this.state.readOnly && (e["aria-readonly"] = "true"), Yr(this, Bl, e);
    let i = this.observer.ignore(() => {
      let n = bs(this.contentDOM, this.contentAttrs, e), r = bs(this.dom, this.editorAttrs, t);
      return n || r;
    });
    return this.editorAttrs = t, this.contentAttrs = e, i;
  }
  showAnnouncements(t) {
    let e = !0;
    for (let i of t)
      for (let n of i.effects)
        if (n.is(A.announce)) {
          e && (this.announceDOM.textContent = ""), e = !1;
          let r = this.announceDOM.appendChild(document.createElement("div"));
          r.textContent = n.value;
        }
  }
  mountStyles() {
    this.styleModules = this.state.facet(ni), de.mount(this.root, this.styleModules.concat(Uf).reverse());
  }
  readMeasured() {
    if (this.updateState == 2)
      throw new Error("Reading the editor layout isn't allowed during an update");
    this.updateState == 0 && this.measureScheduled > -1 && this.measure(!1);
  }
  requestMeasure(t) {
    if (this.measureScheduled < 0 && (this.measureScheduled = this.win.requestAnimationFrame(() => this.measure())), t) {
      if (t.key != null) {
        for (let e = 0; e < this.measureRequests.length; e++)
          if (this.measureRequests[e].key === t.key) {
            this.measureRequests[e] = t;
            return;
          }
      }
      this.measureRequests.push(t);
    }
  }
  plugin(t) {
    let e = this.pluginMap.get(t);
    return (e === void 0 || e && e.spec != t) && this.pluginMap.set(t, e = this.plugins.find((i) => i.spec == t) || null), e && e.update(this).value;
  }
  get documentTop() {
    return this.contentDOM.getBoundingClientRect().top + this.viewState.paddingTop;
  }
  get documentPadding() {
    return { top: this.viewState.paddingTop, bottom: this.viewState.paddingBottom };
  }
  elementAtHeight(t) {
    return this.readMeasured(), this.viewState.elementAtHeight(t);
  }
  lineBlockAtHeight(t) {
    return this.readMeasured(), this.viewState.lineBlockAtHeight(t);
  }
  get viewportLineBlocks() {
    return this.viewState.viewportLines;
  }
  lineBlockAt(t) {
    return this.viewState.lineBlockAt(t);
  }
  get contentHeight() {
    return this.viewState.contentHeight;
  }
  moveByChar(t, e, i) {
    return $n(this, t, Vr(this, t, e, i));
  }
  moveByGroup(t, e) {
    return $n(this, t, Vr(this, t, e, (i) => xf(this, t.head, i)));
  }
  moveToLineBoundary(t, e, i = !0) {
    return kf(this, t, e, i);
  }
  moveVertically(t, e, i) {
    return $n(this, t, vf(this, t, e, i));
  }
  domAtPos(t) {
    return this.docView.domAtPos(t);
  }
  posAtDOM(t, e = 0) {
    return this.docView.posFromDOM(t, e);
  }
  posAtCoords(t, e = !0) {
    return this.readMeasured(), Fl(this, t, e);
  }
  coordsAtPos(t, e = 1) {
    this.readMeasured();
    let i = this.docView.coordsAt(t, e);
    if (!i || i.left == i.right)
      return i;
    let n = this.state.doc.lineAt(t), r = this.bidiSpans(n), o = r[$e.find(r, t - n.from, -1, e)];
    return Sn(i, o.dir == X.LTR == e > 0);
  }
  get defaultCharacterWidth() {
    return this.viewState.heightOracle.charWidth;
  }
  get defaultLineHeight() {
    return this.viewState.heightOracle.lineHeight;
  }
  get textDirection() {
    return this.viewState.defaultTextDirection;
  }
  textDirectionAt(t) {
    return !this.state.facet(Tl) || t < this.viewport.from || t > this.viewport.to ? this.textDirection : (this.readMeasured(), this.docView.textDirectionAt(t));
  }
  get lineWrapping() {
    return this.viewState.heightOracle.lineWrapping;
  }
  bidiSpans(t) {
    if (t.length > iu)
      return Nl(t.length);
    let e = this.textDirectionAt(t.from);
    for (let n of this.bidiCache)
      if (n.from == t.from && n.dir == e)
        return n.order;
    let i = of(t.text, e);
    return this.bidiCache.push(new rn(t.from, t.to, e, i)), i;
  }
  get hasFocus() {
    var t;
    return (this.dom.ownerDocument.hasFocus() || x.safari && ((t = this.inputState) === null || t === void 0 ? void 0 : t.lastContextMenu) > Date.now() - 3e4) && this.root.activeElement == this.contentDOM;
  }
  focus() {
    this.observer.ignore(() => {
      fl(this.contentDOM), this.docView.updateSelection();
    });
  }
  setRoot(t) {
    this._root != t && (this._root = t, this.observer.setWindow((t.nodeType == 9 ? t : t.ownerDocument).defaultView || window), this.mountStyles());
  }
  destroy() {
    for (let t of this.plugins)
      t.destroy(this);
    this.plugins = [], this.inputState.destroy(), this.dom.remove(), this.observer.destroy(), this.measureScheduled > -1 && cancelAnimationFrame(this.measureScheduled), this.destroyed = !0;
  }
  static scrollIntoView(t, e = {}) {
    return Mr.of(new nn(typeof t == "number" ? k.cursor(t) : t, e.y, e.x, e.yMargin, e.xMargin));
  }
  static domEventHandlers(t) {
    return wt.define(() => ({}), { eventHandlers: t });
  }
  static theme(t, e) {
    let i = de.newName(), n = [Pi.of(i), ni.of(Ts(`.${i}`, t))];
    return e && e.dark && n.push(Ms.of(!0)), n;
  }
  static baseTheme(t) {
    return _s.lowest(ni.of(Ts("." + Ds, t, Xl)));
  }
  static findFromDOM(t) {
    var e;
    let i = t.querySelector(".cm-content"), n = i && W.get(i) || W.get(t);
    return ((e = n == null ? void 0 : n.rootView) === null || e === void 0 ? void 0 : e.view) || null;
  }
}
A.styleModule = ni;
A.inputHandler = Dl;
A.perLineTextDirection = Tl;
A.exceptionSink = Ml;
A.updateListener = xs;
A.editable = On;
A.mouseSelectionStyle = Ol;
A.dragMovesSelection = Al;
A.clickAddsSelectionRange = Cl;
A.decorations = gi;
A.atomicRanges = Rl;
A.scrollMargins = Ll;
A.darkTheme = Ms;
A.contentAttributes = Bl;
A.editorAttributes = Pl;
A.lineWrapping = /* @__PURE__ */ A.contentAttributes.of({ class: "cm-lineWrapping" });
A.announce = /* @__PURE__ */ F.define();
const iu = 4096, Xr = {};
class rn {
  constructor(t, e, i, n) {
    this.from = t, this.to = e, this.dir = i, this.order = n;
  }
  static update(t, e) {
    if (e.empty)
      return t;
    let i = [], n = t.length ? t[t.length - 1].dir : X.LTR;
    for (let r = Math.max(0, t.length - 10); r < t.length; r++) {
      let o = t[r];
      o.dir == n && !e.touchesRange(o.from, o.to) && i.push(new rn(e.mapPos(o.from, 1), e.mapPos(o.to, -1), o.dir, o.order));
    }
    return i;
  }
}
function Yr(s, t, e) {
  for (let i = s.state.facet(t), n = i.length - 1; n >= 0; n--) {
    let r = i[n], o = typeof r == "function" ? r(s) : r;
    o && ys(o, e);
  }
  return e;
}
const nu = x.mac ? "mac" : x.windows ? "win" : x.linux ? "linux" : "key";
function su(s, t) {
  const e = s.split(/-(?!$)/);
  let i = e[e.length - 1];
  i == "Space" && (i = " ");
  let n, r, o, l;
  for (let h = 0; h < e.length - 1; ++h) {
    const a = e[h];
    if (/^(cmd|meta|m)$/i.test(a))
      l = !0;
    else if (/^a(lt)?$/i.test(a))
      n = !0;
    else if (/^(c|ctrl|control)$/i.test(a))
      r = !0;
    else if (/^s(hift)?$/i.test(a))
      o = !0;
    else if (/^mod$/i.test(a))
      t == "mac" ? l = !0 : r = !0;
    else
      throw new Error("Unrecognized modifier name: " + a);
  }
  return n && (i = "Alt-" + i), r && (i = "Ctrl-" + i), l && (i = "Meta-" + i), o && (i = "Shift-" + i), i;
}
function Bi(s, t, e) {
  return t.altKey && (s = "Alt-" + s), t.ctrlKey && (s = "Ctrl-" + s), t.metaKey && (s = "Meta-" + s), e !== !1 && t.shiftKey && (s = "Shift-" + s), s;
}
const ru = /* @__PURE__ */ _s.default(/* @__PURE__ */ A.domEventHandlers({
  keydown(s, t) {
    return au(ou(t.state), s, t, "editor");
  }
})), Yl = /* @__PURE__ */ v.define({ enables: ru }), Zr = /* @__PURE__ */ new WeakMap();
function ou(s) {
  let t = s.facet(Yl), e = Zr.get(t);
  return e || Zr.set(t, e = hu(t.reduce((i, n) => i.concat(n), []))), e;
}
let re = null;
const lu = 4e3;
function hu(s, t = nu) {
  let e = /* @__PURE__ */ Object.create(null), i = /* @__PURE__ */ Object.create(null), n = (o, l) => {
    let h = i[o];
    if (h == null)
      i[o] = l;
    else if (h != l)
      throw new Error("Key binding " + o + " is used both as a regular binding and as a multi-stroke prefix");
  }, r = (o, l, h, a) => {
    var c, f;
    let u = e[o] || (e[o] = /* @__PURE__ */ Object.create(null)), d = l.split(/ (?!$)/).map((g) => su(g, t));
    for (let g = 1; g < d.length; g++) {
      let y = d.slice(0, g).join(" ");
      n(y, !0), u[y] || (u[y] = {
        preventDefault: !0,
        run: [(O) => {
          let T = re = { view: O, prefix: y, scope: o };
          return setTimeout(() => {
            re == T && (re = null);
          }, lu), !0;
        }]
      });
    }
    let p = d.join(" ");
    n(p, !1);
    let w = u[p] || (u[p] = { preventDefault: !1, run: ((f = (c = u._any) === null || c === void 0 ? void 0 : c.run) === null || f === void 0 ? void 0 : f.slice()) || [] });
    h && w.run.push(h), a && (w.preventDefault = !0);
  };
  for (let o of s) {
    let l = o.scope ? o.scope.split(" ") : ["editor"];
    if (o.any)
      for (let a of l) {
        let c = e[a] || (e[a] = /* @__PURE__ */ Object.create(null));
        c._any || (c._any = { preventDefault: !1, run: [] });
        for (let f in c)
          c[f].run.push(o.any);
      }
    let h = o[t] || o.key;
    if (!!h)
      for (let a of l)
        r(a, h, o.run, o.preventDefault), o.shift && r(a, "Shift-" + h, o.shift, o.preventDefault);
  }
  return e;
}
function au(s, t, e, i) {
  let n = Wc(t), r = oi(n, 0), o = es(r) == n.length && n != " ", l = "", h = !1;
  re && re.view == e && re.scope == i && (l = re.prefix + " ", (h = _l.indexOf(t.keyCode) < 0) && (re = null));
  let a = /* @__PURE__ */ new Set(), c = (p) => {
    if (p) {
      for (let w of p.run)
        if (!a.has(w) && (a.add(w), w(e, t)))
          return !0;
      p.preventDefault && (h = !0);
    }
    return !1;
  }, f = s[i], u, d;
  if (f) {
    if (c(f[l + Bi(n, t, !o)]))
      return !0;
    if (o && (t.shiftKey || t.altKey || t.metaKey || r > 127) && (u = pe[t.keyCode]) && u != n) {
      if (c(f[l + Bi(u, t, !0)]))
        return !0;
      if (t.shiftKey && (d = ui[t.keyCode]) != n && d != u && c(f[l + Bi(d, t, !1)]))
        return !0;
    } else if (o && t.shiftKey && c(f[l + Bi(n, t, !0)]))
      return !0;
    if (c(f._any))
      return !0;
  }
  return h;
}
const cu = !x.ios, fu = {
  ".cm-line": {
    "& ::selection": { backgroundColor: "transparent !important" },
    "&::selection": { backgroundColor: "transparent !important" }
  }
};
cu && (fu[".cm-line"].caretColor = "transparent !important");
function to(s, t, e, i, n) {
  t.lastIndex = 0;
  for (let r = s.iterRange(e, i), o = e, l; !r.next().done; o += r.value.length)
    if (!r.lineBreak)
      for (; l = t.exec(r.value); )
        n(o + l.index, l);
}
function uu(s, t) {
  let e = s.visibleRanges;
  if (e.length == 1 && e[0].from == s.viewport.from && e[0].to == s.viewport.to)
    return e;
  let i = [];
  for (let { from: n, to: r } of e)
    n = Math.max(s.state.doc.lineAt(n).from, n - t), r = Math.min(s.state.doc.lineAt(r).to, r + t), i.length && i[i.length - 1].to >= n ? i[i.length - 1].to = r : i.push({ from: n, to: r });
  return i;
}
class du {
  constructor(t) {
    const { regexp: e, decoration: i, decorate: n, boundary: r, maxLength: o = 1e3 } = t;
    if (!e.global)
      throw new RangeError("The regular expression given to MatchDecorator should have its 'g' flag set");
    if (this.regexp = e, n)
      this.addMatch = (l, h, a, c) => n(c, a, a + l[0].length, l, h);
    else if (typeof i == "function")
      this.addMatch = (l, h, a, c) => {
        let f = i(l, h, a);
        f && c(a, a + l[0].length, f);
      };
    else if (i)
      this.addMatch = (l, h, a, c) => c(a, a + l[0].length, i);
    else
      throw new RangeError("Either 'decorate' or 'decoration' should be provided to MatchDecorator");
    this.boundary = r, this.maxLength = o;
  }
  createDeco(t) {
    let e = new De(), i = e.add.bind(e);
    for (let { from: n, to: r } of uu(t, this.maxLength))
      to(t.state.doc, this.regexp, n, r, (o, l) => this.addMatch(l, t, o, i));
    return e.finish();
  }
  updateDeco(t, e) {
    let i = 1e9, n = -1;
    return t.docChanged && t.changes.iterChanges((r, o, l, h) => {
      h > t.view.viewport.from && l < t.view.viewport.to && (i = Math.min(l, i), n = Math.max(h, n));
    }), t.viewportChanged || n - i > 1e3 ? this.createDeco(t.view) : n > -1 ? this.updateRange(t.view, e.map(t.changes), i, n) : e;
  }
  updateRange(t, e, i, n) {
    for (let r of t.visibleRanges) {
      let o = Math.max(r.from, i), l = Math.min(r.to, n);
      if (l > o) {
        let h = t.state.doc.lineAt(o), a = h.to < l ? t.state.doc.lineAt(l) : h, c = Math.max(r.from, h.from), f = Math.min(r.to, a.to);
        if (this.boundary) {
          for (; o > h.from; o--)
            if (this.boundary.test(h.text[o - 1 - h.from])) {
              c = o;
              break;
            }
          for (; l < a.to; l++)
            if (this.boundary.test(a.text[l - a.from])) {
              f = l;
              break;
            }
        }
        let u = [], d, p = (w, g, y) => u.push(y.range(w, g));
        if (h == a)
          for (this.regexp.lastIndex = c - h.from; (d = this.regexp.exec(h.text)) && d.index < f - h.from; )
            this.addMatch(d, t, d.index + h.from, p);
        else
          to(t.state.doc, this.regexp, c, f, (w, g) => this.addMatch(g, t, w, p));
        e = e.update({ filterFrom: c, filterTo: f, filter: (w, g) => w < c || g > f, add: u });
      }
    }
    return e;
  }
}
const Ps = /x/.unicode != null ? "gu" : "g", pu = /* @__PURE__ */ new RegExp(`[\0-\b
-\x7F-\x9F\xAD\u061C\u200B\u200E\u200F\u2028\u2029\u202D\u202E\u2066\u2067\u2069\uFEFF\uFFF9-\uFFFC]`, Ps), gu = {
  0: "null",
  7: "bell",
  8: "backspace",
  10: "newline",
  11: "vertical tab",
  13: "carriage return",
  27: "escape",
  8203: "zero width space",
  8204: "zero width non-joiner",
  8205: "zero width joiner",
  8206: "left-to-right mark",
  8207: "right-to-left mark",
  8232: "line separator",
  8237: "left-to-right override",
  8238: "right-to-left override",
  8294: "left-to-right isolate",
  8295: "right-to-left isolate",
  8297: "pop directional isolate",
  8233: "paragraph separator",
  65279: "zero width no-break space",
  65532: "object replacement"
};
let _n = null;
function mu() {
  var s;
  if (_n == null && typeof document < "u" && document.body) {
    let t = document.body.style;
    _n = ((s = t.tabSize) !== null && s !== void 0 ? s : t.MozTabSize) != null;
  }
  return _n || !1;
}
const Wi = /* @__PURE__ */ v.define({
  combine(s) {
    let t = xn(s, {
      render: null,
      specialChars: pu,
      addSpecialChars: null
    });
    return (t.replaceTabs = !mu()) && (t.specialChars = new RegExp("	|" + t.specialChars.source, Ps)), t.addSpecialChars && (t.specialChars = new RegExp(t.specialChars.source + "|" + t.addSpecialChars.source, Ps)), t;
  }
});
function wu(s = {}) {
  return [Wi.of(s), yu()];
}
let eo = null;
function yu() {
  return eo || (eo = wt.fromClass(class {
    constructor(s) {
      this.view = s, this.decorations = D.none, this.decorationCache = /* @__PURE__ */ Object.create(null), this.decorator = this.makeDecorator(s.state.facet(Wi)), this.decorations = this.decorator.createDeco(s);
    }
    makeDecorator(s) {
      return new du({
        regexp: s.specialChars,
        decoration: (t, e, i) => {
          let { doc: n } = e.state, r = oi(t[0], 0);
          if (r == 9) {
            let o = n.lineAt(i), l = e.state.tabSize, h = vn(o.text, l, i - o.from);
            return D.replace({ widget: new vu((l - h % l) * this.view.defaultCharacterWidth) });
          }
          return this.decorationCache[r] || (this.decorationCache[r] = D.replace({ widget: new xu(s, r) }));
        },
        boundary: s.replaceTabs ? void 0 : /[^]/
      });
    }
    update(s) {
      let t = s.state.facet(Wi);
      s.startState.facet(Wi) != t ? (this.decorator = this.makeDecorator(t), this.decorations = this.decorator.createDeco(s.view)) : this.decorations = this.decorator.updateDeco(s, this.decorations);
    }
  }, {
    decorations: (s) => s.decorations
  }));
}
const bu = "\u2022";
function ku(s) {
  return s >= 32 ? bu : s == 10 ? "\u2424" : String.fromCharCode(9216 + s);
}
class xu extends ye {
  constructor(t, e) {
    super(), this.options = t, this.code = e;
  }
  eq(t) {
    return t.code == this.code;
  }
  toDOM(t) {
    let e = ku(this.code), i = t.state.phrase("Control character") + " " + (gu[this.code] || "0x" + this.code.toString(16)), n = this.options.render && this.options.render(this.code, i, e);
    if (n)
      return n;
    let r = document.createElement("span");
    return r.textContent = e, r.title = i, r.setAttribute("aria-label", i), r.className = "cm-specialChar", r;
  }
  ignoreEvent() {
    return !1;
  }
}
class vu extends ye {
  constructor(t) {
    super(), this.width = t;
  }
  eq(t) {
    return t.width == this.width;
  }
  toDOM() {
    let t = document.createElement("span");
    return t.textContent = "	", t.className = "cm-tab", t.style.width = this.width + "px", t;
  }
  ignoreEvent() {
    return !1;
  }
}
function Su() {
  return Au;
}
const Cu = /* @__PURE__ */ D.line({ class: "cm-activeLine" }), Au = /* @__PURE__ */ wt.fromClass(class {
  constructor(s) {
    this.decorations = this.getDeco(s);
  }
  update(s) {
    (s.docChanged || s.selectionSet) && (this.decorations = this.getDeco(s.view));
  }
  getDeco(s) {
    let t = -1, e = [];
    for (let i of s.state.selection.ranges) {
      let n = s.lineBlockAt(i.head);
      n.from > t && (e.push(Cu.range(n.from)), t = n.from);
    }
    return D.set(e);
  }
}, {
  decorations: (s) => s.decorations
}), Wn = "-10000px";
class Zl {
  constructor(t, e, i) {
    this.facet = e, this.createTooltipView = i, this.input = t.state.facet(e), this.tooltips = this.input.filter((n) => n), this.tooltipViews = this.tooltips.map(i);
  }
  update(t) {
    let e = t.state.facet(this.facet), i = e.filter((r) => r);
    if (e === this.input) {
      for (let r of this.tooltipViews)
        r.update && r.update(t);
      return !1;
    }
    let n = [];
    for (let r = 0; r < i.length; r++) {
      let o = i[r], l = -1;
      if (!!o) {
        for (let h = 0; h < this.tooltips.length; h++) {
          let a = this.tooltips[h];
          a && a.create == o.create && (l = h);
        }
        if (l < 0)
          n[r] = this.createTooltipView(o);
        else {
          let h = n[r] = this.tooltipViews[l];
          h.update && h.update(t);
        }
      }
    }
    for (let r of this.tooltipViews)
      n.indexOf(r) < 0 && r.dom.remove();
    return this.input = e, this.tooltips = i, this.tooltipViews = n, !0;
  }
}
function Ou(s) {
  let { win: t } = s;
  return { top: 0, left: 0, bottom: t.innerHeight, right: t.innerWidth };
}
const jn = /* @__PURE__ */ v.define({
  combine: (s) => {
    var t, e, i;
    return {
      position: x.ios ? "absolute" : ((t = s.find((n) => n.position)) === null || t === void 0 ? void 0 : t.position) || "fixed",
      parent: ((e = s.find((n) => n.parent)) === null || e === void 0 ? void 0 : e.parent) || null,
      tooltipSpace: ((i = s.find((n) => n.tooltipSpace)) === null || i === void 0 ? void 0 : i.tooltipSpace) || Ou
    };
  }
}), Mu = /* @__PURE__ */ wt.fromClass(class {
  constructor(s) {
    this.view = s, this.inView = !0, this.lastTransaction = 0, this.measureTimeout = -1;
    let t = s.state.facet(jn);
    this.position = t.position, this.parent = t.parent, this.classes = s.themeClasses, this.createContainer(), this.measureReq = { read: this.readMeasure.bind(this), write: this.writeMeasure.bind(this), key: this }, this.manager = new Zl(s, th, (e) => this.createTooltip(e)), this.intersectionObserver = typeof IntersectionObserver == "function" ? new IntersectionObserver((e) => {
      Date.now() > this.lastTransaction - 50 && e.length > 0 && e[e.length - 1].intersectionRatio < 1 && this.measureSoon();
    }, { threshold: [1] }) : null, this.observeIntersection(), s.win.addEventListener("resize", this.measureSoon = this.measureSoon.bind(this)), this.maybeMeasure();
  }
  createContainer() {
    this.parent ? (this.container = document.createElement("div"), this.container.style.position = "relative", this.container.className = this.view.themeClasses, this.parent.appendChild(this.container)) : this.container = this.view.dom;
  }
  observeIntersection() {
    if (this.intersectionObserver) {
      this.intersectionObserver.disconnect();
      for (let s of this.manager.tooltipViews)
        this.intersectionObserver.observe(s.dom);
    }
  }
  measureSoon() {
    this.measureTimeout < 0 && (this.measureTimeout = setTimeout(() => {
      this.measureTimeout = -1, this.maybeMeasure();
    }, 50));
  }
  update(s) {
    s.transactions.length && (this.lastTransaction = Date.now());
    let t = this.manager.update(s);
    t && this.observeIntersection();
    let e = t || s.geometryChanged, i = s.state.facet(jn);
    if (i.position != this.position) {
      this.position = i.position;
      for (let n of this.manager.tooltipViews)
        n.dom.style.position = this.position;
      e = !0;
    }
    if (i.parent != this.parent) {
      this.parent && this.container.remove(), this.parent = i.parent, this.createContainer();
      for (let n of this.manager.tooltipViews)
        this.container.appendChild(n.dom);
      e = !0;
    } else
      this.parent && this.view.themeClasses != this.classes && (this.classes = this.container.className = this.view.themeClasses);
    e && this.maybeMeasure();
  }
  createTooltip(s) {
    let t = s.create(this.view);
    if (t.dom.classList.add("cm-tooltip"), s.arrow && !t.dom.querySelector(".cm-tooltip > .cm-tooltip-arrow")) {
      let e = document.createElement("div");
      e.className = "cm-tooltip-arrow", t.dom.appendChild(e);
    }
    return t.dom.style.position = this.position, t.dom.style.top = Wn, this.container.appendChild(t.dom), t.mount && t.mount(this.view), t;
  }
  destroy() {
    var s;
    this.view.win.removeEventListener("resize", this.measureSoon);
    for (let { dom: t } of this.manager.tooltipViews)
      t.remove();
    (s = this.intersectionObserver) === null || s === void 0 || s.disconnect(), clearTimeout(this.measureTimeout);
  }
  readMeasure() {
    let s = this.view.dom.getBoundingClientRect();
    return {
      editor: s,
      parent: this.parent ? this.container.getBoundingClientRect() : s,
      pos: this.manager.tooltips.map((t, e) => {
        let i = this.manager.tooltipViews[e];
        return i.getCoords ? i.getCoords(t.pos) : this.view.coordsAtPos(t.pos);
      }),
      size: this.manager.tooltipViews.map(({ dom: t }) => t.getBoundingClientRect()),
      space: this.view.state.facet(jn).tooltipSpace(this.view)
    };
  }
  writeMeasure(s) {
    let { editor: t, space: e } = s, i = [];
    for (let n = 0; n < this.manager.tooltips.length; n++) {
      let r = this.manager.tooltips[n], o = this.manager.tooltipViews[n], { dom: l } = o, h = s.pos[n], a = s.size[n];
      if (!h || h.bottom <= Math.max(t.top, e.top) || h.top >= Math.min(t.bottom, e.bottom) || h.right < Math.max(t.left, e.left) - 0.1 || h.left > Math.min(t.right, e.right) + 0.1) {
        l.style.top = Wn;
        continue;
      }
      let c = r.arrow ? o.dom.querySelector(".cm-tooltip-arrow") : null, f = c ? 7 : 0, u = a.right - a.left, d = a.bottom - a.top, p = o.offset || Tu, w = this.view.textDirection == X.LTR, g = a.width > e.right - e.left ? w ? e.left : e.right - a.width : w ? Math.min(h.left - (c ? 14 : 0) + p.x, e.right - u) : Math.max(e.left, h.left - u + (c ? 14 : 0) - p.x), y = !!r.above;
      !r.strictSide && (y ? h.top - (a.bottom - a.top) - p.y < e.top : h.bottom + (a.bottom - a.top) + p.y > e.bottom) && y == e.bottom - h.bottom > h.top - e.top && (y = !y);
      let O = y ? h.top - d - f - p.y : h.bottom + f + p.y, T = g + u;
      if (o.overlap !== !0)
        for (let C of i)
          C.left < T && C.right > g && C.top < O + d && C.bottom > O && (O = y ? C.top - d - 2 - f : C.bottom + f + 2);
      this.position == "absolute" ? (l.style.top = O - s.parent.top + "px", l.style.left = g - s.parent.left + "px") : (l.style.top = O + "px", l.style.left = g + "px"), c && (c.style.left = `${h.left + (w ? p.x : -p.x) - (g + 14 - 7)}px`), o.overlap !== !0 && i.push({ left: g, top: O, right: T, bottom: O + d }), l.classList.toggle("cm-tooltip-above", y), l.classList.toggle("cm-tooltip-below", !y), o.positioned && o.positioned();
    }
  }
  maybeMeasure() {
    if (this.manager.tooltips.length && (this.view.inView && this.view.requestMeasure(this.measureReq), this.inView != this.view.inView && (this.inView = this.view.inView, !this.inView)))
      for (let s of this.manager.tooltipViews)
        s.dom.style.top = Wn;
  }
}, {
  eventHandlers: {
    scroll() {
      this.maybeMeasure();
    }
  }
}), Du = /* @__PURE__ */ A.baseTheme({
  ".cm-tooltip": {
    zIndex: 100
  },
  "&light .cm-tooltip": {
    border: "1px solid #bbb",
    backgroundColor: "#f5f5f5"
  },
  "&light .cm-tooltip-section:not(:first-child)": {
    borderTop: "1px solid #bbb"
  },
  "&dark .cm-tooltip": {
    backgroundColor: "#333338",
    color: "white"
  },
  ".cm-tooltip-arrow": {
    height: `${7}px`,
    width: `${7 * 2}px`,
    position: "absolute",
    zIndex: -1,
    overflow: "hidden",
    "&:before, &:after": {
      content: "''",
      position: "absolute",
      width: 0,
      height: 0,
      borderLeft: `${7}px solid transparent`,
      borderRight: `${7}px solid transparent`
    },
    ".cm-tooltip-above &": {
      bottom: `-${7}px`,
      "&:before": {
        borderTop: `${7}px solid #bbb`
      },
      "&:after": {
        borderTop: `${7}px solid #f5f5f5`,
        bottom: "1px"
      }
    },
    ".cm-tooltip-below &": {
      top: `-${7}px`,
      "&:before": {
        borderBottom: `${7}px solid #bbb`
      },
      "&:after": {
        borderBottom: `${7}px solid #f5f5f5`,
        top: "1px"
      }
    }
  },
  "&dark .cm-tooltip .cm-tooltip-arrow": {
    "&:before": {
      borderTopColor: "#333338",
      borderBottomColor: "#333338"
    },
    "&:after": {
      borderTopColor: "transparent",
      borderBottomColor: "transparent"
    }
  }
}), Tu = { x: 0, y: 0 }, th = /* @__PURE__ */ v.define({
  enables: [Mu, Du]
}), on = /* @__PURE__ */ v.define();
class Us {
  constructor(t) {
    this.view = t, this.mounted = !1, this.dom = document.createElement("div"), this.dom.classList.add("cm-tooltip-hover"), this.manager = new Zl(t, on, (e) => this.createHostedView(e));
  }
  static create(t) {
    return new Us(t);
  }
  createHostedView(t) {
    let e = t.create(this.view);
    return e.dom.classList.add("cm-tooltip-section"), this.dom.appendChild(e.dom), this.mounted && e.mount && e.mount(this.view), e;
  }
  mount(t) {
    for (let e of this.manager.tooltipViews)
      e.mount && e.mount(t);
    this.mounted = !0;
  }
  positioned() {
    for (let t of this.manager.tooltipViews)
      t.positioned && t.positioned();
  }
  update(t) {
    this.manager.update(t);
  }
}
const Pu = /* @__PURE__ */ th.compute([on], (s) => {
  let t = s.facet(on).filter((e) => e);
  return t.length === 0 ? null : {
    pos: Math.min(...t.map((e) => e.pos)),
    end: Math.max(...t.filter((e) => e.end != null).map((e) => e.end)),
    create: Us.create,
    above: t[0].above,
    arrow: t.some((e) => e.arrow)
  };
});
class Bu {
  constructor(t, e, i, n, r) {
    this.view = t, this.source = e, this.field = i, this.setHover = n, this.hoverTime = r, this.hoverTimeout = -1, this.restartTimeout = -1, this.pending = null, this.lastMove = { x: 0, y: 0, target: t.dom, time: 0 }, this.checkHover = this.checkHover.bind(this), t.dom.addEventListener("mouseleave", this.mouseleave = this.mouseleave.bind(this)), t.dom.addEventListener("mousemove", this.mousemove = this.mousemove.bind(this));
  }
  update() {
    this.pending && (this.pending = null, clearTimeout(this.restartTimeout), this.restartTimeout = setTimeout(() => this.startHover(), 20));
  }
  get active() {
    return this.view.state.field(this.field);
  }
  checkHover() {
    if (this.hoverTimeout = -1, this.active)
      return;
    let t = Date.now() - this.lastMove.time;
    t < this.hoverTime ? this.hoverTimeout = setTimeout(this.checkHover, this.hoverTime - t) : this.startHover();
  }
  startHover() {
    clearTimeout(this.restartTimeout);
    let { lastMove: t } = this, e = this.view.contentDOM.contains(t.target) ? this.view.posAtCoords(t) : null;
    if (e == null)
      return;
    let i = this.view.coordsAtPos(e);
    if (i == null || t.y < i.top || t.y > i.bottom || t.x < i.left - this.view.defaultCharacterWidth || t.x > i.right + this.view.defaultCharacterWidth)
      return;
    let n = this.view.bidiSpans(this.view.state.doc.lineAt(e)).find((l) => l.from <= e && l.to >= e), r = n && n.dir == X.RTL ? -1 : 1, o = this.source(this.view, e, t.x < i.left ? -r : r);
    if (o != null && o.then) {
      let l = this.pending = { pos: e };
      o.then((h) => {
        this.pending == l && (this.pending = null, h && this.view.dispatch({ effects: this.setHover.of(h) }));
      }, (h) => zt(this.view.state, h, "hover tooltip"));
    } else
      o && this.view.dispatch({ effects: this.setHover.of(o) });
  }
  mousemove(t) {
    var e;
    this.lastMove = { x: t.clientX, y: t.clientY, target: t.target, time: Date.now() }, this.hoverTimeout < 0 && (this.hoverTimeout = setTimeout(this.checkHover, this.hoverTime));
    let i = this.active;
    if (i && !Ru(this.lastMove.target) || this.pending) {
      let { pos: n } = i || this.pending, r = (e = i == null ? void 0 : i.end) !== null && e !== void 0 ? e : n;
      (n == r ? this.view.posAtCoords(this.lastMove) != n : !Lu(this.view, n, r, t.clientX, t.clientY, 6)) && (this.view.dispatch({ effects: this.setHover.of(null) }), this.pending = null);
    }
  }
  mouseleave() {
    clearTimeout(this.hoverTimeout), this.hoverTimeout = -1, this.active && this.view.dispatch({ effects: this.setHover.of(null) });
  }
  destroy() {
    clearTimeout(this.hoverTimeout), this.view.dom.removeEventListener("mouseleave", this.mouseleave), this.view.dom.removeEventListener("mousemove", this.mousemove);
  }
}
function Ru(s) {
  for (let t = s; t; t = t.parentNode)
    if (t.nodeType == 1 && t.classList.contains("cm-tooltip"))
      return !0;
  return !1;
}
function Lu(s, t, e, i, n, r) {
  let o = document.createRange(), l = s.domAtPos(t), h = s.domAtPos(e);
  o.setEnd(h.node, h.offset), o.setStart(l.node, l.offset);
  let a = o.getClientRects();
  o.detach();
  for (let c = 0; c < a.length; c++) {
    let f = a[c];
    if (Math.max(f.top - n, n - f.bottom, f.left - i, i - f.right) <= r)
      return !0;
  }
  return !1;
}
function Eu(s, t = {}) {
  let e = F.define(), i = Bt.define({
    create() {
      return null;
    },
    update(n, r) {
      if (n && (t.hideOnChange && (r.docChanged || r.selection) || t.hideOn && t.hideOn(r, n)))
        return null;
      if (n && r.docChanged) {
        let o = r.changes.mapPos(n.pos, -1, pt.TrackDel);
        if (o == null)
          return null;
        let l = Object.assign(/* @__PURE__ */ Object.create(null), n);
        l.pos = o, n.end != null && (l.end = r.changes.mapPos(n.end)), n = l;
      }
      for (let o of r.effects)
        o.is(e) && (n = o.value), o.is(Nu) && (n = null);
      return n;
    },
    provide: (n) => on.from(n)
  });
  return [
    i,
    wt.define((n) => new Bu(n, s, i, e, t.hoverTime || 300)),
    Pu
  ];
}
const Nu = /* @__PURE__ */ F.define(), io = /* @__PURE__ */ v.define({
  combine(s) {
    let t, e;
    for (let i of s)
      t = t || i.topContainer, e = e || i.bottomContainer;
    return { topContainer: t, bottomContainer: e };
  }
});
function Vu(s, t) {
  let e = s.plugin(eh), i = e ? e.specs.indexOf(t) : -1;
  return i > -1 ? e.panels[i] : null;
}
const eh = /* @__PURE__ */ wt.fromClass(class {
  constructor(s) {
    this.input = s.state.facet(Bs), this.specs = this.input.filter((e) => e), this.panels = this.specs.map((e) => e(s));
    let t = s.state.facet(io);
    this.top = new Ri(s, !0, t.topContainer), this.bottom = new Ri(s, !1, t.bottomContainer), this.top.sync(this.panels.filter((e) => e.top)), this.bottom.sync(this.panels.filter((e) => !e.top));
    for (let e of this.panels)
      e.dom.classList.add("cm-panel"), e.mount && e.mount();
  }
  update(s) {
    let t = s.state.facet(io);
    this.top.container != t.topContainer && (this.top.sync([]), this.top = new Ri(s.view, !0, t.topContainer)), this.bottom.container != t.bottomContainer && (this.bottom.sync([]), this.bottom = new Ri(s.view, !1, t.bottomContainer)), this.top.syncClasses(), this.bottom.syncClasses();
    let e = s.state.facet(Bs);
    if (e != this.input) {
      let i = e.filter((h) => h), n = [], r = [], o = [], l = [];
      for (let h of i) {
        let a = this.specs.indexOf(h), c;
        a < 0 ? (c = h(s.view), l.push(c)) : (c = this.panels[a], c.update && c.update(s)), n.push(c), (c.top ? r : o).push(c);
      }
      this.specs = i, this.panels = n, this.top.sync(r), this.bottom.sync(o);
      for (let h of l)
        h.dom.classList.add("cm-panel"), h.mount && h.mount();
    } else
      for (let i of this.panels)
        i.update && i.update(s);
  }
  destroy() {
    this.top.sync([]), this.bottom.sync([]);
  }
}, {
  provide: (s) => A.scrollMargins.of((t) => {
    let e = t.plugin(s);
    return e && { top: e.top.scrollMargin(), bottom: e.bottom.scrollMargin() };
  })
});
class Ri {
  constructor(t, e, i) {
    this.view = t, this.top = e, this.container = i, this.dom = void 0, this.classes = "", this.panels = [], this.syncClasses();
  }
  sync(t) {
    for (let e of this.panels)
      e.destroy && t.indexOf(e) < 0 && e.destroy();
    this.panels = t, this.syncDOM();
  }
  syncDOM() {
    if (this.panels.length == 0) {
      this.dom && (this.dom.remove(), this.dom = void 0);
      return;
    }
    if (!this.dom) {
      this.dom = document.createElement("div"), this.dom.className = this.top ? "cm-panels cm-panels-top" : "cm-panels cm-panels-bottom", this.dom.style[this.top ? "top" : "bottom"] = "0";
      let e = this.container || this.view.dom;
      e.insertBefore(this.dom, this.top ? e.firstChild : null);
    }
    let t = this.dom.firstChild;
    for (let e of this.panels)
      if (e.dom.parentNode == this.dom) {
        for (; t != e.dom; )
          t = no(t);
        t = t.nextSibling;
      } else
        this.dom.insertBefore(e.dom, t);
    for (; t; )
      t = no(t);
  }
  scrollMargin() {
    return !this.dom || this.container ? 0 : Math.max(0, this.top ? this.dom.getBoundingClientRect().bottom - Math.max(0, this.view.scrollDOM.getBoundingClientRect().top) : Math.min(innerHeight, this.view.scrollDOM.getBoundingClientRect().bottom) - this.dom.getBoundingClientRect().top);
  }
  syncClasses() {
    if (!(!this.container || this.classes == this.view.themeClasses)) {
      for (let t of this.classes.split(" "))
        t && this.container.classList.remove(t);
      for (let t of (this.classes = this.view.themeClasses).split(" "))
        t && this.container.classList.add(t);
    }
  }
}
function no(s) {
  let t = s.nextSibling;
  return s.remove(), t;
}
const Bs = /* @__PURE__ */ v.define({
  enables: eh
});
class me extends _e {
  compare(t) {
    return this == t || this.constructor == t.constructor && this.eq(t);
  }
  eq(t) {
    return !1;
  }
  destroy(t) {
  }
}
me.prototype.elementClass = "";
me.prototype.toDOM = void 0;
me.prototype.mapMode = pt.TrackBefore;
me.prototype.startSide = me.prototype.endSide = -1;
me.prototype.point = !0;
const ji = /* @__PURE__ */ v.define(), Iu = {
  class: "",
  renderEmptyElements: !1,
  elementStyle: "",
  markers: () => $.empty,
  lineMarker: () => null,
  lineMarkerChange: null,
  initialSpacer: null,
  updateSpacer: null,
  domEventHandlers: {}
}, qi = /* @__PURE__ */ v.define();
function Hu(s) {
  return [$u(), qi.of(Object.assign(Object.assign({}, Iu), s))];
}
const Rs = /* @__PURE__ */ v.define({
  combine: (s) => s.some((t) => t)
});
function $u(s) {
  let t = [
    Fu
  ];
  return s && s.fixed === !1 && t.push(Rs.of(!0)), t;
}
const Fu = /* @__PURE__ */ wt.fromClass(class {
  constructor(s) {
    this.view = s, this.prevViewport = s.viewport, this.dom = document.createElement("div"), this.dom.className = "cm-gutters", this.dom.setAttribute("aria-hidden", "true"), this.dom.style.minHeight = this.view.contentHeight + "px", this.gutters = s.state.facet(qi).map((t) => new ro(s, t));
    for (let t of this.gutters)
      this.dom.appendChild(t.dom);
    this.fixed = !s.state.facet(Rs), this.fixed && (this.dom.style.position = "sticky"), this.syncGutters(!1), s.scrollDOM.insertBefore(this.dom, s.contentDOM);
  }
  update(s) {
    if (this.updateGutters(s)) {
      let t = this.prevViewport, e = s.view.viewport, i = Math.min(t.to, e.to) - Math.max(t.from, e.from);
      this.syncGutters(i < (e.to - e.from) * 0.8);
    }
    s.geometryChanged && (this.dom.style.minHeight = this.view.contentHeight + "px"), this.view.state.facet(Rs) != !this.fixed && (this.fixed = !this.fixed, this.dom.style.position = this.fixed ? "sticky" : ""), this.prevViewport = s.view.viewport;
  }
  syncGutters(s) {
    let t = this.dom.nextSibling;
    s && this.dom.remove();
    let e = $.iter(this.view.state.facet(ji), this.view.viewport.from), i = [], n = this.gutters.map((r) => new zu(r, this.view.viewport, -this.view.documentPadding.top));
    for (let r of this.view.viewportLineBlocks) {
      let o;
      if (Array.isArray(r.type)) {
        for (let l of r.type)
          if (l.type == U.Text) {
            o = l;
            break;
          }
      } else
        o = r.type == U.Text ? r : void 0;
      if (!!o) {
        i.length && (i = []), ih(e, i, r.from);
        for (let l of n)
          l.line(this.view, o, i);
      }
    }
    for (let r of n)
      r.finish();
    s && this.view.scrollDOM.insertBefore(this.dom, t);
  }
  updateGutters(s) {
    let t = s.startState.facet(qi), e = s.state.facet(qi), i = s.docChanged || s.heightChanged || s.viewportChanged || !$.eq(s.startState.facet(ji), s.state.facet(ji), s.view.viewport.from, s.view.viewport.to);
    if (t == e)
      for (let n of this.gutters)
        n.update(s) && (i = !0);
    else {
      i = !0;
      let n = [];
      for (let r of e) {
        let o = t.indexOf(r);
        o < 0 ? n.push(new ro(this.view, r)) : (this.gutters[o].update(s), n.push(this.gutters[o]));
      }
      for (let r of this.gutters)
        r.dom.remove(), n.indexOf(r) < 0 && r.destroy();
      for (let r of n)
        this.dom.appendChild(r.dom);
      this.gutters = n;
    }
    return i;
  }
  destroy() {
    for (let s of this.gutters)
      s.destroy();
    this.dom.remove();
  }
}, {
  provide: (s) => A.scrollMargins.of((t) => {
    let e = t.plugin(s);
    return !e || e.gutters.length == 0 || !e.fixed ? null : t.textDirection == X.LTR ? { left: e.dom.offsetWidth } : { right: e.dom.offsetWidth };
  })
});
function so(s) {
  return Array.isArray(s) ? s : [s];
}
function ih(s, t, e) {
  for (; s.value && s.from <= e; )
    s.from == e && t.push(s.value), s.next();
}
class zu {
  constructor(t, e, i) {
    this.gutter = t, this.height = i, this.localMarkers = [], this.i = 0, this.cursor = $.iter(t.markers, e.from);
  }
  line(t, e, i) {
    this.localMarkers.length && (this.localMarkers = []), ih(this.cursor, this.localMarkers, e.from);
    let n = i.length ? this.localMarkers.concat(i) : this.localMarkers, r = this.gutter.config.lineMarker(t, e, n);
    r && n.unshift(r);
    let o = this.gutter;
    if (n.length == 0 && !o.config.renderEmptyElements)
      return;
    let l = e.top - this.height;
    if (this.i == o.elements.length) {
      let h = new nh(t, e.height, l, n);
      o.elements.push(h), o.dom.appendChild(h.dom);
    } else
      o.elements[this.i].update(t, e.height, l, n);
    this.height = e.bottom, this.i++;
  }
  finish() {
    let t = this.gutter;
    for (; t.elements.length > this.i; ) {
      let e = t.elements.pop();
      t.dom.removeChild(e.dom), e.destroy();
    }
  }
}
class ro {
  constructor(t, e) {
    this.view = t, this.config = e, this.elements = [], this.spacer = null, this.dom = document.createElement("div"), this.dom.className = "cm-gutter" + (this.config.class ? " " + this.config.class : "");
    for (let i in e.domEventHandlers)
      this.dom.addEventListener(i, (n) => {
        let r = t.lineBlockAtHeight(n.clientY - t.documentTop);
        e.domEventHandlers[i](t, r, n) && n.preventDefault();
      });
    this.markers = so(e.markers(t)), e.initialSpacer && (this.spacer = new nh(t, 0, 0, [e.initialSpacer(t)]), this.dom.appendChild(this.spacer.dom), this.spacer.dom.style.cssText += "visibility: hidden; pointer-events: none");
  }
  update(t) {
    let e = this.markers;
    if (this.markers = so(this.config.markers(t.view)), this.spacer && this.config.updateSpacer) {
      let n = this.config.updateSpacer(this.spacer.markers[0], t);
      n != this.spacer.markers[0] && this.spacer.update(t.view, 0, 0, [n]);
    }
    let i = t.view.viewport;
    return !$.eq(this.markers, e, i.from, i.to) || (this.config.lineMarkerChange ? this.config.lineMarkerChange(t) : !1);
  }
  destroy() {
    for (let t of this.elements)
      t.destroy();
  }
}
class nh {
  constructor(t, e, i, n) {
    this.height = -1, this.above = 0, this.markers = [], this.dom = document.createElement("div"), this.dom.className = "cm-gutterElement", this.update(t, e, i, n);
  }
  update(t, e, i, n) {
    this.height != e && (this.dom.style.height = (this.height = e) + "px"), this.above != i && (this.dom.style.marginTop = (this.above = i) ? i + "px" : ""), _u(this.markers, n) || this.setMarkers(t, n);
  }
  setMarkers(t, e) {
    let i = "cm-gutterElement", n = this.dom.firstChild;
    for (let r = 0, o = 0; ; ) {
      let l = o, h = r < e.length ? e[r++] : null, a = !1;
      if (h) {
        let c = h.elementClass;
        c && (i += " " + c);
        for (let f = o; f < this.markers.length; f++)
          if (this.markers[f].compare(h)) {
            l = f, a = !0;
            break;
          }
      } else
        l = this.markers.length;
      for (; o < l; ) {
        let c = this.markers[o++];
        if (c.toDOM) {
          c.destroy(n);
          let f = n.nextSibling;
          n.remove(), n = f;
        }
      }
      if (!h)
        break;
      h.toDOM && (a ? n = n.nextSibling : this.dom.insertBefore(h.toDOM(t), n)), a && o++;
    }
    this.dom.className = i, this.markers = e;
  }
  destroy() {
    this.setMarkers(null, []);
  }
}
function _u(s, t) {
  if (s.length != t.length)
    return !1;
  for (let e = 0; e < s.length; e++)
    if (!s[e].compare(t[e]))
      return !1;
  return !0;
}
const Wu = /* @__PURE__ */ new class extends me {
  constructor() {
    super(...arguments), this.elementClass = "cm-activeLineGutter";
  }
}(), ju = /* @__PURE__ */ ji.compute(["selection"], (s) => {
  let t = [], e = -1;
  for (let i of s.selection.ranges) {
    let n = s.doc.lineAt(i.head).from;
    n > e && (e = n, t.push(Wu.range(n)));
  }
  return $.of(t);
});
function qu() {
  return ju;
}
const sh = 1024;
let Gu = 0;
class qn {
  constructor(t, e) {
    this.from = t, this.to = e;
  }
}
class P {
  constructor(t = {}) {
    this.id = Gu++, this.perNode = !!t.perNode, this.deserialize = t.deserialize || (() => {
      throw new Error("This node type doesn't define a deserialize function");
    });
  }
  add(t) {
    if (this.perNode)
      throw new RangeError("Can't add per-node props to node types");
    return typeof t != "function" && (t = yt.match(t)), (e) => {
      let i = t(e);
      return i === void 0 ? null : [this, i];
    };
  }
}
P.closedBy = new P({ deserialize: (s) => s.split(" ") });
P.openedBy = new P({ deserialize: (s) => s.split(" ") });
P.group = new P({ deserialize: (s) => s.split(" ") });
P.contextHash = new P({ perNode: !0 });
P.lookAhead = new P({ perNode: !0 });
P.mounted = new P({ perNode: !0 });
const Ku = /* @__PURE__ */ Object.create(null);
class yt {
  constructor(t, e, i, n = 0) {
    this.name = t, this.props = e, this.id = i, this.flags = n;
  }
  static define(t) {
    let e = t.props && t.props.length ? /* @__PURE__ */ Object.create(null) : Ku, i = (t.top ? 1 : 0) | (t.skipped ? 2 : 0) | (t.error ? 4 : 0) | (t.name == null ? 8 : 0), n = new yt(t.name || "", e, t.id, i);
    if (t.props) {
      for (let r of t.props)
        if (Array.isArray(r) || (r = r(n)), r) {
          if (r[0].perNode)
            throw new RangeError("Can't store a per-node prop on a node type");
          e[r[0].id] = r[1];
        }
    }
    return n;
  }
  prop(t) {
    return this.props[t.id];
  }
  get isTop() {
    return (this.flags & 1) > 0;
  }
  get isSkipped() {
    return (this.flags & 2) > 0;
  }
  get isError() {
    return (this.flags & 4) > 0;
  }
  get isAnonymous() {
    return (this.flags & 8) > 0;
  }
  is(t) {
    if (typeof t == "string") {
      if (this.name == t)
        return !0;
      let e = this.prop(P.group);
      return e ? e.indexOf(t) > -1 : !1;
    }
    return this.id == t;
  }
  static match(t) {
    let e = /* @__PURE__ */ Object.create(null);
    for (let i in t)
      for (let n of i.split(" "))
        e[n] = t[i];
    return (i) => {
      for (let n = i.prop(P.group), r = -1; r < (n ? n.length : 0); r++) {
        let o = e[r < 0 ? i.name : n[r]];
        if (o)
          return o;
      }
    };
  }
}
yt.none = new yt("", /* @__PURE__ */ Object.create(null), 0, 8);
class Qs {
  constructor(t) {
    this.types = t;
    for (let e = 0; e < t.length; e++)
      if (t[e].id != e)
        throw new RangeError("Node type ids should correspond to array positions when creating a node set");
  }
  extend(...t) {
    let e = [];
    for (let i of this.types) {
      let n = null;
      for (let r of t) {
        let o = r(i);
        o && (n || (n = Object.assign({}, i.props)), n[o[0].id] = o[1]);
      }
      e.push(n ? new yt(i.name, n, i.id, i.flags) : i);
    }
    return new Qs(e);
  }
}
const Li = /* @__PURE__ */ new WeakMap(), oo = /* @__PURE__ */ new WeakMap();
var st;
(function(s) {
  s[s.ExcludeBuffers = 1] = "ExcludeBuffers", s[s.IncludeAnonymous = 2] = "IncludeAnonymous", s[s.IgnoreMounts = 4] = "IgnoreMounts", s[s.IgnoreOverlays = 8] = "IgnoreOverlays";
})(st || (st = {}));
class J {
  constructor(t, e, i, n, r) {
    if (this.type = t, this.children = e, this.positions = i, this.length = n, this.props = null, r && r.length) {
      this.props = /* @__PURE__ */ Object.create(null);
      for (let [o, l] of r)
        this.props[typeof o == "number" ? o : o.id] = l;
    }
  }
  toString() {
    let t = this.prop(P.mounted);
    if (t && !t.overlay)
      return t.tree.toString();
    let e = "";
    for (let i of this.children) {
      let n = i.toString();
      n && (e && (e += ","), e += n);
    }
    return this.type.name ? (/\W/.test(this.type.name) && !this.type.isError ? JSON.stringify(this.type.name) : this.type.name) + (e.length ? "(" + e + ")" : "") : e;
  }
  cursor(t = 0) {
    return new an(this.topNode, t);
  }
  cursorAt(t, e = 0, i = 0) {
    let n = Li.get(this) || this.topNode, r = new an(n);
    return r.moveTo(t, e), Li.set(this, r._tree), r;
  }
  get topNode() {
    return new Zt(this, 0, 0, null);
  }
  resolve(t, e = 0) {
    let i = Ge(Li.get(this) || this.topNode, t, e, !1);
    return Li.set(this, i), i;
  }
  resolveInner(t, e = 0) {
    let i = Ge(oo.get(this) || this.topNode, t, e, !0);
    return oo.set(this, i), i;
  }
  iterate(t) {
    let { enter: e, leave: i, from: n = 0, to: r = this.length } = t;
    for (let o = this.cursor((t.mode || 0) | st.IncludeAnonymous); ; ) {
      let l = !1;
      if (o.from <= r && o.to >= n && (o.type.isAnonymous || e(o) !== !1)) {
        if (o.firstChild())
          continue;
        l = !0;
      }
      for (; l && i && !o.type.isAnonymous && i(o), !o.nextSibling(); ) {
        if (!o.parent())
          return;
        l = !0;
      }
    }
  }
  prop(t) {
    return t.perNode ? this.props ? this.props[t.id] : void 0 : this.type.prop(t);
  }
  get propValues() {
    let t = [];
    if (this.props)
      for (let e in this.props)
        t.push([+e, this.props[e]]);
    return t;
  }
  balance(t = {}) {
    return this.children.length <= 8 ? this : Ys(yt.none, this.children, this.positions, 0, this.children.length, 0, this.length, (e, i, n) => new J(this.type, e, i, n, this.propValues), t.makeTree || ((e, i, n) => new J(yt.none, e, i, n)));
  }
  static build(t) {
    return Qu(t);
  }
}
J.empty = new J(yt.none, [], [], 0);
class Js {
  constructor(t, e) {
    this.buffer = t, this.index = e;
  }
  get id() {
    return this.buffer[this.index - 4];
  }
  get start() {
    return this.buffer[this.index - 3];
  }
  get end() {
    return this.buffer[this.index - 2];
  }
  get size() {
    return this.buffer[this.index - 1];
  }
  get pos() {
    return this.index;
  }
  next() {
    this.index -= 4;
  }
  fork() {
    return new Js(this.buffer, this.index);
  }
}
class Re {
  constructor(t, e, i) {
    this.buffer = t, this.length = e, this.set = i;
  }
  get type() {
    return yt.none;
  }
  toString() {
    let t = [];
    for (let e = 0; e < this.buffer.length; )
      t.push(this.childString(e)), e = this.buffer[e + 3];
    return t.join(",");
  }
  childString(t) {
    let e = this.buffer[t], i = this.buffer[t + 3], n = this.set.types[e], r = n.name;
    if (/\W/.test(r) && !n.isError && (r = JSON.stringify(r)), t += 4, i == t)
      return r;
    let o = [];
    for (; t < i; )
      o.push(this.childString(t)), t = this.buffer[t + 3];
    return r + "(" + o.join(",") + ")";
  }
  findChild(t, e, i, n, r) {
    let { buffer: o } = this, l = -1;
    for (let h = t; h != e && !(rh(r, n, o[h + 1], o[h + 2]) && (l = h, i > 0)); h = o[h + 3])
      ;
    return l;
  }
  slice(t, e, i, n) {
    let r = this.buffer, o = new Uint16Array(e - t);
    for (let l = t, h = 0; l < e; )
      o[h++] = r[l++], o[h++] = r[l++] - i, o[h++] = r[l++] - i, o[h++] = r[l++] - t;
    return new Re(o, n - i, this.set);
  }
}
function rh(s, t, e, i) {
  switch (s) {
    case -2:
      return e < t;
    case -1:
      return i >= t && e < t;
    case 0:
      return e < t && i > t;
    case 1:
      return e <= t && i > t;
    case 2:
      return i > t;
    case 4:
      return !0;
  }
}
function oh(s, t) {
  let e = s.childBefore(t);
  for (; e; ) {
    let i = e.lastChild;
    if (!i || i.to != e.to)
      break;
    i.type.isError && i.from == i.to ? (s = e, e = i.prevSibling) : e = i;
  }
  return s;
}
function Ge(s, t, e, i) {
  for (var n; s.from == s.to || (e < 1 ? s.from >= t : s.from > t) || (e > -1 ? s.to <= t : s.to < t); ) {
    let o = !i && s instanceof Zt && s.index < 0 ? null : s.parent;
    if (!o)
      return s;
    s = o;
  }
  let r = i ? 0 : st.IgnoreOverlays;
  if (i)
    for (let o = s, l = o.parent; l; o = l, l = o.parent)
      o instanceof Zt && o.index < 0 && ((n = l.enter(t, e, r)) === null || n === void 0 ? void 0 : n.from) != o.from && (s = l);
  for (; ; ) {
    let o = s.enter(t, e, r);
    if (!o)
      return s;
    s = o;
  }
}
class Zt {
  constructor(t, e, i, n) {
    this._tree = t, this.from = e, this.index = i, this._parent = n;
  }
  get type() {
    return this._tree.type;
  }
  get name() {
    return this._tree.type.name;
  }
  get to() {
    return this.from + this._tree.length;
  }
  nextChild(t, e, i, n, r = 0) {
    for (let o = this; ; ) {
      for (let { children: l, positions: h } = o._tree, a = e > 0 ? l.length : -1; t != a; t += e) {
        let c = l[t], f = h[t] + o.from;
        if (!!rh(n, i, f, f + c.length)) {
          if (c instanceof Re) {
            if (r & st.ExcludeBuffers)
              continue;
            let u = c.findChild(0, c.buffer.length, e, i - f, n);
            if (u > -1)
              return new ce(new Uu(o, c, t, f), null, u);
          } else if (r & st.IncludeAnonymous || !c.type.isAnonymous || Xs(c)) {
            let u;
            if (!(r & st.IgnoreMounts) && c.props && (u = c.prop(P.mounted)) && !u.overlay)
              return new Zt(u.tree, f, t, o);
            let d = new Zt(c, f, t, o);
            return r & st.IncludeAnonymous || !d.type.isAnonymous ? d : d.nextChild(e < 0 ? c.children.length - 1 : 0, e, i, n);
          }
        }
      }
      if (r & st.IncludeAnonymous || !o.type.isAnonymous || (o.index >= 0 ? t = o.index + e : t = e < 0 ? -1 : o._parent._tree.children.length, o = o._parent, !o))
        return null;
    }
  }
  get firstChild() {
    return this.nextChild(0, 1, 0, 4);
  }
  get lastChild() {
    return this.nextChild(this._tree.children.length - 1, -1, 0, 4);
  }
  childAfter(t) {
    return this.nextChild(0, 1, t, 2);
  }
  childBefore(t) {
    return this.nextChild(this._tree.children.length - 1, -1, t, -2);
  }
  enter(t, e, i = 0) {
    let n;
    if (!(i & st.IgnoreOverlays) && (n = this._tree.prop(P.mounted)) && n.overlay) {
      let r = t - this.from;
      for (let { from: o, to: l } of n.overlay)
        if ((e > 0 ? o <= r : o < r) && (e < 0 ? l >= r : l > r))
          return new Zt(n.tree, n.overlay[0].from + this.from, -1, this);
    }
    return this.nextChild(0, 1, t, e, i);
  }
  nextSignificantParent() {
    let t = this;
    for (; t.type.isAnonymous && t._parent; )
      t = t._parent;
    return t;
  }
  get parent() {
    return this._parent ? this._parent.nextSignificantParent() : null;
  }
  get nextSibling() {
    return this._parent && this.index >= 0 ? this._parent.nextChild(this.index + 1, 1, 0, 4) : null;
  }
  get prevSibling() {
    return this._parent && this.index >= 0 ? this._parent.nextChild(this.index - 1, -1, 0, 4) : null;
  }
  cursor(t = 0) {
    return new an(this, t);
  }
  get tree() {
    return this._tree;
  }
  toTree() {
    return this._tree;
  }
  resolve(t, e = 0) {
    return Ge(this, t, e, !1);
  }
  resolveInner(t, e = 0) {
    return Ge(this, t, e, !0);
  }
  enterUnfinishedNodesBefore(t) {
    return oh(this, t);
  }
  getChild(t, e = null, i = null) {
    let n = ln(this, t, e, i);
    return n.length ? n[0] : null;
  }
  getChildren(t, e = null, i = null) {
    return ln(this, t, e, i);
  }
  toString() {
    return this._tree.toString();
  }
  get node() {
    return this;
  }
  matchContext(t) {
    return hn(this, t);
  }
}
function ln(s, t, e, i) {
  let n = s.cursor(), r = [];
  if (!n.firstChild())
    return r;
  if (e != null) {
    for (; !n.type.is(e); )
      if (!n.nextSibling())
        return r;
  }
  for (; ; ) {
    if (i != null && n.type.is(i))
      return r;
    if (n.type.is(t) && r.push(n.node), !n.nextSibling())
      return i == null ? r : [];
  }
}
function hn(s, t, e = t.length - 1) {
  for (let i = s.parent; e >= 0; i = i.parent) {
    if (!i)
      return !1;
    if (!i.type.isAnonymous) {
      if (t[e] && t[e] != i.name)
        return !1;
      e--;
    }
  }
  return !0;
}
class Uu {
  constructor(t, e, i, n) {
    this.parent = t, this.buffer = e, this.index = i, this.start = n;
  }
}
class ce {
  constructor(t, e, i) {
    this.context = t, this._parent = e, this.index = i, this.type = t.buffer.set.types[t.buffer.buffer[i]];
  }
  get name() {
    return this.type.name;
  }
  get from() {
    return this.context.start + this.context.buffer.buffer[this.index + 1];
  }
  get to() {
    return this.context.start + this.context.buffer.buffer[this.index + 2];
  }
  child(t, e, i) {
    let { buffer: n } = this.context, r = n.findChild(this.index + 4, n.buffer[this.index + 3], t, e - this.context.start, i);
    return r < 0 ? null : new ce(this.context, this, r);
  }
  get firstChild() {
    return this.child(1, 0, 4);
  }
  get lastChild() {
    return this.child(-1, 0, 4);
  }
  childAfter(t) {
    return this.child(1, t, 2);
  }
  childBefore(t) {
    return this.child(-1, t, -2);
  }
  enter(t, e, i = 0) {
    if (i & st.ExcludeBuffers)
      return null;
    let { buffer: n } = this.context, r = n.findChild(this.index + 4, n.buffer[this.index + 3], e > 0 ? 1 : -1, t - this.context.start, e);
    return r < 0 ? null : new ce(this.context, this, r);
  }
  get parent() {
    return this._parent || this.context.parent.nextSignificantParent();
  }
  externalSibling(t) {
    return this._parent ? null : this.context.parent.nextChild(this.context.index + t, t, 0, 4);
  }
  get nextSibling() {
    let { buffer: t } = this.context, e = t.buffer[this.index + 3];
    return e < (this._parent ? t.buffer[this._parent.index + 3] : t.buffer.length) ? new ce(this.context, this._parent, e) : this.externalSibling(1);
  }
  get prevSibling() {
    let { buffer: t } = this.context, e = this._parent ? this._parent.index + 4 : 0;
    return this.index == e ? this.externalSibling(-1) : new ce(this.context, this._parent, t.findChild(e, this.index, -1, 0, 4));
  }
  cursor(t = 0) {
    return new an(this, t);
  }
  get tree() {
    return null;
  }
  toTree() {
    let t = [], e = [], { buffer: i } = this.context, n = this.index + 4, r = i.buffer[this.index + 3];
    if (r > n) {
      let o = i.buffer[this.index + 1], l = i.buffer[this.index + 2];
      t.push(i.slice(n, r, o, l)), e.push(0);
    }
    return new J(this.type, t, e, this.to - this.from);
  }
  resolve(t, e = 0) {
    return Ge(this, t, e, !1);
  }
  resolveInner(t, e = 0) {
    return Ge(this, t, e, !0);
  }
  enterUnfinishedNodesBefore(t) {
    return oh(this, t);
  }
  toString() {
    return this.context.buffer.childString(this.index);
  }
  getChild(t, e = null, i = null) {
    let n = ln(this, t, e, i);
    return n.length ? n[0] : null;
  }
  getChildren(t, e = null, i = null) {
    return ln(this, t, e, i);
  }
  get node() {
    return this;
  }
  matchContext(t) {
    return hn(this, t);
  }
}
class an {
  constructor(t, e = 0) {
    if (this.mode = e, this.buffer = null, this.stack = [], this.index = 0, this.bufferNode = null, t instanceof Zt)
      this.yieldNode(t);
    else {
      this._tree = t.context.parent, this.buffer = t.context;
      for (let i = t._parent; i; i = i._parent)
        this.stack.unshift(i.index);
      this.bufferNode = t, this.yieldBuf(t.index);
    }
  }
  get name() {
    return this.type.name;
  }
  yieldNode(t) {
    return t ? (this._tree = t, this.type = t.type, this.from = t.from, this.to = t.to, !0) : !1;
  }
  yieldBuf(t, e) {
    this.index = t;
    let { start: i, buffer: n } = this.buffer;
    return this.type = e || n.set.types[n.buffer[t]], this.from = i + n.buffer[t + 1], this.to = i + n.buffer[t + 2], !0;
  }
  yield(t) {
    return t ? t instanceof Zt ? (this.buffer = null, this.yieldNode(t)) : (this.buffer = t.context, this.yieldBuf(t.index, t.type)) : !1;
  }
  toString() {
    return this.buffer ? this.buffer.buffer.childString(this.index) : this._tree.toString();
  }
  enterChild(t, e, i) {
    if (!this.buffer)
      return this.yield(this._tree.nextChild(t < 0 ? this._tree._tree.children.length - 1 : 0, t, e, i, this.mode));
    let { buffer: n } = this.buffer, r = n.findChild(this.index + 4, n.buffer[this.index + 3], t, e - this.buffer.start, i);
    return r < 0 ? !1 : (this.stack.push(this.index), this.yieldBuf(r));
  }
  firstChild() {
    return this.enterChild(1, 0, 4);
  }
  lastChild() {
    return this.enterChild(-1, 0, 4);
  }
  childAfter(t) {
    return this.enterChild(1, t, 2);
  }
  childBefore(t) {
    return this.enterChild(-1, t, -2);
  }
  enter(t, e, i = this.mode) {
    return this.buffer ? i & st.ExcludeBuffers ? !1 : this.enterChild(1, t, e) : this.yield(this._tree.enter(t, e, i));
  }
  parent() {
    if (!this.buffer)
      return this.yieldNode(this.mode & st.IncludeAnonymous ? this._tree._parent : this._tree.parent);
    if (this.stack.length)
      return this.yieldBuf(this.stack.pop());
    let t = this.mode & st.IncludeAnonymous ? this.buffer.parent : this.buffer.parent.nextSignificantParent();
    return this.buffer = null, this.yieldNode(t);
  }
  sibling(t) {
    if (!this.buffer)
      return this._tree._parent ? this.yield(this._tree.index < 0 ? null : this._tree._parent.nextChild(this._tree.index + t, t, 0, 4, this.mode)) : !1;
    let { buffer: e } = this.buffer, i = this.stack.length - 1;
    if (t < 0) {
      let n = i < 0 ? 0 : this.stack[i] + 4;
      if (this.index != n)
        return this.yieldBuf(e.findChild(n, this.index, -1, 0, 4));
    } else {
      let n = e.buffer[this.index + 3];
      if (n < (i < 0 ? e.buffer.length : e.buffer[this.stack[i] + 3]))
        return this.yieldBuf(n);
    }
    return i < 0 ? this.yield(this.buffer.parent.nextChild(this.buffer.index + t, t, 0, 4, this.mode)) : !1;
  }
  nextSibling() {
    return this.sibling(1);
  }
  prevSibling() {
    return this.sibling(-1);
  }
  atLastNode(t) {
    let e, i, { buffer: n } = this;
    if (n) {
      if (t > 0) {
        if (this.index < n.buffer.buffer.length)
          return !1;
      } else
        for (let r = 0; r < this.index; r++)
          if (n.buffer.buffer[r + 3] < this.index)
            return !1;
      ({ index: e, parent: i } = n);
    } else
      ({ index: e, _parent: i } = this._tree);
    for (; i; { index: e, _parent: i } = i)
      if (e > -1)
        for (let r = e + t, o = t < 0 ? -1 : i._tree.children.length; r != o; r += t) {
          let l = i._tree.children[r];
          if (this.mode & st.IncludeAnonymous || l instanceof Re || !l.type.isAnonymous || Xs(l))
            return !1;
        }
    return !0;
  }
  move(t, e) {
    if (e && this.enterChild(t, 0, 4))
      return !0;
    for (; ; ) {
      if (this.sibling(t))
        return !0;
      if (this.atLastNode(t) || !this.parent())
        return !1;
    }
  }
  next(t = !0) {
    return this.move(1, t);
  }
  prev(t = !0) {
    return this.move(-1, t);
  }
  moveTo(t, e = 0) {
    for (; (this.from == this.to || (e < 1 ? this.from >= t : this.from > t) || (e > -1 ? this.to <= t : this.to < t)) && this.parent(); )
      ;
    for (; this.enterChild(1, t, e); )
      ;
    return this;
  }
  get node() {
    if (!this.buffer)
      return this._tree;
    let t = this.bufferNode, e = null, i = 0;
    if (t && t.context == this.buffer) {
      t:
        for (let n = this.index, r = this.stack.length; r >= 0; ) {
          for (let o = t; o; o = o._parent)
            if (o.index == n) {
              if (n == this.index)
                return o;
              e = o, i = r + 1;
              break t;
            }
          n = this.stack[--r];
        }
    }
    for (let n = i; n < this.stack.length; n++)
      e = new ce(this.buffer, e, this.stack[n]);
    return this.bufferNode = new ce(this.buffer, e, this.index);
  }
  get tree() {
    return this.buffer ? null : this._tree._tree;
  }
  iterate(t, e) {
    for (let i = 0; ; ) {
      let n = !1;
      if (this.type.isAnonymous || t(this) !== !1) {
        if (this.firstChild()) {
          i++;
          continue;
        }
        this.type.isAnonymous || (n = !0);
      }
      for (; n && e && e(this), n = this.type.isAnonymous, !this.nextSibling(); ) {
        if (!i)
          return;
        this.parent(), i--, n = !0;
      }
    }
  }
  matchContext(t) {
    if (!this.buffer)
      return hn(this.node, t);
    let { buffer: e } = this.buffer, { types: i } = e.set;
    for (let n = t.length - 1, r = this.stack.length - 1; n >= 0; r--) {
      if (r < 0)
        return hn(this.node, t, n);
      let o = i[e.buffer[this.stack[r]]];
      if (!o.isAnonymous) {
        if (t[n] && t[n] != o.name)
          return !1;
        n--;
      }
    }
    return !0;
  }
}
function Xs(s) {
  return s.children.some((t) => t instanceof Re || !t.type.isAnonymous || Xs(t));
}
function Qu(s) {
  var t;
  let { buffer: e, nodeSet: i, maxBufferLength: n = sh, reused: r = [], minRepeatType: o = i.types.length } = s, l = Array.isArray(e) ? new Js(e, e.length) : e, h = i.types, a = 0, c = 0;
  function f(C, L, M, N, et) {
    let { id: V, start: R, end: G, size: dt } = l, Ot = c;
    for (; dt < 0; )
      if (l.next(), dt == -1) {
        let ie = r[V];
        M.push(ie), N.push(R - C);
        return;
      } else if (dt == -3) {
        a = V;
        return;
      } else if (dt == -4) {
        c = V;
        return;
      } else
        throw new RangeError(`Unrecognized record size: ${dt}`);
    let Le = h[V], ee, Gt, lr = R - C;
    if (G - R <= n && (Gt = w(l.pos - L, et))) {
      let ie = new Uint16Array(Gt.size - Gt.skip), Mt = l.pos - Gt.size, Kt = ie.length;
      for (; l.pos > Mt; )
        Kt = g(Gt.start, ie, Kt);
      ee = new Re(ie, G - Gt.start, i), lr = Gt.start - C;
    } else {
      let ie = l.pos - dt;
      l.next();
      let Mt = [], Kt = [], ke = V >= o ? V : -1, Ee = 0, Si = G;
      for (; l.pos > ie; )
        ke >= 0 && l.id == ke && l.size >= 0 ? (l.end <= Si - n && (d(Mt, Kt, R, Ee, l.end, Si, ke, Ot), Ee = Mt.length, Si = l.end), l.next()) : f(R, ie, Mt, Kt, ke);
      if (ke >= 0 && Ee > 0 && Ee < Mt.length && d(Mt, Kt, R, Ee, R, Si, ke, Ot), Mt.reverse(), Kt.reverse(), ke > -1 && Ee > 0) {
        let hr = u(Le);
        ee = Ys(Le, Mt, Kt, 0, Mt.length, 0, G - R, hr, hr);
      } else
        ee = p(Le, Mt, Kt, G - R, Ot - G);
    }
    M.push(ee), N.push(lr);
  }
  function u(C) {
    return (L, M, N) => {
      let et = 0, V = L.length - 1, R, G;
      if (V >= 0 && (R = L[V]) instanceof J) {
        if (!V && R.type == C && R.length == N)
          return R;
        (G = R.prop(P.lookAhead)) && (et = M[V] + R.length + G);
      }
      return p(C, L, M, N, et);
    };
  }
  function d(C, L, M, N, et, V, R, G) {
    let dt = [], Ot = [];
    for (; C.length > N; )
      dt.push(C.pop()), Ot.push(L.pop() + M - et);
    C.push(p(i.types[R], dt, Ot, V - et, G - V)), L.push(et - M);
  }
  function p(C, L, M, N, et = 0, V) {
    if (a) {
      let R = [P.contextHash, a];
      V = V ? [R].concat(V) : [R];
    }
    if (et > 25) {
      let R = [P.lookAhead, et];
      V = V ? [R].concat(V) : [R];
    }
    return new J(C, L, M, N, V);
  }
  function w(C, L) {
    let M = l.fork(), N = 0, et = 0, V = 0, R = M.end - n, G = { size: 0, start: 0, skip: 0 };
    t:
      for (let dt = M.pos - C; M.pos > dt; ) {
        let Ot = M.size;
        if (M.id == L && Ot >= 0) {
          G.size = N, G.start = et, G.skip = V, V += 4, N += 4, M.next();
          continue;
        }
        let Le = M.pos - Ot;
        if (Ot < 0 || Le < dt || M.start < R)
          break;
        let ee = M.id >= o ? 4 : 0, Gt = M.start;
        for (M.next(); M.pos > Le; ) {
          if (M.size < 0)
            if (M.size == -3)
              ee += 4;
            else
              break t;
          else
            M.id >= o && (ee += 4);
          M.next();
        }
        et = Gt, N += Ot, V += ee;
      }
    return (L < 0 || N == C) && (G.size = N, G.start = et, G.skip = V), G.size > 4 ? G : void 0;
  }
  function g(C, L, M) {
    let { id: N, start: et, end: V, size: R } = l;
    if (l.next(), R >= 0 && N < o) {
      let G = M;
      if (R > 4) {
        let dt = l.pos - (R - 4);
        for (; l.pos > dt; )
          M = g(C, L, M);
      }
      L[--M] = G, L[--M] = V - C, L[--M] = et - C, L[--M] = N;
    } else
      R == -3 ? a = N : R == -4 && (c = N);
    return M;
  }
  let y = [], O = [];
  for (; l.pos > 0; )
    f(s.start || 0, s.bufferStart || 0, y, O, -1);
  let T = (t = s.length) !== null && t !== void 0 ? t : y.length ? O[0] + y[0].length : 0;
  return new J(h[s.topID], y.reverse(), O.reverse(), T);
}
const lo = /* @__PURE__ */ new WeakMap();
function Gi(s, t) {
  if (!s.isAnonymous || t instanceof Re || t.type != s)
    return 1;
  let e = lo.get(t);
  if (e == null) {
    e = 1;
    for (let i of t.children) {
      if (i.type != s || !(i instanceof J)) {
        e = 1;
        break;
      }
      e += Gi(s, i);
    }
    lo.set(t, e);
  }
  return e;
}
function Ys(s, t, e, i, n, r, o, l, h) {
  let a = 0;
  for (let p = i; p < n; p++)
    a += Gi(s, t[p]);
  let c = Math.ceil(a * 1.5 / 8), f = [], u = [];
  function d(p, w, g, y, O) {
    for (let T = g; T < y; ) {
      let C = T, L = w[T], M = Gi(s, p[T]);
      for (T++; T < y; T++) {
        let N = Gi(s, p[T]);
        if (M + N >= c)
          break;
        M += N;
      }
      if (T == C + 1) {
        if (M > c) {
          let N = p[C];
          d(N.children, N.positions, 0, N.children.length, w[C] + O);
          continue;
        }
        f.push(p[C]);
      } else {
        let N = w[T - 1] + p[T - 1].length - L;
        f.push(Ys(s, p, w, C, T, L, N, null, h));
      }
      u.push(L + O - r);
    }
  }
  return d(t, e, i, n, 0), (l || h)(f, u, o);
}
class Oe {
  constructor(t, e, i, n, r = !1, o = !1) {
    this.from = t, this.to = e, this.tree = i, this.offset = n, this.open = (r ? 1 : 0) | (o ? 2 : 0);
  }
  get openStart() {
    return (this.open & 1) > 0;
  }
  get openEnd() {
    return (this.open & 2) > 0;
  }
  static addTree(t, e = [], i = !1) {
    let n = [new Oe(0, t.length, t, 0, !1, i)];
    for (let r of e)
      r.to > t.length && n.push(r);
    return n;
  }
  static applyChanges(t, e, i = 128) {
    if (!e.length)
      return t;
    let n = [], r = 1, o = t.length ? t[0] : null;
    for (let l = 0, h = 0, a = 0; ; l++) {
      let c = l < e.length ? e[l] : null, f = c ? c.fromA : 1e9;
      if (f - h >= i)
        for (; o && o.from < f; ) {
          let u = o;
          if (h >= u.from || f <= u.to || a) {
            let d = Math.max(u.from, h) - a, p = Math.min(u.to, f) - a;
            u = d >= p ? null : new Oe(d, p, u.tree, u.offset + a, l > 0, !!c);
          }
          if (u && n.push(u), o.to > f)
            break;
          o = r < t.length ? t[r++] : null;
        }
      if (!c)
        break;
      h = c.toA, a = c.toA - c.toB;
    }
    return n;
  }
}
class lh {
  startParse(t, e, i) {
    return typeof t == "string" && (t = new Ju(t)), i = i ? i.length ? i.map((n) => new qn(n.from, n.to)) : [new qn(0, 0)] : [new qn(0, t.length)], this.createParse(t, e || [], i);
  }
  parse(t, e, i) {
    let n = this.startParse(t, e, i);
    for (; ; ) {
      let r = n.advance();
      if (r)
        return r;
    }
  }
}
class Ju {
  constructor(t) {
    this.string = t;
  }
  get length() {
    return this.string.length;
  }
  chunk(t) {
    return this.string.slice(t);
  }
  get lineChunks() {
    return !1;
  }
  read(t, e) {
    return this.string.slice(t, e);
  }
}
new P({ perNode: !0 });
let Xu = 0;
class It {
  constructor(t, e, i) {
    this.set = t, this.base = e, this.modified = i, this.id = Xu++;
  }
  static define(t) {
    if (t != null && t.base)
      throw new Error("Can not derive from a modified tag");
    let e = new It([], null, []);
    if (e.set.push(e), t)
      for (let i of t.set)
        e.set.push(i);
    return e;
  }
  static defineModifier() {
    let t = new cn();
    return (e) => e.modified.indexOf(t) > -1 ? e : cn.get(e.base || e, e.modified.concat(t).sort((i, n) => i.id - n.id));
  }
}
let Yu = 0;
class cn {
  constructor() {
    this.instances = [], this.id = Yu++;
  }
  static get(t, e) {
    if (!e.length)
      return t;
    let i = e[0].instances.find((l) => l.base == t && Zu(e, l.modified));
    if (i)
      return i;
    let n = [], r = new It(n, t, e);
    for (let l of e)
      l.instances.push(r);
    let o = hh(e);
    for (let l of t.set)
      for (let h of o)
        n.push(cn.get(l, h));
    return r;
  }
}
function Zu(s, t) {
  return s.length == t.length && s.every((e, i) => e == t[i]);
}
function hh(s) {
  let t = [s];
  for (let e = 0; e < s.length; e++)
    for (let i of hh(s.slice(0, e).concat(s.slice(e + 1))))
      t.push(i);
  return t;
}
function ah(s) {
  let t = /* @__PURE__ */ Object.create(null);
  for (let e in s) {
    let i = s[e];
    Array.isArray(i) || (i = [i]);
    for (let n of e.split(" "))
      if (n) {
        let r = [], o = 2, l = n;
        for (let f = 0; ; ) {
          if (l == "..." && f > 0 && f + 3 == n.length) {
            o = 1;
            break;
          }
          let u = /^"(?:[^"\\]|\\.)*?"|[^\/!]+/.exec(l);
          if (!u)
            throw new RangeError("Invalid path: " + n);
          if (r.push(u[0] == "*" ? "" : u[0][0] == '"' ? JSON.parse(u[0]) : u[0]), f += u[0].length, f == n.length)
            break;
          let d = n[f++];
          if (f == n.length && d == "!") {
            o = 0;
            break;
          }
          if (d != "/")
            throw new RangeError("Invalid path: " + n);
          l = n.slice(f);
        }
        let h = r.length - 1, a = r[h];
        if (!a)
          throw new RangeError("Invalid path: " + n);
        let c = new fn(i, o, h > 0 ? r.slice(0, h) : null);
        t[a] = c.sort(t[a]);
      }
  }
  return ch.add(t);
}
const ch = new P();
class fn {
  constructor(t, e, i, n) {
    this.tags = t, this.mode = e, this.context = i, this.next = n;
  }
  get opaque() {
    return this.mode == 0;
  }
  get inherit() {
    return this.mode == 1;
  }
  sort(t) {
    return !t || t.depth < this.depth ? (this.next = t, this) : (t.next = this.sort(t.next), t);
  }
  get depth() {
    return this.context ? this.context.length : 0;
  }
}
fn.empty = new fn([], 2, null);
function fh(s, t) {
  let e = /* @__PURE__ */ Object.create(null);
  for (let r of s)
    if (!Array.isArray(r.tag))
      e[r.tag.id] = r.class;
    else
      for (let o of r.tag)
        e[o.id] = r.class;
  let { scope: i, all: n = null } = t || {};
  return {
    style: (r) => {
      let o = n;
      for (let l of r)
        for (let h of l.set) {
          let a = e[h.id];
          if (a) {
            o = o ? o + " " + a : a;
            break;
          }
        }
      return o;
    },
    scope: i
  };
}
function td(s, t) {
  let e = null;
  for (let i of s) {
    let n = i.style(t);
    n && (e = e ? e + " " + n : n);
  }
  return e;
}
function ed(s, t, e, i = 0, n = s.length) {
  let r = new id(i, Array.isArray(t) ? t : [t], e);
  r.highlightRange(s.cursor(), i, n, "", r.highlighters), r.flush(n);
}
class id {
  constructor(t, e, i) {
    this.at = t, this.highlighters = e, this.span = i, this.class = "";
  }
  startSpan(t, e) {
    e != this.class && (this.flush(t), t > this.at && (this.at = t), this.class = e);
  }
  flush(t) {
    t > this.at && this.class && this.span(this.at, t, this.class);
  }
  highlightRange(t, e, i, n, r) {
    let { type: o, from: l, to: h } = t;
    if (l >= i || h <= e)
      return;
    o.isTop && (r = this.highlighters.filter((d) => !d.scope || d.scope(o)));
    let a = n, c = nd(t) || fn.empty, f = td(r, c.tags);
    if (f && (a && (a += " "), a += f, c.mode == 1 && (n += (n ? " " : "") + f)), this.startSpan(t.from, a), c.opaque)
      return;
    let u = t.tree && t.tree.prop(P.mounted);
    if (u && u.overlay) {
      let d = t.node.enter(u.overlay[0].from + l, 1), p = this.highlighters.filter((g) => !g.scope || g.scope(u.tree.type)), w = t.firstChild();
      for (let g = 0, y = l; ; g++) {
        let O = g < u.overlay.length ? u.overlay[g] : null, T = O ? O.from + l : h, C = Math.max(e, y), L = Math.min(i, T);
        if (C < L && w)
          for (; t.from < L && (this.highlightRange(t, C, L, n, r), this.startSpan(Math.min(i, t.to), a), !(t.to >= T || !t.nextSibling())); )
            ;
        if (!O || T > i)
          break;
        y = O.to + l, y > e && (this.highlightRange(d.cursor(), Math.max(e, O.from + l), Math.min(i, y), n, p), this.startSpan(y, a));
      }
      w && t.parent();
    } else if (t.firstChild()) {
      do
        if (!(t.to <= e)) {
          if (t.from >= i)
            break;
          this.highlightRange(t, e, i, n, r), this.startSpan(Math.min(i, t.to), a);
        }
      while (t.nextSibling());
      t.parent();
    }
  }
}
function nd(s) {
  let t = s.type.prop(ch);
  for (; t && t.context && !s.matchContext(t.context); )
    t = t.next;
  return t || null;
}
const b = It.define, Ei = b(), ne = b(), ho = b(ne), ao = b(ne), se = b(), Ni = b(se), Gn = b(se), Vt = b(), xe = b(Vt), Et = b(), Nt = b(), Ls = b(), Ze = b(Ls), Vi = b(), m = {
  comment: Ei,
  lineComment: b(Ei),
  blockComment: b(Ei),
  docComment: b(Ei),
  name: ne,
  variableName: b(ne),
  typeName: ho,
  tagName: b(ho),
  propertyName: ao,
  attributeName: b(ao),
  className: b(ne),
  labelName: b(ne),
  namespace: b(ne),
  macroName: b(ne),
  literal: se,
  string: Ni,
  docString: b(Ni),
  character: b(Ni),
  attributeValue: b(Ni),
  number: Gn,
  integer: b(Gn),
  float: b(Gn),
  bool: b(se),
  regexp: b(se),
  escape: b(se),
  color: b(se),
  url: b(se),
  keyword: Et,
  self: b(Et),
  null: b(Et),
  atom: b(Et),
  unit: b(Et),
  modifier: b(Et),
  operatorKeyword: b(Et),
  controlKeyword: b(Et),
  definitionKeyword: b(Et),
  moduleKeyword: b(Et),
  operator: Nt,
  derefOperator: b(Nt),
  arithmeticOperator: b(Nt),
  logicOperator: b(Nt),
  bitwiseOperator: b(Nt),
  compareOperator: b(Nt),
  updateOperator: b(Nt),
  definitionOperator: b(Nt),
  typeOperator: b(Nt),
  controlOperator: b(Nt),
  punctuation: Ls,
  separator: b(Ls),
  bracket: Ze,
  angleBracket: b(Ze),
  squareBracket: b(Ze),
  paren: b(Ze),
  brace: b(Ze),
  content: Vt,
  heading: xe,
  heading1: b(xe),
  heading2: b(xe),
  heading3: b(xe),
  heading4: b(xe),
  heading5: b(xe),
  heading6: b(xe),
  contentSeparator: b(Vt),
  list: b(Vt),
  quote: b(Vt),
  emphasis: b(Vt),
  strong: b(Vt),
  link: b(Vt),
  monospace: b(Vt),
  strikethrough: b(Vt),
  inserted: b(),
  deleted: b(),
  changed: b(),
  invalid: b(),
  meta: Vi,
  documentMeta: b(Vi),
  annotation: b(Vi),
  processingInstruction: b(Vi),
  definition: It.defineModifier(),
  constant: It.defineModifier(),
  function: It.defineModifier(),
  standard: It.defineModifier(),
  local: It.defineModifier(),
  special: It.defineModifier()
};
fh([
  { tag: m.link, class: "tok-link" },
  { tag: m.heading, class: "tok-heading" },
  { tag: m.emphasis, class: "tok-emphasis" },
  { tag: m.strong, class: "tok-strong" },
  { tag: m.keyword, class: "tok-keyword" },
  { tag: m.atom, class: "tok-atom" },
  { tag: m.bool, class: "tok-bool" },
  { tag: m.url, class: "tok-url" },
  { tag: m.labelName, class: "tok-labelName" },
  { tag: m.inserted, class: "tok-inserted" },
  { tag: m.deleted, class: "tok-deleted" },
  { tag: m.literal, class: "tok-literal" },
  { tag: m.string, class: "tok-string" },
  { tag: m.number, class: "tok-number" },
  { tag: [m.regexp, m.escape, m.special(m.string)], class: "tok-string2" },
  { tag: m.variableName, class: "tok-variableName" },
  { tag: m.local(m.variableName), class: "tok-variableName tok-local" },
  { tag: m.definition(m.variableName), class: "tok-variableName tok-definition" },
  { tag: m.special(m.variableName), class: "tok-variableName2" },
  { tag: m.definition(m.propertyName), class: "tok-propertyName tok-definition" },
  { tag: m.typeName, class: "tok-typeName" },
  { tag: m.namespace, class: "tok-namespace" },
  { tag: m.className, class: "tok-className" },
  { tag: m.macroName, class: "tok-macroName" },
  { tag: m.propertyName, class: "tok-propertyName" },
  { tag: m.operator, class: "tok-operator" },
  { tag: m.comment, class: "tok-comment" },
  { tag: m.meta, class: "tok-meta" },
  { tag: m.invalid, class: "tok-invalid" },
  { tag: m.punctuation, class: "tok-punctuation" }
]);
var Kn;
const mi = /* @__PURE__ */ new P();
function sd(s) {
  return v.define({
    combine: s ? (t) => t.concat(s) : void 0
  });
}
class Tt {
  constructor(t, e, i = []) {
    this.data = t, E.prototype.hasOwnProperty("tree") || Object.defineProperty(E.prototype, "tree", { get() {
      return St(this);
    } }), this.parser = e, this.extension = [
      we.of(this),
      E.languageData.of((n, r, o) => n.facet(co(n, r, o)))
    ].concat(i);
  }
  isActiveAt(t, e, i = -1) {
    return co(t, e, i) == this.data;
  }
  findRegions(t) {
    let e = t.facet(we);
    if ((e == null ? void 0 : e.data) == this.data)
      return [{ from: 0, to: t.doc.length }];
    if (!e || !e.allowsNesting)
      return [];
    let i = [], n = (r, o) => {
      if (r.prop(mi) == this.data) {
        i.push({ from: o, to: o + r.length });
        return;
      }
      let l = r.prop(P.mounted);
      if (l) {
        if (l.tree.prop(mi) == this.data) {
          if (l.overlay)
            for (let h of l.overlay)
              i.push({ from: h.from + o, to: h.to + o });
          else
            i.push({ from: o, to: o + r.length });
          return;
        } else if (l.overlay) {
          let h = i.length;
          if (n(l.tree, l.overlay[0].from + o), i.length > h)
            return;
        }
      }
      for (let h = 0; h < r.children.length; h++) {
        let a = r.children[h];
        a instanceof J && n(a, r.positions[h] + o);
      }
    };
    return n(St(t), 0), i;
  }
  get allowsNesting() {
    return !0;
  }
}
Tt.setState = /* @__PURE__ */ F.define();
function co(s, t, e) {
  let i = s.facet(we);
  if (!i)
    return null;
  let n = i.data;
  if (i.allowsNesting)
    for (let r = St(s).topNode; r; r = r.enter(t, e, st.ExcludeBuffers))
      n = r.type.prop(mi) || n;
  return n;
}
class un extends Tt {
  constructor(t, e) {
    super(t, e), this.parser = e;
  }
  static define(t) {
    let e = sd(t.languageData);
    return new un(e, t.parser.configure({
      props: [mi.add((i) => i.isTop ? e : void 0)]
    }));
  }
  configure(t) {
    return new un(this.data, this.parser.configure(t));
  }
  get allowsNesting() {
    return this.parser.hasWrappers();
  }
}
function St(s) {
  let t = s.field(Tt.state, !1);
  return t ? t.tree : J.empty;
}
class rd {
  constructor(t, e = t.length) {
    this.doc = t, this.length = e, this.cursorPos = 0, this.string = "", this.cursor = t.iter();
  }
  syncTo(t) {
    return this.string = this.cursor.next(t - this.cursorPos).value, this.cursorPos = t + this.string.length, this.cursorPos - this.string.length;
  }
  chunk(t) {
    return this.syncTo(t), this.string;
  }
  get lineChunks() {
    return !0;
  }
  read(t, e) {
    let i = this.cursorPos - this.string.length;
    return t < i || e >= this.cursorPos ? this.doc.sliceString(t, e) : this.string.slice(t - i, e - i);
  }
}
let ti = null;
class dn {
  constructor(t, e, i = [], n, r, o, l, h) {
    this.parser = t, this.state = e, this.fragments = i, this.tree = n, this.treeLen = r, this.viewport = o, this.skipped = l, this.scheduleOn = h, this.parse = null, this.tempSkipped = [];
  }
  static create(t, e, i) {
    return new dn(t, e, [], J.empty, 0, i, [], null);
  }
  startParse() {
    return this.parser.startParse(new rd(this.state.doc), this.fragments);
  }
  work(t, e) {
    return e != null && e >= this.state.doc.length && (e = void 0), this.tree != J.empty && this.isDone(e != null ? e : this.state.doc.length) ? (this.takeTree(), !0) : this.withContext(() => {
      var i;
      if (typeof t == "number") {
        let n = Date.now() + t;
        t = () => Date.now() > n;
      }
      for (this.parse || (this.parse = this.startParse()), e != null && (this.parse.stoppedAt == null || this.parse.stoppedAt > e) && e < this.state.doc.length && this.parse.stopAt(e); ; ) {
        let n = this.parse.advance();
        if (n)
          if (this.fragments = this.withoutTempSkipped(Oe.addTree(n, this.fragments, this.parse.stoppedAt != null)), this.treeLen = (i = this.parse.stoppedAt) !== null && i !== void 0 ? i : this.state.doc.length, this.tree = n, this.parse = null, this.treeLen < (e != null ? e : this.state.doc.length))
            this.parse = this.startParse();
          else
            return !0;
        if (t())
          return !1;
      }
    });
  }
  takeTree() {
    let t, e;
    this.parse && (t = this.parse.parsedPos) >= this.treeLen && ((this.parse.stoppedAt == null || this.parse.stoppedAt > t) && this.parse.stopAt(t), this.withContext(() => {
      for (; !(e = this.parse.advance()); )
        ;
    }), this.treeLen = t, this.tree = e, this.fragments = this.withoutTempSkipped(Oe.addTree(this.tree, this.fragments, !0)), this.parse = null);
  }
  withContext(t) {
    let e = ti;
    ti = this;
    try {
      return t();
    } finally {
      ti = e;
    }
  }
  withoutTempSkipped(t) {
    for (let e; e = this.tempSkipped.pop(); )
      t = fo(t, e.from, e.to);
    return t;
  }
  changes(t, e) {
    let { fragments: i, tree: n, treeLen: r, viewport: o, skipped: l } = this;
    if (this.takeTree(), !t.empty) {
      let h = [];
      if (t.iterChangedRanges((a, c, f, u) => h.push({ fromA: a, toA: c, fromB: f, toB: u })), i = Oe.applyChanges(i, h), n = J.empty, r = 0, o = { from: t.mapPos(o.from, -1), to: t.mapPos(o.to, 1) }, this.skipped.length) {
        l = [];
        for (let a of this.skipped) {
          let c = t.mapPos(a.from, 1), f = t.mapPos(a.to, -1);
          c < f && l.push({ from: c, to: f });
        }
      }
    }
    return new dn(this.parser, e, i, n, r, o, l, this.scheduleOn);
  }
  updateViewport(t) {
    if (this.viewport.from == t.from && this.viewport.to == t.to)
      return !1;
    this.viewport = t;
    let e = this.skipped.length;
    for (let i = 0; i < this.skipped.length; i++) {
      let { from: n, to: r } = this.skipped[i];
      n < t.to && r > t.from && (this.fragments = fo(this.fragments, n, r), this.skipped.splice(i--, 1));
    }
    return this.skipped.length >= e ? !1 : (this.reset(), !0);
  }
  reset() {
    this.parse && (this.takeTree(), this.parse = null);
  }
  skipUntilInView(t, e) {
    this.skipped.push({ from: t, to: e });
  }
  static getSkippingParser(t) {
    return new class extends lh {
      createParse(e, i, n) {
        let r = n[0].from, o = n[n.length - 1].to;
        return {
          parsedPos: r,
          advance() {
            let h = ti;
            if (h) {
              for (let a of n)
                h.tempSkipped.push(a);
              t && (h.scheduleOn = h.scheduleOn ? Promise.all([h.scheduleOn, t]) : t);
            }
            return this.parsedPos = o, new J(yt.none, [], [], o - r);
          },
          stoppedAt: null,
          stopAt() {
          }
        };
      }
    }();
  }
  isDone(t) {
    t = Math.min(t, this.state.doc.length);
    let e = this.fragments;
    return this.treeLen >= t && e.length && e[0].from == 0 && e[0].to >= t;
  }
  static get() {
    return ti;
  }
}
function fo(s, t, e) {
  return Oe.applyChanges(s, [{ fromA: t, toA: e, fromB: t, toB: e }]);
}
class Ke {
  constructor(t) {
    this.context = t, this.tree = t.tree;
  }
  apply(t) {
    if (!t.docChanged && this.tree == this.context.tree)
      return this;
    let e = this.context.changes(t.changes, t.state), i = this.context.treeLen == t.startState.doc.length ? void 0 : Math.max(t.changes.mapPos(this.context.treeLen), e.viewport.to);
    return e.work(20, i) || e.takeTree(), new Ke(e);
  }
  static init(t) {
    let e = Math.min(3e3, t.doc.length), i = dn.create(t.facet(we).parser, t, { from: 0, to: e });
    return i.work(20, e) || i.takeTree(), new Ke(i);
  }
}
Tt.state = /* @__PURE__ */ Bt.define({
  create: Ke.init,
  update(s, t) {
    for (let e of t.effects)
      if (e.is(Tt.setState))
        return e.value;
    return t.startState.facet(we) != t.state.facet(we) ? Ke.init(t.state) : s.apply(t);
  }
});
let uh = (s) => {
  let t = setTimeout(() => s(), 500);
  return () => clearTimeout(t);
};
typeof requestIdleCallback < "u" && (uh = (s) => {
  let t = -1, e = setTimeout(() => {
    t = requestIdleCallback(s, { timeout: 500 - 100 });
  }, 100);
  return () => t < 0 ? clearTimeout(e) : cancelIdleCallback(t);
});
const Un = typeof navigator < "u" && ((Kn = navigator.scheduling) === null || Kn === void 0 ? void 0 : Kn.isInputPending) ? () => navigator.scheduling.isInputPending() : null, od = /* @__PURE__ */ wt.fromClass(class {
  constructor(t) {
    this.view = t, this.working = null, this.workScheduled = 0, this.chunkEnd = -1, this.chunkBudget = -1, this.work = this.work.bind(this), this.scheduleWork();
  }
  update(t) {
    let e = this.view.state.field(Tt.state).context;
    (e.updateViewport(t.view.viewport) || this.view.viewport.to > e.treeLen) && this.scheduleWork(), t.docChanged && (this.view.hasFocus && (this.chunkBudget += 50), this.scheduleWork()), this.checkAsyncSchedule(e);
  }
  scheduleWork() {
    if (this.working)
      return;
    let { state: t } = this.view, e = t.field(Tt.state);
    (e.tree != e.context.tree || !e.context.isDone(t.doc.length)) && (this.working = uh(this.work));
  }
  work(t) {
    this.working = null;
    let e = Date.now();
    if (this.chunkEnd < e && (this.chunkEnd < 0 || this.view.hasFocus) && (this.chunkEnd = e + 3e4, this.chunkBudget = 3e3), this.chunkBudget <= 0)
      return;
    let { state: i, viewport: { to: n } } = this.view, r = i.field(Tt.state);
    if (r.tree == r.context.tree && r.context.isDone(n + 1e5))
      return;
    let o = Date.now() + Math.min(this.chunkBudget, 100, t && !Un ? Math.max(25, t.timeRemaining() - 5) : 1e9), l = r.context.treeLen < n && i.doc.length > n + 1e3, h = r.context.work(() => Un && Un() || Date.now() > o, n + (l ? 0 : 1e5));
    this.chunkBudget -= Date.now() - e, (h || this.chunkBudget <= 0) && (r.context.takeTree(), this.view.dispatch({ effects: Tt.setState.of(new Ke(r.context)) })), this.chunkBudget > 0 && !(h && !l) && this.scheduleWork(), this.checkAsyncSchedule(r.context);
  }
  checkAsyncSchedule(t) {
    t.scheduleOn && (this.workScheduled++, t.scheduleOn.then(() => this.scheduleWork()).catch((e) => zt(this.view.state, e)).then(() => this.workScheduled--), t.scheduleOn = null);
  }
  destroy() {
    this.working && this.working();
  }
  isWorking() {
    return !!(this.working || this.workScheduled > 0);
  }
}, {
  eventHandlers: { focus() {
    this.scheduleWork();
  } }
}), we = /* @__PURE__ */ v.define({
  combine(s) {
    return s.length ? s[0] : null;
  },
  enables: [Tt.state, od]
});
class ld {
  constructor(t, e = []) {
    this.language = t, this.support = e, this.extension = [t, e];
  }
}
const hd = /* @__PURE__ */ v.define(), Zs = /* @__PURE__ */ v.define({
  combine: (s) => {
    if (!s.length)
      return "  ";
    if (!/^(?: +|\t+)$/.test(s[0]))
      throw new Error("Invalid indent unit: " + JSON.stringify(s[0]));
    return s[0];
  }
});
function pn(s) {
  let t = s.facet(Zs);
  return t.charCodeAt(0) == 9 ? s.tabSize * t.length : t.length;
}
function wi(s, t) {
  let e = "", i = s.tabSize;
  if (s.facet(Zs).charCodeAt(0) == 9)
    for (; t >= i; )
      e += "	", t -= i;
  for (let n = 0; n < t; n++)
    e += " ";
  return e;
}
function tr(s, t) {
  s instanceof E && (s = new Mn(s));
  for (let i of s.state.facet(hd)) {
    let n = i(s, t);
    if (n != null)
      return n;
  }
  let e = St(s.state);
  return e ? ad(s, e, t) : null;
}
class Mn {
  constructor(t, e = {}) {
    this.state = t, this.options = e, this.unit = pn(t);
  }
  lineAt(t, e = 1) {
    let i = this.state.doc.lineAt(t), { simulateBreak: n, simulateDoubleBreak: r } = this.options;
    return n != null && n >= i.from && n <= i.to ? r && n == t ? { text: "", from: t } : (e < 0 ? n < t : n <= t) ? { text: i.text.slice(n - i.from), from: n } : { text: i.text.slice(0, n - i.from), from: i.from } : i;
  }
  textAfterPos(t, e = 1) {
    if (this.options.simulateDoubleBreak && t == this.options.simulateBreak)
      return "";
    let { text: i, from: n } = this.lineAt(t, e);
    return i.slice(t - n, Math.min(i.length, t + 100 - n));
  }
  column(t, e = 1) {
    let { text: i, from: n } = this.lineAt(t, e), r = this.countColumn(i, t - n), o = this.options.overrideIndentation ? this.options.overrideIndentation(n) : -1;
    return o > -1 && (r += o - this.countColumn(i, i.search(/\S|$/))), r;
  }
  countColumn(t, e = t.length) {
    return vn(t, this.state.tabSize, e);
  }
  lineIndent(t, e = 1) {
    let { text: i, from: n } = this.lineAt(t, e), r = this.options.overrideIndentation;
    if (r) {
      let o = r(n);
      if (o > -1)
        return o;
    }
    return this.countColumn(i, i.search(/\S|$/));
  }
  get simulatedBreak() {
    return this.options.simulateBreak || null;
  }
}
const dh = /* @__PURE__ */ new P();
function ad(s, t, e) {
  return ph(t.resolveInner(e).enterUnfinishedNodesBefore(e), e, s);
}
function cd(s) {
  return s.pos == s.options.simulateBreak && s.options.simulateDoubleBreak;
}
function fd(s) {
  let t = s.type.prop(dh);
  if (t)
    return t;
  let e = s.firstChild, i;
  if (e && (i = e.type.prop(P.closedBy))) {
    let n = s.lastChild, r = n && i.indexOf(n.name) > -1;
    return (o) => gd(o, !0, 1, void 0, r && !cd(o) ? n.from : void 0);
  }
  return s.parent == null ? ud : null;
}
function ph(s, t, e) {
  for (; s; s = s.parent) {
    let i = fd(s);
    if (i)
      return i(er.create(e, t, s));
  }
  return null;
}
function ud() {
  return 0;
}
class er extends Mn {
  constructor(t, e, i) {
    super(t.state, t.options), this.base = t, this.pos = e, this.node = i;
  }
  static create(t, e, i) {
    return new er(t, e, i);
  }
  get textAfter() {
    return this.textAfterPos(this.pos);
  }
  get baseIndent() {
    let t = this.state.doc.lineAt(this.node.from);
    for (; ; ) {
      let e = this.node.resolve(t.from);
      for (; e.parent && e.parent.from == e.from; )
        e = e.parent;
      if (dd(e, this.node))
        break;
      t = this.state.doc.lineAt(e.from);
    }
    return this.lineIndent(t.from);
  }
  continue() {
    let t = this.node.parent;
    return t ? ph(t, this.pos, this.base) : 0;
  }
}
function dd(s, t) {
  for (let e = t; e; e = e.parent)
    if (s == e)
      return !0;
  return !1;
}
function pd(s) {
  let t = s.node, e = t.childAfter(t.from), i = t.lastChild;
  if (!e)
    return null;
  let n = s.options.simulateBreak, r = s.state.doc.lineAt(e.from), o = n == null || n <= r.from ? r.to : Math.min(r.to, n);
  for (let l = e.to; ; ) {
    let h = t.childAfter(l);
    if (!h || h == i)
      return null;
    if (!h.type.isSkipped)
      return h.from < o ? e : null;
    l = h.to;
  }
}
function gd(s, t, e, i, n) {
  let r = s.textAfter, o = r.match(/^\s*/)[0].length, l = i && r.slice(o, o + i.length) == i || n == s.pos + o, h = t ? pd(s) : null;
  return h ? l ? s.column(h.from) : s.column(h.to) : s.baseIndent + (l ? 0 : s.unit * e);
}
function uo({ except: s, units: t = 1 } = {}) {
  return (e) => {
    let i = s && s.test(e.textAfter);
    return e.baseIndent + (i ? 0 : t * e.unit);
  };
}
const md = 200;
function wd() {
  return E.transactionFilter.of((s) => {
    if (!s.docChanged || !s.isUserEvent("input.type") && !s.isUserEvent("input.complete"))
      return s;
    let t = s.startState.languageDataAt("indentOnInput", s.startState.selection.main.head);
    if (!t.length)
      return s;
    let e = s.newDoc, { head: i } = s.newSelection.main, n = e.lineAt(i);
    if (i > n.from + md)
      return s;
    let r = e.sliceString(n.from, i);
    if (!t.some((a) => a.test(r)))
      return s;
    let { state: o } = s, l = -1, h = [];
    for (let { head: a } of o.selection.ranges) {
      let c = o.doc.lineAt(a);
      if (c.from == l)
        continue;
      l = c.from;
      let f = tr(o, c.from);
      if (f == null)
        continue;
      let u = /^\s*/.exec(c.text)[0], d = wi(o, f);
      u != d && h.push({ from: c.from, to: c.from + u.length, insert: d });
    }
    return h.length ? [s, { changes: h, sequential: !0 }] : s;
  });
}
const yd = /* @__PURE__ */ v.define(), gh = /* @__PURE__ */ new P();
function bd(s) {
  let t = s.firstChild, e = s.lastChild;
  return t && t.to < e.from ? { from: t.to, to: e.type.isError ? s.to : e.from } : null;
}
function kd(s, t, e) {
  let i = St(s);
  if (i.length < e)
    return null;
  let n = i.resolveInner(e), r = null;
  for (let o = n; o; o = o.parent) {
    if (o.to <= e || o.from > e)
      continue;
    if (r && o.from < t)
      break;
    let l = o.type.prop(gh);
    if (l && (o.to < i.length - 50 || i.length == s.doc.length || !xd(o))) {
      let h = l(o, s);
      h && h.from <= e && h.from >= t && h.to > e && (r = h);
    }
  }
  return r;
}
function xd(s) {
  let t = s.lastChild;
  return t && t.to == s.to && t.type.isError;
}
function gn(s, t, e) {
  for (let i of s.facet(yd)) {
    let n = i(s, t, e);
    if (n)
      return n;
  }
  return kd(s, t, e);
}
function mh(s, t) {
  let e = t.mapPos(s.from, 1), i = t.mapPos(s.to, -1);
  return e >= i ? void 0 : { from: e, to: i };
}
const Dn = /* @__PURE__ */ F.define({ map: mh }), xi = /* @__PURE__ */ F.define({ map: mh });
function wh(s) {
  let t = [];
  for (let { head: e } of s.state.selection.ranges)
    t.some((i) => i.from <= e && i.to >= e) || t.push(s.lineBlockAt(e));
  return t;
}
const Pe = /* @__PURE__ */ Bt.define({
  create() {
    return D.none;
  },
  update(s, t) {
    s = s.map(t.changes);
    for (let e of t.effects)
      e.is(Dn) && !vd(s, e.value.from, e.value.to) ? s = s.update({ add: [po.range(e.value.from, e.value.to)] }) : e.is(xi) && (s = s.update({
        filter: (i, n) => e.value.from != i || e.value.to != n,
        filterFrom: e.value.from,
        filterTo: e.value.to
      }));
    if (t.selection) {
      let e = !1, { head: i } = t.selection.main;
      s.between(i, i, (n, r) => {
        n < i && r > i && (e = !0);
      }), e && (s = s.update({
        filterFrom: i,
        filterTo: i,
        filter: (n, r) => r <= i || n >= i
      }));
    }
    return s;
  },
  provide: (s) => A.decorations.from(s),
  toJSON(s, t) {
    let e = [];
    return s.between(0, t.doc.length, (i, n) => {
      e.push(i, n);
    }), e;
  },
  fromJSON(s) {
    if (!Array.isArray(s) || s.length % 2)
      throw new RangeError("Invalid JSON for fold state");
    let t = [];
    for (let e = 0; e < s.length; ) {
      let i = s[e++], n = s[e++];
      if (typeof i != "number" || typeof n != "number")
        throw new RangeError("Invalid JSON for fold state");
      t.push(po.range(i, n));
    }
    return D.set(t, !0);
  }
});
function mn(s, t, e) {
  var i;
  let n = null;
  return (i = s.field(Pe, !1)) === null || i === void 0 || i.between(t, e, (r, o) => {
    (!n || n.from > r) && (n = { from: r, to: o });
  }), n;
}
function vd(s, t, e) {
  let i = !1;
  return s.between(t, t, (n, r) => {
    n == t && r == e && (i = !0);
  }), i;
}
function yh(s, t) {
  return s.field(Pe, !1) ? t : t.concat(F.appendConfig.of(xh()));
}
const Sd = (s) => {
  for (let t of wh(s)) {
    let e = gn(s.state, t.from, t.to);
    if (e)
      return s.dispatch({ effects: yh(s.state, [Dn.of(e), bh(s, e)]) }), !0;
  }
  return !1;
}, Cd = (s) => {
  if (!s.state.field(Pe, !1))
    return !1;
  let t = [];
  for (let e of wh(s)) {
    let i = mn(s.state, e.from, e.to);
    i && t.push(xi.of(i), bh(s, i, !1));
  }
  return t.length && s.dispatch({ effects: t }), t.length > 0;
};
function bh(s, t, e = !0) {
  let i = s.state.doc.lineAt(t.from).number, n = s.state.doc.lineAt(t.to).number;
  return A.announce.of(`${s.state.phrase(e ? "Folded lines" : "Unfolded lines")} ${i} ${s.state.phrase("to")} ${n}.`);
}
const Ad = (s) => {
  let { state: t } = s, e = [];
  for (let i = 0; i < t.doc.length; ) {
    let n = s.lineBlockAt(i), r = gn(t, n.from, n.to);
    r && e.push(Dn.of(r)), i = (r ? s.lineBlockAt(r.to) : n).to + 1;
  }
  return e.length && s.dispatch({ effects: yh(s.state, e) }), !!e.length;
}, Od = (s) => {
  let t = s.state.field(Pe, !1);
  if (!t || !t.size)
    return !1;
  let e = [];
  return t.between(0, s.state.doc.length, (i, n) => {
    e.push(xi.of({ from: i, to: n }));
  }), s.dispatch({ effects: e }), !0;
}, Md = [
  { key: "Ctrl-Shift-[", mac: "Cmd-Alt-[", run: Sd },
  { key: "Ctrl-Shift-]", mac: "Cmd-Alt-]", run: Cd },
  { key: "Ctrl-Alt-[", run: Ad },
  { key: "Ctrl-Alt-]", run: Od }
], Dd = {
  placeholderDOM: null,
  placeholderText: "\u2026"
}, kh = /* @__PURE__ */ v.define({
  combine(s) {
    return xn(s, Dd);
  }
});
function xh(s) {
  let t = [Pe, Bd];
  return s && t.push(kh.of(s)), t;
}
const po = /* @__PURE__ */ D.replace({ widget: /* @__PURE__ */ new class extends ye {
  toDOM(s) {
    let { state: t } = s, e = t.facet(kh), i = (r) => {
      let o = s.lineBlockAt(s.posAtDOM(r.target)), l = mn(s.state, o.from, o.to);
      l && s.dispatch({ effects: xi.of(l) }), r.preventDefault();
    };
    if (e.placeholderDOM)
      return e.placeholderDOM(s, i);
    let n = document.createElement("span");
    return n.textContent = e.placeholderText, n.setAttribute("aria-label", t.phrase("folded code")), n.title = t.phrase("unfold"), n.className = "cm-foldPlaceholder", n.onclick = i, n;
  }
}() }), Td = {
  openText: "\u2304",
  closedText: "\u203A",
  markerDOM: null,
  domEventHandlers: {},
  foldingChanged: () => !1
};
class Qn extends me {
  constructor(t, e) {
    super(), this.config = t, this.open = e;
  }
  eq(t) {
    return this.config == t.config && this.open == t.open;
  }
  toDOM(t) {
    if (this.config.markerDOM)
      return this.config.markerDOM(this.open);
    let e = document.createElement("span");
    return e.textContent = this.open ? this.config.openText : this.config.closedText, e.title = t.state.phrase(this.open ? "Fold line" : "Unfold line"), e;
  }
}
function Pd(s = {}) {
  let t = Object.assign(Object.assign({}, Td), s), e = new Qn(t, !0), i = new Qn(t, !1), n = wt.fromClass(class {
    constructor(o) {
      this.from = o.viewport.from, this.markers = this.buildMarkers(o);
    }
    update(o) {
      (o.docChanged || o.viewportChanged || o.startState.facet(we) != o.state.facet(we) || o.startState.field(Pe, !1) != o.state.field(Pe, !1) || St(o.startState) != St(o.state) || t.foldingChanged(o)) && (this.markers = this.buildMarkers(o.view));
    }
    buildMarkers(o) {
      let l = new De();
      for (let h of o.viewportLineBlocks) {
        let a = mn(o.state, h.from, h.to) ? i : gn(o.state, h.from, h.to) ? e : null;
        a && l.add(h.from, h.from, a);
      }
      return l.finish();
    }
  }), { domEventHandlers: r } = t;
  return [
    n,
    Hu({
      class: "cm-foldGutter",
      markers(o) {
        var l;
        return ((l = o.plugin(n)) === null || l === void 0 ? void 0 : l.markers) || $.empty;
      },
      initialSpacer() {
        return new Qn(t, !1);
      },
      domEventHandlers: Object.assign(Object.assign({}, r), { click: (o, l, h) => {
        if (r.click && r.click(o, l, h))
          return !0;
        let a = mn(o.state, l.from, l.to);
        if (a)
          return o.dispatch({ effects: xi.of(a) }), !0;
        let c = gn(o.state, l.from, l.to);
        return c ? (o.dispatch({ effects: Dn.of(c) }), !0) : !1;
      } })
    }),
    xh()
  ];
}
const Bd = /* @__PURE__ */ A.baseTheme({
  ".cm-foldPlaceholder": {
    backgroundColor: "#eee",
    border: "1px solid #ddd",
    color: "#888",
    borderRadius: ".2em",
    margin: "0 1px",
    padding: "0 1px",
    cursor: "pointer"
  },
  ".cm-foldGutter span": {
    padding: "0 1px",
    cursor: "pointer"
  }
});
class vi {
  constructor(t, e) {
    let i;
    function n(l) {
      let h = de.newName();
      return (i || (i = /* @__PURE__ */ Object.create(null)))["." + h] = l, h;
    }
    const r = typeof e.all == "string" ? e.all : e.all ? n(e.all) : void 0, o = e.scope;
    this.scope = o instanceof Tt ? (l) => l.prop(mi) == o.data : o ? (l) => l == o : void 0, this.style = fh(t.map((l) => ({
      tag: l.tag,
      class: l.class || n(Object.assign({}, l, { tag: null }))
    })), {
      all: r
    }).style, this.module = i ? new de(i) : null, this.themeType = e.themeType;
  }
  static define(t, e) {
    return new vi(t, e || {});
  }
}
const Es = /* @__PURE__ */ v.define(), vh = /* @__PURE__ */ v.define({
  combine(s) {
    return s.length ? [s[0]] : null;
  }
});
function Jn(s) {
  let t = s.facet(Es);
  return t.length ? t : s.facet(vh);
}
function go(s, t) {
  let e = [Ld], i;
  return s instanceof vi && (s.module && e.push(A.styleModule.of(s.module)), i = s.themeType), t != null && t.fallback ? e.push(vh.of(s)) : i ? e.push(Es.computeN([A.darkTheme], (n) => n.facet(A.darkTheme) == (i == "dark") ? [s] : [])) : e.push(Es.of(s)), e;
}
class Rd {
  constructor(t) {
    this.markCache = /* @__PURE__ */ Object.create(null), this.tree = St(t.state), this.decorations = this.buildDeco(t, Jn(t.state));
  }
  update(t) {
    let e = St(t.state), i = Jn(t.state), n = i != Jn(t.startState);
    e.length < t.view.viewport.to && !n && e.type == this.tree.type ? this.decorations = this.decorations.map(t.changes) : (e != this.tree || t.viewportChanged || n) && (this.tree = e, this.decorations = this.buildDeco(t.view, i));
  }
  buildDeco(t, e) {
    if (!e || !this.tree.length)
      return D.none;
    let i = new De();
    for (let { from: n, to: r } of t.visibleRanges)
      ed(this.tree, e, (o, l, h) => {
        i.add(o, l, this.markCache[h] || (this.markCache[h] = D.mark({ class: h })));
      }, n, r);
    return i.finish();
  }
}
const Ld = /* @__PURE__ */ _s.high(/* @__PURE__ */ wt.fromClass(Rd, {
  decorations: (s) => s.decorations
})), Ed = /* @__PURE__ */ vi.define([
  {
    tag: m.meta,
    color: "#7a757a"
  },
  {
    tag: m.link,
    textDecoration: "underline"
  },
  {
    tag: m.heading,
    textDecoration: "underline",
    fontWeight: "bold"
  },
  {
    tag: m.emphasis,
    fontStyle: "italic"
  },
  {
    tag: m.strong,
    fontWeight: "bold"
  },
  {
    tag: m.strikethrough,
    textDecoration: "line-through"
  },
  {
    tag: m.keyword,
    color: "#708"
  },
  {
    tag: [m.atom, m.bool, m.url, m.contentSeparator, m.labelName],
    color: "#219"
  },
  {
    tag: [m.literal, m.inserted],
    color: "#164"
  },
  {
    tag: [m.string, m.deleted],
    color: "#a11"
  },
  {
    tag: [m.regexp, m.escape, /* @__PURE__ */ m.special(m.string)],
    color: "#e40"
  },
  {
    tag: /* @__PURE__ */ m.definition(m.variableName),
    color: "#00f"
  },
  {
    tag: /* @__PURE__ */ m.local(m.variableName),
    color: "#30a"
  },
  {
    tag: [m.typeName, m.namespace],
    color: "#085"
  },
  {
    tag: m.className,
    color: "#167"
  },
  {
    tag: [/* @__PURE__ */ m.special(m.variableName), m.macroName],
    color: "#256"
  },
  {
    tag: /* @__PURE__ */ m.definition(m.propertyName),
    color: "#00c"
  },
  {
    tag: m.comment,
    color: "#940"
  },
  {
    tag: m.invalid,
    color: "#f00"
  }
]), Nd = /* @__PURE__ */ A.baseTheme({
  "&.cm-focused .cm-matchingBracket": { backgroundColor: "#328c8252" },
  "&.cm-focused .cm-nonmatchingBracket": { backgroundColor: "#bb555544" }
}), Sh = 1e4, Ch = "()[]{}", Ah = /* @__PURE__ */ v.define({
  combine(s) {
    return xn(s, {
      afterCursor: !0,
      brackets: Ch,
      maxScanDistance: Sh,
      renderMatch: Hd
    });
  }
}), Vd = /* @__PURE__ */ D.mark({ class: "cm-matchingBracket" }), Id = /* @__PURE__ */ D.mark({ class: "cm-nonmatchingBracket" });
function Hd(s) {
  let t = [], e = s.matched ? Vd : Id;
  return t.push(e.range(s.start.from, s.start.to)), s.end && t.push(e.range(s.end.from, s.end.to)), t;
}
const $d = /* @__PURE__ */ Bt.define({
  create() {
    return D.none;
  },
  update(s, t) {
    if (!t.docChanged && !t.selection)
      return s;
    let e = [], i = t.state.facet(Ah);
    for (let n of t.state.selection.ranges) {
      if (!n.empty)
        continue;
      let r = Ft(t.state, n.head, -1, i) || n.head > 0 && Ft(t.state, n.head - 1, 1, i) || i.afterCursor && (Ft(t.state, n.head, 1, i) || n.head < t.state.doc.length && Ft(t.state, n.head + 1, -1, i));
      r && (e = e.concat(i.renderMatch(r, t.state)));
    }
    return D.set(e, !0);
  },
  provide: (s) => A.decorations.from(s)
}), Fd = [
  $d,
  Nd
];
function zd(s = {}) {
  return [Ah.of(s), Fd];
}
function Ns(s, t, e) {
  let i = s.prop(t < 0 ? P.openedBy : P.closedBy);
  if (i)
    return i;
  if (s.name.length == 1) {
    let n = e.indexOf(s.name);
    if (n > -1 && n % 2 == (t < 0 ? 1 : 0))
      return [e[n + t]];
  }
  return null;
}
function Ft(s, t, e, i = {}) {
  let n = i.maxScanDistance || Sh, r = i.brackets || Ch, o = St(s), l = o.resolveInner(t, e);
  for (let h = l; h; h = h.parent) {
    let a = Ns(h.type, e, r);
    if (a && h.from < h.to)
      return _d(s, t, e, h, a, r);
  }
  return Wd(s, t, e, o, l.type, n, r);
}
function _d(s, t, e, i, n, r) {
  let o = i.parent, l = { from: i.from, to: i.to }, h = 0, a = o == null ? void 0 : o.cursor();
  if (a && (e < 0 ? a.childBefore(i.from) : a.childAfter(i.to)))
    do
      if (e < 0 ? a.to <= i.from : a.from >= i.to) {
        if (h == 0 && n.indexOf(a.type.name) > -1 && a.from < a.to)
          return { start: l, end: { from: a.from, to: a.to }, matched: !0 };
        if (Ns(a.type, e, r))
          h++;
        else if (Ns(a.type, -e, r)) {
          if (h == 0)
            return {
              start: l,
              end: a.from == a.to ? void 0 : { from: a.from, to: a.to },
              matched: !1
            };
          h--;
        }
      }
    while (e < 0 ? a.prevSibling() : a.nextSibling());
  return { start: l, matched: !1 };
}
function Wd(s, t, e, i, n, r, o) {
  let l = e < 0 ? s.sliceDoc(t - 1, t) : s.sliceDoc(t, t + 1), h = o.indexOf(l);
  if (h < 0 || h % 2 == 0 != e > 0)
    return null;
  let a = { from: e < 0 ? t - 1 : t, to: e > 0 ? t + 1 : t }, c = s.doc.iterRange(t, e > 0 ? s.doc.length : 0), f = 0;
  for (let u = 0; !c.next().done && u <= r; ) {
    let d = c.value;
    e < 0 && (u += d.length);
    let p = t + u * e;
    for (let w = e > 0 ? 0 : d.length - 1, g = e > 0 ? d.length : -1; w != g; w += e) {
      let y = o.indexOf(d[w]);
      if (!(y < 0 || i.resolveInner(p + w, 1).type != n))
        if (y % 2 == 0 == e > 0)
          f++;
        else {
          if (f == 1)
            return { start: a, end: { from: p + w, to: p + w + 1 }, matched: y >> 1 == h >> 1 };
          f--;
        }
    }
    e > 0 && (u += d.length);
  }
  return c.done ? { start: a, matched: !1 } : null;
}
const jd = /* @__PURE__ */ Object.create(null), mo = [yt.none], wo = [], qd = /* @__PURE__ */ Object.create(null);
for (let [s, t] of [
  ["variable", "variableName"],
  ["variable-2", "variableName.special"],
  ["string-2", "string.special"],
  ["def", "variableName.definition"],
  ["tag", "tagName"],
  ["attribute", "attributeName"],
  ["type", "typeName"],
  ["builtin", "variableName.standard"],
  ["qualifier", "modifier"],
  ["error", "invalid"],
  ["header", "heading"],
  ["property", "propertyName"]
])
  qd[s] = /* @__PURE__ */ Gd(jd, t);
function Xn(s, t) {
  wo.indexOf(s) > -1 || (wo.push(s), console.warn(t));
}
function Gd(s, t) {
  let e = null;
  for (let r of t.split(".")) {
    let o = s[r] || m[r];
    o ? typeof o == "function" ? e ? e = o(e) : Xn(r, `Modifier ${r} used at start of tag`) : e ? Xn(r, `Tag ${r} used as modifier`) : e = o : Xn(r, `Unknown highlighting tag ${r}`);
  }
  if (!e)
    return 0;
  let i = t.replace(/ /g, "_"), n = yt.define({
    id: mo.length,
    name: i,
    props: [ah({ [i]: e })]
  });
  return mo.push(n), n.id;
}
const Kd = (s) => {
  let t = nr(s.state);
  return t.line ? Ud(s) : t.block ? Jd(s) : !1;
};
function ir(s, t) {
  return ({ state: e, dispatch: i }) => {
    if (e.readOnly)
      return !1;
    let n = s(t, e);
    return n ? (i(e.update(n)), !0) : !1;
  };
}
const Ud = /* @__PURE__ */ ir(Zd, 0), Qd = /* @__PURE__ */ ir(Oh, 0), Jd = /* @__PURE__ */ ir((s, t) => Oh(s, t, Yd(t)), 0);
function nr(s, t = s.selection.main.head) {
  let e = s.languageDataAt("commentTokens", t);
  return e.length ? e[0] : {};
}
const ei = 50;
function Xd(s, { open: t, close: e }, i, n) {
  let r = s.sliceDoc(i - ei, i), o = s.sliceDoc(n, n + ei), l = /\s*$/.exec(r)[0].length, h = /^\s*/.exec(o)[0].length, a = r.length - l;
  if (r.slice(a - t.length, a) == t && o.slice(h, h + e.length) == e)
    return {
      open: { pos: i - l, margin: l && 1 },
      close: { pos: n + h, margin: h && 1 }
    };
  let c, f;
  n - i <= 2 * ei ? c = f = s.sliceDoc(i, n) : (c = s.sliceDoc(i, i + ei), f = s.sliceDoc(n - ei, n));
  let u = /^\s*/.exec(c)[0].length, d = /\s*$/.exec(f)[0].length, p = f.length - d - e.length;
  return c.slice(u, u + t.length) == t && f.slice(p, p + e.length) == e ? {
    open: {
      pos: i + u + t.length,
      margin: /\s/.test(c.charAt(u + t.length)) ? 1 : 0
    },
    close: {
      pos: n - d - e.length,
      margin: /\s/.test(f.charAt(p - 1)) ? 1 : 0
    }
  } : null;
}
function Yd(s) {
  let t = [];
  for (let e of s.selection.ranges) {
    let i = s.doc.lineAt(e.from), n = e.to <= i.to ? i : s.doc.lineAt(e.to), r = t.length - 1;
    r >= 0 && t[r].to > i.from ? t[r].to = n.to : t.push({ from: i.from, to: n.to });
  }
  return t;
}
function Oh(s, t, e = t.selection.ranges) {
  let i = e.map((r) => nr(t, r.from).block);
  if (!i.every((r) => r))
    return null;
  let n = e.map((r, o) => Xd(t, i[o], r.from, r.to));
  if (s != 2 && !n.every((r) => r))
    return { changes: t.changes(e.map((r, o) => n[o] ? [] : [{ from: r.from, insert: i[o].open + " " }, { from: r.to, insert: " " + i[o].close }])) };
  if (s != 1 && n.some((r) => r)) {
    let r = [];
    for (let o = 0, l; o < n.length; o++)
      if (l = n[o]) {
        let h = i[o], { open: a, close: c } = l;
        r.push({ from: a.pos - h.open.length, to: a.pos + a.margin }, { from: c.pos - c.margin, to: c.pos + h.close.length });
      }
    return { changes: r };
  }
  return null;
}
function Zd(s, t, e = t.selection.ranges) {
  let i = [], n = -1;
  for (let { from: r, to: o } of e) {
    let l = i.length, h = 1e9;
    for (let a = r; a <= o; ) {
      let c = t.doc.lineAt(a);
      if (c.from > n && (r == o || o > c.from)) {
        n = c.from;
        let f = nr(t, a).line;
        if (!f)
          continue;
        let u = /^\s*/.exec(c.text)[0].length, d = u == c.length, p = c.text.slice(u, u + f.length) == f ? u : -1;
        u < c.text.length && u < h && (h = u), i.push({ line: c, comment: p, token: f, indent: u, empty: d, single: !1 });
      }
      a = c.to + 1;
    }
    if (h < 1e9)
      for (let a = l; a < i.length; a++)
        i[a].indent < i[a].line.text.length && (i[a].indent = h);
    i.length == l + 1 && (i[l].single = !0);
  }
  if (s != 2 && i.some((r) => r.comment < 0 && (!r.empty || r.single))) {
    let r = [];
    for (let { line: l, token: h, indent: a, empty: c, single: f } of i)
      (f || !c) && r.push({ from: l.from + a, insert: h + " " });
    let o = t.changes(r);
    return { changes: o, selection: t.selection.map(o, 1) };
  } else if (s != 1 && i.some((r) => r.comment >= 0)) {
    let r = [];
    for (let { line: o, comment: l, token: h } of i)
      if (l >= 0) {
        let a = o.from + l, c = a + h.length;
        o.text[c - o.from] == " " && c++, r.push({ from: a, to: c });
      }
    return { changes: r };
  }
  return null;
}
function Je(s, t) {
  return k.create(s.ranges.map(t), s.mainIndex);
}
function qt(s, t) {
  return s.update({ selection: t, scrollIntoView: !0, userEvent: "select" });
}
function Rt({ state: s, dispatch: t }, e) {
  let i = Je(s.selection, e);
  return i.eq(s.selection) ? !1 : (t(qt(s, i)), !0);
}
function Tn(s, t) {
  return k.cursor(t ? s.to : s.from);
}
function Mh(s, t) {
  return Rt(s, (e) => e.empty ? s.moveByChar(e, t) : Tn(e, t));
}
function ft(s) {
  return s.textDirectionAt(s.state.selection.main.head) == X.LTR;
}
const Dh = (s) => Mh(s, !ft(s)), Th = (s) => Mh(s, ft(s));
function Ph(s, t) {
  return Rt(s, (e) => e.empty ? s.moveByGroup(e, t) : Tn(e, t));
}
const tp = (s) => Ph(s, !ft(s)), ep = (s) => Ph(s, ft(s));
function ip(s, t, e) {
  if (t.type.prop(e))
    return !0;
  let i = t.to - t.from;
  return i && (i > 2 || /[^\s,.;:]/.test(s.sliceDoc(t.from, t.to))) || t.firstChild;
}
function Pn(s, t, e) {
  let i = St(s).resolveInner(t.head), n = e ? P.closedBy : P.openedBy;
  for (let h = t.head; ; ) {
    let a = e ? i.childAfter(h) : i.childBefore(h);
    if (!a)
      break;
    ip(s, a, n) ? i = a : h = e ? a.to : a.from;
  }
  let r = i.type.prop(n), o, l;
  return r && (o = e ? Ft(s, i.from, 1) : Ft(s, i.to, -1)) && o.matched ? l = e ? o.end.to : o.end.from : l = e ? i.to : i.from, k.cursor(l, e ? -1 : 1);
}
const np = (s) => Rt(s, (t) => Pn(s.state, t, !ft(s))), sp = (s) => Rt(s, (t) => Pn(s.state, t, ft(s)));
function Bh(s, t) {
  return Rt(s, (e) => {
    if (!e.empty)
      return Tn(e, t);
    let i = s.moveVertically(e, t);
    return i.head != e.head ? i : s.moveToLineBoundary(e, t);
  });
}
const Rh = (s) => Bh(s, !1), Lh = (s) => Bh(s, !0);
function Eh(s) {
  return Math.max(s.defaultLineHeight, Math.min(s.dom.clientHeight, innerHeight) - 5);
}
function Nh(s, t) {
  let { state: e } = s, i = Je(e.selection, (l) => l.empty ? s.moveVertically(l, t, Eh(s)) : Tn(l, t));
  if (i.eq(e.selection))
    return !1;
  let n = s.coordsAtPos(e.selection.main.head), r = s.scrollDOM.getBoundingClientRect(), o;
  return n && n.top > r.top && n.bottom < r.bottom && n.top - r.top <= s.scrollDOM.scrollHeight - s.scrollDOM.scrollTop - s.scrollDOM.clientHeight && (o = A.scrollIntoView(i.main.head, { y: "start", yMargin: n.top - r.top })), s.dispatch(qt(e, i), { effects: o }), !0;
}
const yo = (s) => Nh(s, !1), Vs = (s) => Nh(s, !0);
function be(s, t, e) {
  let i = s.lineBlockAt(t.head), n = s.moveToLineBoundary(t, e);
  if (n.head == t.head && n.head != (e ? i.to : i.from) && (n = s.moveToLineBoundary(t, e, !1)), !e && n.head == i.from && i.length) {
    let r = /^\s*/.exec(s.state.sliceDoc(i.from, Math.min(i.from + 100, i.to)))[0].length;
    r && t.head != i.from + r && (n = k.cursor(i.from + r));
  }
  return n;
}
const rp = (s) => Rt(s, (t) => be(s, t, !0)), op = (s) => Rt(s, (t) => be(s, t, !1)), lp = (s) => Rt(s, (t) => be(s, t, !ft(s))), hp = (s) => Rt(s, (t) => be(s, t, ft(s))), ap = (s) => Rt(s, (t) => k.cursor(s.lineBlockAt(t.head).from, 1)), cp = (s) => Rt(s, (t) => k.cursor(s.lineBlockAt(t.head).to, -1));
function fp(s, t, e) {
  let i = !1, n = Je(s.selection, (r) => {
    let o = Ft(s, r.head, -1) || Ft(s, r.head, 1) || r.head > 0 && Ft(s, r.head - 1, 1) || r.head < s.doc.length && Ft(s, r.head + 1, -1);
    if (!o || !o.end)
      return r;
    i = !0;
    let l = o.start.from == r.head ? o.end.to : o.end.from;
    return e ? k.range(r.anchor, l) : k.cursor(l);
  });
  return i ? (t(qt(s, n)), !0) : !1;
}
const up = ({ state: s, dispatch: t }) => fp(s, t, !1);
function At(s, t) {
  let e = Je(s.state.selection, (i) => {
    let n = t(i);
    return k.range(i.anchor, n.head, n.goalColumn);
  });
  return e.eq(s.state.selection) ? !1 : (s.dispatch(qt(s.state, e)), !0);
}
function Vh(s, t) {
  return At(s, (e) => s.moveByChar(e, t));
}
const Ih = (s) => Vh(s, !ft(s)), Hh = (s) => Vh(s, ft(s));
function $h(s, t) {
  return At(s, (e) => s.moveByGroup(e, t));
}
const dp = (s) => $h(s, !ft(s)), pp = (s) => $h(s, ft(s)), gp = (s) => At(s, (t) => Pn(s.state, t, !ft(s))), mp = (s) => At(s, (t) => Pn(s.state, t, ft(s)));
function Fh(s, t) {
  return At(s, (e) => s.moveVertically(e, t));
}
const zh = (s) => Fh(s, !1), _h = (s) => Fh(s, !0);
function Wh(s, t) {
  return At(s, (e) => s.moveVertically(e, t, Eh(s)));
}
const bo = (s) => Wh(s, !1), ko = (s) => Wh(s, !0), wp = (s) => At(s, (t) => be(s, t, !0)), yp = (s) => At(s, (t) => be(s, t, !1)), bp = (s) => At(s, (t) => be(s, t, !ft(s))), kp = (s) => At(s, (t) => be(s, t, ft(s))), xp = (s) => At(s, (t) => k.cursor(s.lineBlockAt(t.head).from)), vp = (s) => At(s, (t) => k.cursor(s.lineBlockAt(t.head).to)), xo = ({ state: s, dispatch: t }) => (t(qt(s, { anchor: 0 })), !0), vo = ({ state: s, dispatch: t }) => (t(qt(s, { anchor: s.doc.length })), !0), So = ({ state: s, dispatch: t }) => (t(qt(s, { anchor: s.selection.main.anchor, head: 0 })), !0), Co = ({ state: s, dispatch: t }) => (t(qt(s, { anchor: s.selection.main.anchor, head: s.doc.length })), !0), Sp = ({ state: s, dispatch: t }) => (t(s.update({ selection: { anchor: 0, head: s.doc.length }, userEvent: "select" })), !0), Cp = ({ state: s, dispatch: t }) => {
  let e = Rn(s).map(({ from: i, to: n }) => k.range(i, Math.min(n + 1, s.doc.length)));
  return t(s.update({ selection: k.create(e), userEvent: "select" })), !0;
}, Ap = ({ state: s, dispatch: t }) => {
  let e = Je(s.selection, (i) => {
    var n;
    let r = St(s).resolveInner(i.head, 1);
    for (; !(r.from < i.from && r.to >= i.to || r.to > i.to && r.from <= i.from || !(!((n = r.parent) === null || n === void 0) && n.parent)); )
      r = r.parent;
    return k.range(r.to, r.from);
  });
  return t(qt(s, e)), !0;
}, Op = ({ state: s, dispatch: t }) => {
  let e = s.selection, i = null;
  return e.ranges.length > 1 ? i = k.create([e.main]) : e.main.empty || (i = k.create([k.cursor(e.main.head)])), i ? (t(qt(s, i)), !0) : !1;
};
function Bn(s, t) {
  if (s.state.readOnly)
    return !1;
  let e = "delete.selection", { state: i } = s, n = i.changeByRange((r) => {
    let { from: o, to: l } = r;
    if (o == l) {
      let h = t(o);
      h < o ? (e = "delete.backward", h = Ii(s, h, !1)) : h > o && (e = "delete.forward", h = Ii(s, h, !0)), o = Math.min(o, h), l = Math.max(l, h);
    } else
      o = Ii(s, o, !1), l = Ii(s, o, !0);
    return o == l ? { range: r } : { changes: { from: o, to: l }, range: k.cursor(o) };
  });
  return n.changes.empty ? !1 : (s.dispatch(i.update(n, {
    scrollIntoView: !0,
    userEvent: e,
    effects: e == "delete.selection" ? A.announce.of(i.phrase("Selection deleted")) : void 0
  })), !0);
}
function Ii(s, t, e) {
  if (s instanceof A)
    for (let i of s.state.facet(A.atomicRanges).map((n) => n(s)))
      i.between(t, t, (n, r) => {
        n < t && r > t && (t = e ? r : n);
      });
  return t;
}
const jh = (s, t) => Bn(s, (e) => {
  let { state: i } = s, n = i.doc.lineAt(e), r, o;
  if (!t && e > n.from && e < n.from + 200 && !/[^ \t]/.test(r = n.text.slice(0, e - n.from))) {
    if (r[r.length - 1] == "	")
      return e - 1;
    let l = vn(r, i.tabSize), h = l % pn(i) || pn(i);
    for (let a = 0; a < h && r[r.length - 1 - a] == " "; a++)
      e--;
    o = e;
  } else
    o = xt(n.text, e - n.from, t, t) + n.from, o == e && n.number != (t ? i.doc.lines : 1) && (o += t ? 1 : -1);
  return o;
}), Is = (s) => jh(s, !1), qh = (s) => jh(s, !0), Gh = (s, t) => Bn(s, (e) => {
  let i = e, { state: n } = s, r = n.doc.lineAt(i), o = n.charCategorizer(i);
  for (let l = null; ; ) {
    if (i == (t ? r.to : r.from)) {
      i == e && r.number != (t ? n.doc.lines : 1) && (i += t ? 1 : -1);
      break;
    }
    let h = xt(r.text, i - r.from, t) + r.from, a = r.text.slice(Math.min(i, h) - r.from, Math.max(i, h) - r.from), c = o(a);
    if (l != null && c != l)
      break;
    (a != " " || i != e) && (l = c), i = h;
  }
  return i;
}), Kh = (s) => Gh(s, !1), Mp = (s) => Gh(s, !0), Uh = (s) => Bn(s, (t) => {
  let e = s.lineBlockAt(t).to;
  return t < e ? e : Math.min(s.state.doc.length, t + 1);
}), Dp = (s) => Bn(s, (t) => {
  let e = s.lineBlockAt(t).from;
  return t > e ? e : Math.max(0, t - 1);
}), Tp = ({ state: s, dispatch: t }) => {
  if (s.readOnly)
    return !1;
  let e = s.changeByRange((i) => ({
    changes: { from: i.from, to: i.to, insert: I.of(["", ""]) },
    range: k.cursor(i.from)
  }));
  return t(s.update(e, { scrollIntoView: !0, userEvent: "input" })), !0;
}, Pp = ({ state: s, dispatch: t }) => {
  if (s.readOnly)
    return !1;
  let e = s.changeByRange((i) => {
    if (!i.empty || i.from == 0 || i.from == s.doc.length)
      return { range: i };
    let n = i.from, r = s.doc.lineAt(n), o = n == r.from ? n - 1 : xt(r.text, n - r.from, !1) + r.from, l = n == r.to ? n + 1 : xt(r.text, n - r.from, !0) + r.from;
    return {
      changes: { from: o, to: l, insert: s.doc.slice(n, l).append(s.doc.slice(o, n)) },
      range: k.cursor(l)
    };
  });
  return e.changes.empty ? !1 : (t(s.update(e, { scrollIntoView: !0, userEvent: "move.character" })), !0);
};
function Rn(s) {
  let t = [], e = -1;
  for (let i of s.selection.ranges) {
    let n = s.doc.lineAt(i.from), r = s.doc.lineAt(i.to);
    if (!i.empty && i.to == r.from && (r = s.doc.lineAt(i.to - 1)), e >= n.number) {
      let o = t[t.length - 1];
      o.to = r.to, o.ranges.push(i);
    } else
      t.push({ from: n.from, to: r.to, ranges: [i] });
    e = r.number + 1;
  }
  return t;
}
function Qh(s, t, e) {
  if (s.readOnly)
    return !1;
  let i = [], n = [];
  for (let r of Rn(s)) {
    if (e ? r.to == s.doc.length : r.from == 0)
      continue;
    let o = s.doc.lineAt(e ? r.to + 1 : r.from - 1), l = o.length + 1;
    if (e) {
      i.push({ from: r.to, to: o.to }, { from: r.from, insert: o.text + s.lineBreak });
      for (let h of r.ranges)
        n.push(k.range(Math.min(s.doc.length, h.anchor + l), Math.min(s.doc.length, h.head + l)));
    } else {
      i.push({ from: o.from, to: r.from }, { from: r.to, insert: s.lineBreak + o.text });
      for (let h of r.ranges)
        n.push(k.range(h.anchor - l, h.head - l));
    }
  }
  return i.length ? (t(s.update({
    changes: i,
    scrollIntoView: !0,
    selection: k.create(n, s.selection.mainIndex),
    userEvent: "move.line"
  })), !0) : !1;
}
const Bp = ({ state: s, dispatch: t }) => Qh(s, t, !1), Rp = ({ state: s, dispatch: t }) => Qh(s, t, !0);
function Jh(s, t, e) {
  if (s.readOnly)
    return !1;
  let i = [];
  for (let n of Rn(s))
    e ? i.push({ from: n.from, insert: s.doc.slice(n.from, n.to) + s.lineBreak }) : i.push({ from: n.to, insert: s.lineBreak + s.doc.slice(n.from, n.to) });
  return t(s.update({ changes: i, scrollIntoView: !0, userEvent: "input.copyline" })), !0;
}
const Lp = ({ state: s, dispatch: t }) => Jh(s, t, !1), Ep = ({ state: s, dispatch: t }) => Jh(s, t, !0), Np = (s) => {
  if (s.state.readOnly)
    return !1;
  let { state: t } = s, e = t.changes(Rn(t).map(({ from: n, to: r }) => (n > 0 ? n-- : r < t.doc.length && r++, { from: n, to: r }))), i = Je(t.selection, (n) => s.moveVertically(n, !0)).map(e);
  return s.dispatch({ changes: e, selection: i, scrollIntoView: !0, userEvent: "delete.line" }), !0;
};
function Vp(s, t) {
  if (/\(\)|\[\]|\{\}/.test(s.sliceDoc(t - 1, t + 1)))
    return { from: t, to: t };
  let e = St(s).resolveInner(t), i = e.childBefore(t), n = e.childAfter(t), r;
  return i && n && i.to <= t && n.from >= t && (r = i.type.prop(P.closedBy)) && r.indexOf(n.name) > -1 && s.doc.lineAt(i.to).from == s.doc.lineAt(n.from).from ? { from: i.to, to: n.from } : null;
}
const Ip = /* @__PURE__ */ Xh(!1), Hp = /* @__PURE__ */ Xh(!0);
function Xh(s) {
  return ({ state: t, dispatch: e }) => {
    if (t.readOnly)
      return !1;
    let i = t.changeByRange((n) => {
      let { from: r, to: o } = n, l = t.doc.lineAt(r), h = !s && r == o && Vp(t, r);
      s && (r = o = (o <= l.to ? l : t.doc.lineAt(o)).to);
      let a = new Mn(t, { simulateBreak: r, simulateDoubleBreak: !!h }), c = tr(a, r);
      for (c == null && (c = /^\s*/.exec(t.doc.lineAt(r).text)[0].length); o < l.to && /\s/.test(l.text[o - l.from]); )
        o++;
      h ? { from: r, to: o } = h : r > l.from && r < l.from + 100 && !/\S/.test(l.text.slice(0, r)) && (r = l.from);
      let f = ["", wi(t, c)];
      return h && f.push(wi(t, a.lineIndent(l.from, -1))), {
        changes: { from: r, to: o, insert: I.of(f) },
        range: k.cursor(r + 1 + f[1].length)
      };
    });
    return e(t.update(i, { scrollIntoView: !0, userEvent: "input" })), !0;
  };
}
function sr(s, t) {
  let e = -1;
  return s.changeByRange((i) => {
    let n = [];
    for (let o = i.from; o <= i.to; ) {
      let l = s.doc.lineAt(o);
      l.number > e && (i.empty || i.to > l.from) && (t(l, n, i), e = l.number), o = l.to + 1;
    }
    let r = s.changes(n);
    return {
      changes: n,
      range: k.range(r.mapPos(i.anchor, 1), r.mapPos(i.head, 1))
    };
  });
}
const $p = ({ state: s, dispatch: t }) => {
  if (s.readOnly)
    return !1;
  let e = /* @__PURE__ */ Object.create(null), i = new Mn(s, { overrideIndentation: (r) => {
    let o = e[r];
    return o == null ? -1 : o;
  } }), n = sr(s, (r, o, l) => {
    let h = tr(i, r.from);
    if (h == null)
      return;
    /\S/.test(r.text) || (h = 0);
    let a = /^\s*/.exec(r.text)[0], c = wi(s, h);
    (a != c || l.from < r.from + a.length) && (e[r.from] = h, o.push({ from: r.from, to: r.from + a.length, insert: c }));
  });
  return n.changes.empty || t(s.update(n, { userEvent: "indent" })), !0;
}, Fp = ({ state: s, dispatch: t }) => s.readOnly ? !1 : (t(s.update(sr(s, (e, i) => {
  i.push({ from: e.from, insert: s.facet(Zs) });
}), { userEvent: "input.indent" })), !0), zp = ({ state: s, dispatch: t }) => s.readOnly ? !1 : (t(s.update(sr(s, (e, i) => {
  let n = /^\s*/.exec(e.text)[0];
  if (!n)
    return;
  let r = vn(n, s.tabSize), o = 0, l = wi(s, Math.max(0, r - pn(s)));
  for (; o < n.length && o < l.length && n.charCodeAt(o) == l.charCodeAt(o); )
    o++;
  i.push({ from: e.from + o, to: e.from + n.length, insert: l.slice(o) });
}), { userEvent: "delete.dedent" })), !0), _p = [
  { key: "Ctrl-b", run: Dh, shift: Ih, preventDefault: !0 },
  { key: "Ctrl-f", run: Th, shift: Hh },
  { key: "Ctrl-p", run: Rh, shift: zh },
  { key: "Ctrl-n", run: Lh, shift: _h },
  { key: "Ctrl-a", run: ap, shift: xp },
  { key: "Ctrl-e", run: cp, shift: vp },
  { key: "Ctrl-d", run: qh },
  { key: "Ctrl-h", run: Is },
  { key: "Ctrl-k", run: Uh },
  { key: "Ctrl-Alt-h", run: Kh },
  { key: "Ctrl-o", run: Tp },
  { key: "Ctrl-t", run: Pp },
  { key: "Ctrl-v", run: Vs }
], Wp = /* @__PURE__ */ [
  { key: "ArrowLeft", run: Dh, shift: Ih, preventDefault: !0 },
  { key: "Mod-ArrowLeft", mac: "Alt-ArrowLeft", run: tp, shift: dp, preventDefault: !0 },
  { mac: "Cmd-ArrowLeft", run: lp, shift: bp, preventDefault: !0 },
  { key: "ArrowRight", run: Th, shift: Hh, preventDefault: !0 },
  { key: "Mod-ArrowRight", mac: "Alt-ArrowRight", run: ep, shift: pp, preventDefault: !0 },
  { mac: "Cmd-ArrowRight", run: hp, shift: kp, preventDefault: !0 },
  { key: "ArrowUp", run: Rh, shift: zh, preventDefault: !0 },
  { mac: "Cmd-ArrowUp", run: xo, shift: So },
  { mac: "Ctrl-ArrowUp", run: yo, shift: bo },
  { key: "ArrowDown", run: Lh, shift: _h, preventDefault: !0 },
  { mac: "Cmd-ArrowDown", run: vo, shift: Co },
  { mac: "Ctrl-ArrowDown", run: Vs, shift: ko },
  { key: "PageUp", run: yo, shift: bo },
  { key: "PageDown", run: Vs, shift: ko },
  { key: "Home", run: op, shift: yp, preventDefault: !0 },
  { key: "Mod-Home", run: xo, shift: So },
  { key: "End", run: rp, shift: wp, preventDefault: !0 },
  { key: "Mod-End", run: vo, shift: Co },
  { key: "Enter", run: Ip },
  { key: "Mod-a", run: Sp },
  { key: "Backspace", run: Is, shift: Is },
  { key: "Delete", run: qh },
  { key: "Mod-Backspace", mac: "Alt-Backspace", run: Kh },
  { key: "Mod-Delete", mac: "Alt-Delete", run: Mp },
  { mac: "Mod-Backspace", run: Dp },
  { mac: "Mod-Delete", run: Uh }
].concat(/* @__PURE__ */ _p.map((s) => ({ mac: s.key, run: s.run, shift: s.shift }))), jp = /* @__PURE__ */ [
  { key: "Alt-ArrowLeft", mac: "Ctrl-ArrowLeft", run: np, shift: gp },
  { key: "Alt-ArrowRight", mac: "Ctrl-ArrowRight", run: sp, shift: mp },
  { key: "Alt-ArrowUp", run: Bp },
  { key: "Shift-Alt-ArrowUp", run: Lp },
  { key: "Alt-ArrowDown", run: Rp },
  { key: "Shift-Alt-ArrowDown", run: Ep },
  { key: "Escape", run: Op },
  { key: "Mod-Enter", run: Hp },
  { key: "Alt-l", mac: "Ctrl-l", run: Cp },
  { key: "Mod-i", run: Ap, preventDefault: !0 },
  { key: "Mod-[", run: zp },
  { key: "Mod-]", run: Fp },
  { key: "Mod-Alt-\\", run: $p },
  { key: "Shift-Mod-k", run: Np },
  { key: "Shift-Mod-\\", run: up },
  { key: "Mod-/", run: Kd },
  { key: "Alt-A", run: Qd }
].concat(Wp);
class wn {
  constructor(t, e, i, n, r, o, l, h, a, c = 0, f) {
    this.p = t, this.stack = e, this.state = i, this.reducePos = n, this.pos = r, this.score = o, this.buffer = l, this.bufferBase = h, this.curContext = a, this.lookAhead = c, this.parent = f;
  }
  toString() {
    return `[${this.stack.filter((t, e) => e % 3 == 0).concat(this.state)}]@${this.pos}${this.score ? "!" + this.score : ""}`;
  }
  static start(t, e, i = 0) {
    let n = t.parser.context;
    return new wn(t, [], e, i, i, 0, [], 0, n ? new Ao(n, n.start) : null, 0, null);
  }
  get context() {
    return this.curContext ? this.curContext.context : null;
  }
  pushState(t, e) {
    this.stack.push(this.state, e, this.bufferBase + this.buffer.length), this.state = t;
  }
  reduce(t) {
    let e = t >> 19, i = t & 65535, { parser: n } = this.p, r = n.dynamicPrecedence(i);
    if (r && (this.score += r), e == 0) {
      this.pushState(n.getGoto(this.state, i, !0), this.reducePos), i < n.minRepeatTerm && this.storeNode(i, this.reducePos, this.reducePos, 4, !0), this.reduceContext(i, this.reducePos);
      return;
    }
    let o = this.stack.length - (e - 1) * 3 - (t & 262144 ? 6 : 0), l = this.stack[o - 2], h = this.stack[o - 1], a = this.bufferBase + this.buffer.length - h;
    if (i < n.minRepeatTerm || t & 131072) {
      let c = n.stateFlag(this.state, 1) ? this.pos : this.reducePos;
      this.storeNode(i, l, c, a + 4, !0);
    }
    if (t & 262144)
      this.state = this.stack[o];
    else {
      let c = this.stack[o - 3];
      this.state = n.getGoto(c, i, !0);
    }
    for (; this.stack.length > o; )
      this.stack.pop();
    this.reduceContext(i, l);
  }
  storeNode(t, e, i, n = 4, r = !1) {
    if (t == 0 && (!this.stack.length || this.stack[this.stack.length - 1] < this.buffer.length + this.bufferBase)) {
      let o = this, l = this.buffer.length;
      if (l == 0 && o.parent && (l = o.bufferBase - o.parent.bufferBase, o = o.parent), l > 0 && o.buffer[l - 4] == 0 && o.buffer[l - 1] > -1) {
        if (e == i)
          return;
        if (o.buffer[l - 2] >= e) {
          o.buffer[l - 2] = i;
          return;
        }
      }
    }
    if (!r || this.pos == i)
      this.buffer.push(t, e, i, n);
    else {
      let o = this.buffer.length;
      if (o > 0 && this.buffer[o - 4] != 0)
        for (; o > 0 && this.buffer[o - 2] > i; )
          this.buffer[o] = this.buffer[o - 4], this.buffer[o + 1] = this.buffer[o - 3], this.buffer[o + 2] = this.buffer[o - 2], this.buffer[o + 3] = this.buffer[o - 1], o -= 4, n > 4 && (n -= 4);
      this.buffer[o] = t, this.buffer[o + 1] = e, this.buffer[o + 2] = i, this.buffer[o + 3] = n;
    }
  }
  shift(t, e, i) {
    let n = this.pos;
    if (t & 131072)
      this.pushState(t & 65535, this.pos);
    else if ((t & 262144) == 0) {
      let r = t, { parser: o } = this.p;
      (i > this.pos || e <= o.maxNode) && (this.pos = i, o.stateFlag(r, 1) || (this.reducePos = i)), this.pushState(r, n), this.shiftContext(e, n), e <= o.maxNode && this.buffer.push(e, n, i, 4);
    } else
      this.pos = i, this.shiftContext(e, n), e <= this.p.parser.maxNode && this.buffer.push(e, n, i, 4);
  }
  apply(t, e, i) {
    t & 65536 ? this.reduce(t) : this.shift(t, e, i);
  }
  useNode(t, e) {
    let i = this.p.reused.length - 1;
    (i < 0 || this.p.reused[i] != t) && (this.p.reused.push(t), i++);
    let n = this.pos;
    this.reducePos = this.pos = n + t.length, this.pushState(e, n), this.buffer.push(i, n, this.reducePos, -1), this.curContext && this.updateContext(this.curContext.tracker.reuse(this.curContext.context, t, this, this.p.stream.reset(this.pos - t.length)));
  }
  split() {
    let t = this, e = t.buffer.length;
    for (; e > 0 && t.buffer[e - 2] > t.reducePos; )
      e -= 4;
    let i = t.buffer.slice(e), n = t.bufferBase + e;
    for (; t && n == t.bufferBase; )
      t = t.parent;
    return new wn(this.p, this.stack.slice(), this.state, this.reducePos, this.pos, this.score, i, n, this.curContext, this.lookAhead, t);
  }
  recoverByDelete(t, e) {
    let i = t <= this.p.parser.maxNode;
    i && this.storeNode(t, this.pos, e, 4), this.storeNode(0, this.pos, e, i ? 8 : 4), this.pos = this.reducePos = e, this.score -= 190;
  }
  canShift(t) {
    for (let e = new qp(this); ; ) {
      let i = this.p.parser.stateSlot(e.state, 4) || this.p.parser.hasAction(e.state, t);
      if ((i & 65536) == 0)
        return !0;
      if (i == 0)
        return !1;
      e.reduce(i);
    }
  }
  recoverByInsert(t) {
    if (this.stack.length >= 300)
      return [];
    let e = this.p.parser.nextStates(this.state);
    if (e.length > 4 << 1 || this.stack.length >= 120) {
      let n = [];
      for (let r = 0, o; r < e.length; r += 2)
        (o = e[r + 1]) != this.state && this.p.parser.hasAction(o, t) && n.push(e[r], o);
      if (this.stack.length < 120)
        for (let r = 0; n.length < 4 << 1 && r < e.length; r += 2) {
          let o = e[r + 1];
          n.some((l, h) => h & 1 && l == o) || n.push(e[r], o);
        }
      e = n;
    }
    let i = [];
    for (let n = 0; n < e.length && i.length < 4; n += 2) {
      let r = e[n + 1];
      if (r == this.state)
        continue;
      let o = this.split();
      o.pushState(r, this.pos), o.storeNode(0, o.pos, o.pos, 4, !0), o.shiftContext(e[n], this.pos), o.score -= 200, i.push(o);
    }
    return i;
  }
  forceReduce() {
    let t = this.p.parser.stateSlot(this.state, 5);
    if ((t & 65536) == 0)
      return !1;
    let { parser: e } = this.p;
    if (!e.validAction(this.state, t)) {
      let i = t >> 19, n = t & 65535, r = this.stack.length - i * 3;
      if (r < 0 || e.getGoto(this.stack[r], n, !1) < 0)
        return !1;
      this.storeNode(0, this.reducePos, this.reducePos, 4, !0), this.score -= 100;
    }
    return this.reducePos = this.pos, this.reduce(t), !0;
  }
  forceAll() {
    for (; !this.p.parser.stateFlag(this.state, 2); )
      if (!this.forceReduce()) {
        this.storeNode(0, this.pos, this.pos, 4, !0);
        break;
      }
    return this;
  }
  get deadEnd() {
    if (this.stack.length != 3)
      return !1;
    let { parser: t } = this.p;
    return t.data[t.stateSlot(this.state, 1)] == 65535 && !t.stateSlot(this.state, 4);
  }
  restart() {
    this.state = this.stack[0], this.stack.length = 0;
  }
  sameState(t) {
    if (this.state != t.state || this.stack.length != t.stack.length)
      return !1;
    for (let e = 0; e < this.stack.length; e += 3)
      if (this.stack[e] != t.stack[e])
        return !1;
    return !0;
  }
  get parser() {
    return this.p.parser;
  }
  dialectEnabled(t) {
    return this.p.parser.dialect.flags[t];
  }
  shiftContext(t, e) {
    this.curContext && this.updateContext(this.curContext.tracker.shift(this.curContext.context, t, this, this.p.stream.reset(e)));
  }
  reduceContext(t, e) {
    this.curContext && this.updateContext(this.curContext.tracker.reduce(this.curContext.context, t, this, this.p.stream.reset(e)));
  }
  emitContext() {
    let t = this.buffer.length - 1;
    (t < 0 || this.buffer[t] != -3) && this.buffer.push(this.curContext.hash, this.reducePos, this.reducePos, -3);
  }
  emitLookAhead() {
    let t = this.buffer.length - 1;
    (t < 0 || this.buffer[t] != -4) && this.buffer.push(this.lookAhead, this.reducePos, this.reducePos, -4);
  }
  updateContext(t) {
    if (t != this.curContext.context) {
      let e = new Ao(this.curContext.tracker, t);
      e.hash != this.curContext.hash && this.emitContext(), this.curContext = e;
    }
  }
  setLookAhead(t) {
    t > this.lookAhead && (this.emitLookAhead(), this.lookAhead = t);
  }
  close() {
    this.curContext && this.curContext.tracker.strict && this.emitContext(), this.lookAhead > 0 && this.emitLookAhead();
  }
}
class Ao {
  constructor(t, e) {
    this.tracker = t, this.context = e, this.hash = t.strict ? t.hash(e) : 0;
  }
}
var Oo;
(function(s) {
  s[s.Insert = 200] = "Insert", s[s.Delete = 190] = "Delete", s[s.Reduce = 100] = "Reduce", s[s.MaxNext = 4] = "MaxNext", s[s.MaxInsertStackDepth = 300] = "MaxInsertStackDepth", s[s.DampenInsertStackDepth = 120] = "DampenInsertStackDepth";
})(Oo || (Oo = {}));
class qp {
  constructor(t) {
    this.start = t, this.state = t.state, this.stack = t.stack, this.base = this.stack.length;
  }
  reduce(t) {
    let e = t & 65535, i = t >> 19;
    i == 0 ? (this.stack == this.start.stack && (this.stack = this.stack.slice()), this.stack.push(this.state, 0, 0), this.base += 3) : this.base -= (i - 1) * 3;
    let n = this.start.p.parser.getGoto(this.stack[this.base - 3], e, !0);
    this.state = n;
  }
}
class yn {
  constructor(t, e, i) {
    this.stack = t, this.pos = e, this.index = i, this.buffer = t.buffer, this.index == 0 && this.maybeNext();
  }
  static create(t, e = t.bufferBase + t.buffer.length) {
    return new yn(t, e, e - t.bufferBase);
  }
  maybeNext() {
    let t = this.stack.parent;
    t != null && (this.index = this.stack.bufferBase - t.bufferBase, this.stack = t, this.buffer = t.buffer);
  }
  get id() {
    return this.buffer[this.index - 4];
  }
  get start() {
    return this.buffer[this.index - 3];
  }
  get end() {
    return this.buffer[this.index - 2];
  }
  get size() {
    return this.buffer[this.index - 1];
  }
  next() {
    this.index -= 4, this.pos -= 4, this.index == 0 && this.maybeNext();
  }
  fork() {
    return new yn(this.stack, this.pos, this.index);
  }
}
class Ki {
  constructor() {
    this.start = -1, this.value = -1, this.end = -1, this.extended = -1, this.lookAhead = 0, this.mask = 0, this.context = 0;
  }
}
const Mo = new Ki();
class Gp {
  constructor(t, e) {
    this.input = t, this.ranges = e, this.chunk = "", this.chunkOff = 0, this.chunk2 = "", this.chunk2Pos = 0, this.next = -1, this.token = Mo, this.rangeIndex = 0, this.pos = this.chunkPos = e[0].from, this.range = e[0], this.end = e[e.length - 1].to, this.readNext();
  }
  resolveOffset(t, e) {
    let i = this.range, n = this.rangeIndex, r = this.pos + t;
    for (; r < i.from; ) {
      if (!n)
        return null;
      let o = this.ranges[--n];
      r -= i.from - o.to, i = o;
    }
    for (; e < 0 ? r > i.to : r >= i.to; ) {
      if (n == this.ranges.length - 1)
        return null;
      let o = this.ranges[++n];
      r += o.from - i.to, i = o;
    }
    return r;
  }
  clipPos(t) {
    if (t >= this.range.from && t < this.range.to)
      return t;
    for (let e of this.ranges)
      if (e.to > t)
        return Math.max(t, e.from);
    return this.end;
  }
  peek(t) {
    let e = this.chunkOff + t, i, n;
    if (e >= 0 && e < this.chunk.length)
      i = this.pos + t, n = this.chunk.charCodeAt(e);
    else {
      let r = this.resolveOffset(t, 1);
      if (r == null)
        return -1;
      if (i = r, i >= this.chunk2Pos && i < this.chunk2Pos + this.chunk2.length)
        n = this.chunk2.charCodeAt(i - this.chunk2Pos);
      else {
        let o = this.rangeIndex, l = this.range;
        for (; l.to <= i; )
          l = this.ranges[++o];
        this.chunk2 = this.input.chunk(this.chunk2Pos = i), i + this.chunk2.length > l.to && (this.chunk2 = this.chunk2.slice(0, l.to - i)), n = this.chunk2.charCodeAt(0);
      }
    }
    return i >= this.token.lookAhead && (this.token.lookAhead = i + 1), n;
  }
  acceptToken(t, e = 0) {
    let i = e ? this.resolveOffset(e, -1) : this.pos;
    if (i == null || i < this.token.start)
      throw new RangeError("Token end out of bounds");
    this.token.value = t, this.token.end = i;
  }
  getChunk() {
    if (this.pos >= this.chunk2Pos && this.pos < this.chunk2Pos + this.chunk2.length) {
      let { chunk: t, chunkPos: e } = this;
      this.chunk = this.chunk2, this.chunkPos = this.chunk2Pos, this.chunk2 = t, this.chunk2Pos = e, this.chunkOff = this.pos - this.chunkPos;
    } else {
      this.chunk2 = this.chunk, this.chunk2Pos = this.chunkPos;
      let t = this.input.chunk(this.pos), e = this.pos + t.length;
      this.chunk = e > this.range.to ? t.slice(0, this.range.to - this.pos) : t, this.chunkPos = this.pos, this.chunkOff = 0;
    }
  }
  readNext() {
    return this.chunkOff >= this.chunk.length && (this.getChunk(), this.chunkOff == this.chunk.length) ? this.next = -1 : this.next = this.chunk.charCodeAt(this.chunkOff);
  }
  advance(t = 1) {
    for (this.chunkOff += t; this.pos + t >= this.range.to; ) {
      if (this.rangeIndex == this.ranges.length - 1)
        return this.setDone();
      t -= this.range.to - this.pos, this.range = this.ranges[++this.rangeIndex], this.pos = this.range.from;
    }
    return this.pos += t, this.pos >= this.token.lookAhead && (this.token.lookAhead = this.pos + 1), this.readNext();
  }
  setDone() {
    return this.pos = this.chunkPos = this.end, this.range = this.ranges[this.rangeIndex = this.ranges.length - 1], this.chunk = "", this.next = -1;
  }
  reset(t, e) {
    if (e ? (this.token = e, e.start = t, e.lookAhead = t + 1, e.value = e.extended = -1) : this.token = Mo, this.pos != t) {
      if (this.pos = t, t == this.end)
        return this.setDone(), this;
      for (; t < this.range.from; )
        this.range = this.ranges[--this.rangeIndex];
      for (; t >= this.range.to; )
        this.range = this.ranges[++this.rangeIndex];
      t >= this.chunkPos && t < this.chunkPos + this.chunk.length ? this.chunkOff = t - this.chunkPos : (this.chunk = "", this.chunkOff = 0), this.readNext();
    }
    return this;
  }
  read(t, e) {
    if (t >= this.chunkPos && e <= this.chunkPos + this.chunk.length)
      return this.chunk.slice(t - this.chunkPos, e - this.chunkPos);
    if (t >= this.chunk2Pos && e <= this.chunk2Pos + this.chunk2.length)
      return this.chunk2.slice(t - this.chunk2Pos, e - this.chunk2Pos);
    if (t >= this.range.from && e <= this.range.to)
      return this.input.read(t, e);
    let i = "";
    for (let n of this.ranges) {
      if (n.from >= e)
        break;
      n.to > t && (i += this.input.read(Math.max(n.from, t), Math.min(n.to, e)));
    }
    return i;
  }
}
class Ui {
  constructor(t, e) {
    this.data = t, this.id = e;
  }
  token(t, e) {
    Kp(this.data, t, e, this.id);
  }
}
Ui.prototype.contextual = Ui.prototype.fallback = Ui.prototype.extend = !1;
function Kp(s, t, e, i) {
  let n = 0, r = 1 << i, { parser: o } = e.p, { dialect: l } = o;
  t:
    for (; (r & s[n]) != 0; ) {
      let h = s[n + 1];
      for (let u = n + 3; u < h; u += 2)
        if ((s[u + 1] & r) > 0) {
          let d = s[u];
          if (l.allows(d) && (t.token.value == -1 || t.token.value == d || o.overrides(d, t.token.value))) {
            t.acceptToken(d);
            break;
          }
        }
      let a = t.next, c = 0, f = s[n + 2];
      if (t.next < 0 && f > c && s[h + f * 3 - 3] == 65535) {
        n = s[h + f * 3 - 1];
        continue t;
      }
      for (; c < f; ) {
        let u = c + f >> 1, d = h + u + (u << 1), p = s[d], w = s[d + 1];
        if (a < p)
          f = u;
        else if (a >= w)
          c = u + 1;
        else {
          n = s[d + 2], t.advance();
          continue t;
        }
      }
      break;
    }
}
function Hi(s, t = Uint16Array) {
  if (typeof s != "string")
    return s;
  let e = null;
  for (let i = 0, n = 0; i < s.length; ) {
    let r = 0;
    for (; ; ) {
      let o = s.charCodeAt(i++), l = !1;
      if (o == 126) {
        r = 65535;
        break;
      }
      o >= 92 && o--, o >= 34 && o--;
      let h = o - 32;
      if (h >= 46 && (h -= 46, l = !0), r += h, l)
        break;
      r *= 46;
    }
    e ? e[n++] = r : e = new t(r);
  }
  return e;
}
const Dt = typeof process < "u" && process.env && /\bparse\b/.test(process.env.LOG);
let Yn = null;
var Do;
(function(s) {
  s[s.Margin = 25] = "Margin";
})(Do || (Do = {}));
function To(s, t, e) {
  let i = s.cursor(st.IncludeAnonymous);
  for (i.moveTo(t); ; )
    if (!(e < 0 ? i.childBefore(t) : i.childAfter(t)))
      for (; ; ) {
        if ((e < 0 ? i.to < t : i.from > t) && !i.type.isError)
          return e < 0 ? Math.max(0, Math.min(i.to - 1, t - 25)) : Math.min(s.length, Math.max(i.from + 1, t + 25));
        if (e < 0 ? i.prevSibling() : i.nextSibling())
          break;
        if (!i.parent())
          return e < 0 ? 0 : s.length;
      }
}
class Up {
  constructor(t, e) {
    this.fragments = t, this.nodeSet = e, this.i = 0, this.fragment = null, this.safeFrom = -1, this.safeTo = -1, this.trees = [], this.start = [], this.index = [], this.nextFragment();
  }
  nextFragment() {
    let t = this.fragment = this.i == this.fragments.length ? null : this.fragments[this.i++];
    if (t) {
      for (this.safeFrom = t.openStart ? To(t.tree, t.from + t.offset, 1) - t.offset : t.from, this.safeTo = t.openEnd ? To(t.tree, t.to + t.offset, -1) - t.offset : t.to; this.trees.length; )
        this.trees.pop(), this.start.pop(), this.index.pop();
      this.trees.push(t.tree), this.start.push(-t.offset), this.index.push(0), this.nextStart = this.safeFrom;
    } else
      this.nextStart = 1e9;
  }
  nodeAt(t) {
    if (t < this.nextStart)
      return null;
    for (; this.fragment && this.safeTo <= t; )
      this.nextFragment();
    if (!this.fragment)
      return null;
    for (; ; ) {
      let e = this.trees.length - 1;
      if (e < 0)
        return this.nextFragment(), null;
      let i = this.trees[e], n = this.index[e];
      if (n == i.children.length) {
        this.trees.pop(), this.start.pop(), this.index.pop();
        continue;
      }
      let r = i.children[n], o = this.start[e] + i.positions[n];
      if (o > t)
        return this.nextStart = o, null;
      if (r instanceof J) {
        if (o == t) {
          if (o < this.safeFrom)
            return null;
          let l = o + r.length;
          if (l <= this.safeTo) {
            let h = r.prop(P.lookAhead);
            if (!h || l + h < this.fragment.to)
              return r;
          }
        }
        this.index[e]++, o + r.length >= Math.max(this.safeFrom, t) && (this.trees.push(r), this.start.push(o), this.index.push(0));
      } else
        this.index[e]++, this.nextStart = o + r.length;
    }
  }
}
class Qp {
  constructor(t, e) {
    this.stream = e, this.tokens = [], this.mainToken = null, this.actions = [], this.tokens = t.tokenizers.map((i) => new Ki());
  }
  getActions(t) {
    let e = 0, i = null, { parser: n } = t.p, { tokenizers: r } = n, o = n.stateSlot(t.state, 3), l = t.curContext ? t.curContext.hash : 0, h = 0;
    for (let a = 0; a < r.length; a++) {
      if ((1 << a & o) == 0)
        continue;
      let c = r[a], f = this.tokens[a];
      if (!(i && !c.fallback) && ((c.contextual || f.start != t.pos || f.mask != o || f.context != l) && (this.updateCachedToken(f, c, t), f.mask = o, f.context = l), f.lookAhead > f.end + 25 && (h = Math.max(f.lookAhead, h)), f.value != 0)) {
        let u = e;
        if (f.extended > -1 && (e = this.addActions(t, f.extended, f.end, e)), e = this.addActions(t, f.value, f.end, e), !c.extend && (i = f, e > u))
          break;
      }
    }
    for (; this.actions.length > e; )
      this.actions.pop();
    return h && t.setLookAhead(h), !i && t.pos == this.stream.end && (i = new Ki(), i.value = t.p.parser.eofTerm, i.start = i.end = t.pos, e = this.addActions(t, i.value, i.end, e)), this.mainToken = i, this.actions;
  }
  getMainToken(t) {
    if (this.mainToken)
      return this.mainToken;
    let e = new Ki(), { pos: i, p: n } = t;
    return e.start = i, e.end = Math.min(i + 1, n.stream.end), e.value = i == n.stream.end ? n.parser.eofTerm : 0, e;
  }
  updateCachedToken(t, e, i) {
    let n = this.stream.clipPos(i.pos);
    if (e.token(this.stream.reset(n, t), i), t.value > -1) {
      let { parser: r } = i.p;
      for (let o = 0; o < r.specialized.length; o++)
        if (r.specialized[o] == t.value) {
          let l = r.specializers[o](this.stream.read(t.start, t.end), i);
          if (l >= 0 && i.p.parser.dialect.allows(l >> 1)) {
            (l & 1) == 0 ? t.value = l >> 1 : t.extended = l >> 1;
            break;
          }
        }
    } else
      t.value = 0, t.end = this.stream.clipPos(n + 1);
  }
  putAction(t, e, i, n) {
    for (let r = 0; r < n; r += 3)
      if (this.actions[r] == t)
        return n;
    return this.actions[n++] = t, this.actions[n++] = e, this.actions[n++] = i, n;
  }
  addActions(t, e, i, n) {
    let { state: r } = t, { parser: o } = t.p, { data: l } = o;
    for (let h = 0; h < 2; h++)
      for (let a = o.stateSlot(r, h ? 2 : 1); ; a += 3) {
        if (l[a] == 65535)
          if (l[a + 1] == 1)
            a = Ut(l, a + 2);
          else {
            n == 0 && l[a + 1] == 2 && (n = this.putAction(Ut(l, a + 2), e, i, n));
            break;
          }
        l[a] == e && (n = this.putAction(Ut(l, a + 1), e, i, n));
      }
    return n;
  }
}
var Po;
(function(s) {
  s[s.Distance = 5] = "Distance", s[s.MaxRemainingPerStep = 3] = "MaxRemainingPerStep", s[s.MinBufferLengthPrune = 500] = "MinBufferLengthPrune", s[s.ForceReduceLimit = 10] = "ForceReduceLimit", s[s.CutDepth = 15e3] = "CutDepth", s[s.CutTo = 9e3] = "CutTo";
})(Po || (Po = {}));
class Jp {
  constructor(t, e, i, n) {
    this.parser = t, this.input = e, this.ranges = n, this.recovering = 0, this.nextStackID = 9812, this.minStackPos = 0, this.reused = [], this.stoppedAt = null, this.stream = new Gp(e, n), this.tokens = new Qp(t, this.stream), this.topTerm = t.top[1];
    let { from: r } = n[0];
    this.stacks = [wn.start(this, t.top[0], r)], this.fragments = i.length && this.stream.end - r > t.bufferLength * 4 ? new Up(i, t.nodeSet) : null;
  }
  get parsedPos() {
    return this.minStackPos;
  }
  advance() {
    let t = this.stacks, e = this.minStackPos, i = this.stacks = [], n, r;
    for (let o = 0; o < t.length; o++) {
      let l = t[o];
      for (; ; ) {
        if (this.tokens.mainToken = null, l.pos > e)
          i.push(l);
        else {
          if (this.advanceStack(l, i, t))
            continue;
          {
            n || (n = [], r = []), n.push(l);
            let h = this.tokens.getMainToken(l);
            r.push(h.value, h.end);
          }
        }
        break;
      }
    }
    if (!i.length) {
      let o = n && Yp(n);
      if (o)
        return this.stackToTree(o);
      if (this.parser.strict)
        throw Dt && n && console.log("Stuck with token " + (this.tokens.mainToken ? this.parser.getName(this.tokens.mainToken.value) : "none")), new SyntaxError("No parse at " + e);
      this.recovering || (this.recovering = 5);
    }
    if (this.recovering && n) {
      let o = this.stoppedAt != null && n[0].pos > this.stoppedAt ? n[0] : this.runRecovery(n, r, i);
      if (o)
        return this.stackToTree(o.forceAll());
    }
    if (this.recovering) {
      let o = this.recovering == 1 ? 1 : this.recovering * 3;
      if (i.length > o)
        for (i.sort((l, h) => h.score - l.score); i.length > o; )
          i.pop();
      i.some((l) => l.reducePos > e) && this.recovering--;
    } else if (i.length > 1) {
      t:
        for (let o = 0; o < i.length - 1; o++) {
          let l = i[o];
          for (let h = o + 1; h < i.length; h++) {
            let a = i[h];
            if (l.sameState(a) || l.buffer.length > 500 && a.buffer.length > 500)
              if ((l.score - a.score || l.buffer.length - a.buffer.length) > 0)
                i.splice(h--, 1);
              else {
                i.splice(o--, 1);
                continue t;
              }
          }
        }
    }
    this.minStackPos = i[0].pos;
    for (let o = 1; o < i.length; o++)
      i[o].pos < this.minStackPos && (this.minStackPos = i[o].pos);
    return null;
  }
  stopAt(t) {
    if (this.stoppedAt != null && this.stoppedAt < t)
      throw new RangeError("Can't move stoppedAt forward");
    this.stoppedAt = t;
  }
  advanceStack(t, e, i) {
    let n = t.pos, { parser: r } = this, o = Dt ? this.stackID(t) + " -> " : "";
    if (this.stoppedAt != null && n > this.stoppedAt)
      return t.forceReduce() ? t : null;
    if (this.fragments) {
      let a = t.curContext && t.curContext.tracker.strict, c = a ? t.curContext.hash : 0;
      for (let f = this.fragments.nodeAt(n); f; ) {
        let u = this.parser.nodeSet.types[f.type.id] == f.type ? r.getGoto(t.state, f.type.id) : -1;
        if (u > -1 && f.length && (!a || (f.prop(P.contextHash) || 0) == c))
          return t.useNode(f, u), Dt && console.log(o + this.stackID(t) + ` (via reuse of ${r.getName(f.type.id)})`), !0;
        if (!(f instanceof J) || f.children.length == 0 || f.positions[0] > 0)
          break;
        let d = f.children[0];
        if (d instanceof J && f.positions[0] == 0)
          f = d;
        else
          break;
      }
    }
    let l = r.stateSlot(t.state, 4);
    if (l > 0)
      return t.reduce(l), Dt && console.log(o + this.stackID(t) + ` (via always-reduce ${r.getName(l & 65535)})`), !0;
    if (t.stack.length >= 15e3)
      for (; t.stack.length > 9e3 && t.forceReduce(); )
        ;
    let h = this.tokens.getActions(t);
    for (let a = 0; a < h.length; ) {
      let c = h[a++], f = h[a++], u = h[a++], d = a == h.length || !i, p = d ? t : t.split();
      if (p.apply(c, f, u), Dt && console.log(o + this.stackID(p) + ` (via ${(c & 65536) == 0 ? "shift" : `reduce of ${r.getName(c & 65535)}`} for ${r.getName(f)} @ ${n}${p == t ? "" : ", split"})`), d)
        return !0;
      p.pos > n ? e.push(p) : i.push(p);
    }
    return !1;
  }
  advanceFully(t, e) {
    let i = t.pos;
    for (; ; ) {
      if (!this.advanceStack(t, null, null))
        return !1;
      if (t.pos > i)
        return Bo(t, e), !0;
    }
  }
  runRecovery(t, e, i) {
    let n = null, r = !1;
    for (let o = 0; o < t.length; o++) {
      let l = t[o], h = e[o << 1], a = e[(o << 1) + 1], c = Dt ? this.stackID(l) + " -> " : "";
      if (l.deadEnd && (r || (r = !0, l.restart(), Dt && console.log(c + this.stackID(l) + " (restarted)"), this.advanceFully(l, i))))
        continue;
      let f = l.split(), u = c;
      for (let d = 0; f.forceReduce() && d < 10 && (Dt && console.log(u + this.stackID(f) + " (via force-reduce)"), !this.advanceFully(f, i)); d++)
        Dt && (u = this.stackID(f) + " -> ");
      for (let d of l.recoverByInsert(h))
        Dt && console.log(c + this.stackID(d) + " (via recover-insert)"), this.advanceFully(d, i);
      this.stream.end > l.pos ? (a == l.pos && (a++, h = 0), l.recoverByDelete(h, a), Dt && console.log(c + this.stackID(l) + ` (via recover-delete ${this.parser.getName(h)})`), Bo(l, i)) : (!n || n.score < l.score) && (n = l);
    }
    return n;
  }
  stackToTree(t) {
    return t.close(), J.build({
      buffer: yn.create(t),
      nodeSet: this.parser.nodeSet,
      topID: this.topTerm,
      maxBufferLength: this.parser.bufferLength,
      reused: this.reused,
      start: this.ranges[0].from,
      length: t.pos - this.ranges[0].from,
      minRepeatType: this.parser.minRepeatTerm
    });
  }
  stackID(t) {
    let e = (Yn || (Yn = /* @__PURE__ */ new WeakMap())).get(t);
    return e || Yn.set(t, e = String.fromCodePoint(this.nextStackID++)), e + t;
  }
}
function Bo(s, t) {
  for (let e = 0; e < t.length; e++) {
    let i = t[e];
    if (i.pos == s.pos && i.sameState(s)) {
      t[e].score < s.score && (t[e] = s);
      return;
    }
  }
  t.push(s);
}
class Xp {
  constructor(t, e, i) {
    this.source = t, this.flags = e, this.disabled = i;
  }
  allows(t) {
    return !this.disabled || this.disabled[t] == 0;
  }
}
class bn extends lh {
  constructor(t) {
    if (super(), this.wrappers = [], t.version != 14)
      throw new RangeError(`Parser version (${t.version}) doesn't match runtime version (${14})`);
    let e = t.nodeNames.split(" ");
    this.minRepeatTerm = e.length;
    for (let l = 0; l < t.repeatNodeCount; l++)
      e.push("");
    let i = Object.keys(t.topRules).map((l) => t.topRules[l][1]), n = [];
    for (let l = 0; l < e.length; l++)
      n.push([]);
    function r(l, h, a) {
      n[l].push([h, h.deserialize(String(a))]);
    }
    if (t.nodeProps)
      for (let l of t.nodeProps) {
        let h = l[0];
        typeof h == "string" && (h = P[h]);
        for (let a = 1; a < l.length; ) {
          let c = l[a++];
          if (c >= 0)
            r(c, h, l[a++]);
          else {
            let f = l[a + -c];
            for (let u = -c; u > 0; u--)
              r(l[a++], h, f);
            a++;
          }
        }
      }
    this.nodeSet = new Qs(e.map((l, h) => yt.define({
      name: h >= this.minRepeatTerm ? void 0 : l,
      id: h,
      props: n[h],
      top: i.indexOf(h) > -1,
      error: h == 0,
      skipped: t.skippedNodes && t.skippedNodes.indexOf(h) > -1
    }))), t.propSources && (this.nodeSet = this.nodeSet.extend(...t.propSources)), this.strict = !1, this.bufferLength = sh;
    let o = Hi(t.tokenData);
    this.context = t.context, this.specializerSpecs = t.specialized || [], this.specialized = new Uint16Array(this.specializerSpecs.length);
    for (let l = 0; l < this.specializerSpecs.length; l++)
      this.specialized[l] = this.specializerSpecs[l].term;
    this.specializers = this.specializerSpecs.map(Lo), this.states = Hi(t.states, Uint32Array), this.data = Hi(t.stateData), this.goto = Hi(t.goto), this.maxTerm = t.maxTerm, this.tokenizers = t.tokenizers.map((l) => typeof l == "number" ? new Ui(o, l) : l), this.topRules = t.topRules, this.dialects = t.dialects || {}, this.dynamicPrecedences = t.dynamicPrecedences || null, this.tokenPrecTable = t.tokenPrec, this.termNames = t.termNames || null, this.maxNode = this.nodeSet.types.length - 1, this.dialect = this.parseDialect(), this.top = this.topRules[Object.keys(this.topRules)[0]];
  }
  createParse(t, e, i) {
    let n = new Jp(this, t, e, i);
    for (let r of this.wrappers)
      n = r(n, t, e, i);
    return n;
  }
  getGoto(t, e, i = !1) {
    let n = this.goto;
    if (e >= n[0])
      return -1;
    for (let r = n[e + 1]; ; ) {
      let o = n[r++], l = o & 1, h = n[r++];
      if (l && i)
        return h;
      for (let a = r + (o >> 1); r < a; r++)
        if (n[r] == t)
          return h;
      if (l)
        return -1;
    }
  }
  hasAction(t, e) {
    let i = this.data;
    for (let n = 0; n < 2; n++)
      for (let r = this.stateSlot(t, n ? 2 : 1), o; ; r += 3) {
        if ((o = i[r]) == 65535)
          if (i[r + 1] == 1)
            o = i[r = Ut(i, r + 2)];
          else {
            if (i[r + 1] == 2)
              return Ut(i, r + 2);
            break;
          }
        if (o == e || o == 0)
          return Ut(i, r + 1);
      }
    return 0;
  }
  stateSlot(t, e) {
    return this.states[t * 6 + e];
  }
  stateFlag(t, e) {
    return (this.stateSlot(t, 0) & e) > 0;
  }
  validAction(t, e) {
    if (e == this.stateSlot(t, 4))
      return !0;
    for (let i = this.stateSlot(t, 1); ; i += 3) {
      if (this.data[i] == 65535)
        if (this.data[i + 1] == 1)
          i = Ut(this.data, i + 2);
        else
          return !1;
      if (e == Ut(this.data, i + 1))
        return !0;
    }
  }
  nextStates(t) {
    let e = [];
    for (let i = this.stateSlot(t, 1); ; i += 3) {
      if (this.data[i] == 65535)
        if (this.data[i + 1] == 1)
          i = Ut(this.data, i + 2);
        else
          break;
      if ((this.data[i + 2] & 1) == 0) {
        let n = this.data[i + 1];
        e.some((r, o) => o & 1 && r == n) || e.push(this.data[i], n);
      }
    }
    return e;
  }
  overrides(t, e) {
    let i = Ro(this.data, this.tokenPrecTable, e);
    return i < 0 || Ro(this.data, this.tokenPrecTable, t) < i;
  }
  configure(t) {
    let e = Object.assign(Object.create(bn.prototype), this);
    if (t.props && (e.nodeSet = this.nodeSet.extend(...t.props)), t.top) {
      let i = this.topRules[t.top];
      if (!i)
        throw new RangeError(`Invalid top rule name ${t.top}`);
      e.top = i;
    }
    return t.tokenizers && (e.tokenizers = this.tokenizers.map((i) => {
      let n = t.tokenizers.find((r) => r.from == i);
      return n ? n.to : i;
    })), t.specializers && (e.specializers = this.specializers.slice(), e.specializerSpecs = this.specializerSpecs.map((i, n) => {
      let r = t.specializers.find((l) => l.from == i.external);
      if (!r)
        return i;
      let o = Object.assign(Object.assign({}, i), { external: r.to });
      return e.specializers[n] = Lo(o), o;
    })), t.contextTracker && (e.context = t.contextTracker), t.dialect && (e.dialect = this.parseDialect(t.dialect)), t.strict != null && (e.strict = t.strict), t.wrap && (e.wrappers = e.wrappers.concat(t.wrap)), t.bufferLength != null && (e.bufferLength = t.bufferLength), e;
  }
  hasWrappers() {
    return this.wrappers.length > 0;
  }
  getName(t) {
    return this.termNames ? this.termNames[t] : String(t <= this.maxNode && this.nodeSet.types[t].name || t);
  }
  get eofTerm() {
    return this.maxNode + 1;
  }
  get topNode() {
    return this.nodeSet.types[this.top[1]];
  }
  dynamicPrecedence(t) {
    let e = this.dynamicPrecedences;
    return e == null ? 0 : e[t] || 0;
  }
  parseDialect(t) {
    let e = Object.keys(this.dialects), i = e.map(() => !1);
    if (t)
      for (let r of t.split(" ")) {
        let o = e.indexOf(r);
        o >= 0 && (i[o] = !0);
      }
    let n = null;
    for (let r = 0; r < e.length; r++)
      if (!i[r])
        for (let o = this.dialects[e[r]], l; (l = this.data[o++]) != 65535; )
          (n || (n = new Uint8Array(this.maxTerm + 1)))[l] = 1;
    return new Xp(t, i, n);
  }
  static deserialize(t) {
    return new bn(t);
  }
}
function Ut(s, t) {
  return s[t] | s[t + 1] << 16;
}
function Ro(s, t, e) {
  for (let i = t, n; (n = s[i]) != 65535; i++)
    if (n == e)
      return i - t;
  return -1;
}
function Yp(s) {
  let t = null;
  for (let e of s) {
    let i = e.p.stoppedAt;
    (e.pos == e.p.stream.end || i != null && e.pos > i) && e.p.parser.stateFlag(e.state, 2) && (!t || t.score < e.score) && (t = e);
  }
  return t;
}
function Lo(s) {
  if (s.external) {
    let t = s.extend ? 1 : 0;
    return (e, i) => s.external(e, i) << 1 | t;
  }
  return s.get;
}
const Zp = ah({
  String: m.string,
  Number: m.number,
  "True False": m.bool,
  PropertyName: m.propertyName,
  Null: m.null,
  ",": m.separator,
  "[ ]": m.squareBracket,
  "{ }": m.brace
}), tg = bn.deserialize({
  version: 14,
  states: "$bOVQPOOOOQO'#Cb'#CbOnQPO'#CeOvQPO'#CjOOQO'#Cp'#CpQOQPOOOOQO'#Cg'#CgO}QPO'#CfO!SQPO'#CrOOQO,59P,59PO![QPO,59PO!aQPO'#CuOOQO,59U,59UO!iQPO,59UOVQPO,59QOqQPO'#CkO!nQPO,59^OOQO1G.k1G.kOVQPO'#ClO!vQPO,59aOOQO1G.p1G.pOOQO1G.l1G.lOOQO,59V,59VOOQO-E6i-E6iOOQO,59W,59WOOQO-E6j-E6j",
  stateData: "#O~OcOS~OQSORSOSSOTSOWQO]ROePO~OVXOeUO~O[[O~PVOg^O~Oh_OVfX~OVaO~OhbO[iX~O[dO~Oh_OVfa~OhbO[ia~O",
  goto: "!kjPPPPPPkPPkqwPPk{!RPPP!XP!ePP!hXSOR^bQWQRf_TVQ_Q`WRg`QcZRicQTOQZRQe^RhbRYQR]R",
  nodeNames: "\u26A0 JsonText True False Null Number String } { Object Property PropertyName ] [ Array",
  maxTerm: 25,
  nodeProps: [
    ["openedBy", 7, "{", 12, "["],
    ["closedBy", 8, "}", 13, "]"]
  ],
  propSources: [Zp],
  skippedNodes: [0],
  repeatNodeCount: 2,
  tokenData: "(p~RaXY!WYZ!W]^!Wpq!Wrs!]|}$i}!O$n!Q!R$w!R![&V![!]&h!}#O&m#P#Q&r#Y#Z&w#b#c'f#h#i'}#o#p(f#q#r(k~!]Oc~~!`Upq!]qr!]rs!rs#O!]#O#P!w#P~!]~!wOe~~!zXrs!]!P!Q!]#O#P!]#U#V!]#Y#Z!]#b#c!]#f#g!]#h#i!]#i#j#g~#jR!Q![#s!c!i#s#T#Z#s~#vR!Q![$P!c!i$P#T#Z$P~$SR!Q![$]!c!i$]#T#Z$]~$`R!Q![!]!c!i!]#T#Z!]~$nOh~~$qQ!Q!R$w!R![&V~$|RT~!O!P%V!g!h%k#X#Y%k~%YP!Q![%]~%bRT~!Q![%]!g!h%k#X#Y%k~%nR{|%w}!O%w!Q![%}~%zP!Q![%}~&SPT~!Q![%}~&[ST~!O!P%V!Q![&V!g!h%k#X#Y%k~&mOg~~&rO]~~&wO[~~&zP#T#U&}~'QP#`#a'T~'WP#g#h'Z~'^P#X#Y'a~'fOR~~'iP#i#j'l~'oP#`#a'r~'uP#`#a'x~'}OS~~(QP#f#g(T~(WP#i#j(Z~(^P#X#Y(a~(fOQ~~(kOW~~(pOV~",
  tokenizers: [0],
  topRules: { JsonText: [0, 1] },
  tokenPrec: 0
}), eg = /* @__PURE__ */ un.define({
  parser: /* @__PURE__ */ tg.configure({
    props: [
      /* @__PURE__ */ dh.add({
        Object: /* @__PURE__ */ uo({ except: /^\s*\}/ }),
        Array: /* @__PURE__ */ uo({ except: /^\s*\]/ })
      }),
      /* @__PURE__ */ gh.add({
        "Object Array": bd
      })
    ]
  }),
  languageData: {
    closeBrackets: { brackets: ["[", "{", '"'] },
    indentOnInput: /^\s*[\}\]]$/
  }
});
function ig() {
  return new ld(eg);
}
function $t() {
  var s = arguments[0];
  typeof s == "string" && (s = document.createElement(s));
  var t = 1, e = arguments[1];
  if (e && typeof e == "object" && e.nodeType == null && !Array.isArray(e)) {
    for (var i in e)
      if (Object.prototype.hasOwnProperty.call(e, i)) {
        var n = e[i];
        typeof n == "string" ? s.setAttribute(i, n) : n != null && (s[i] = n);
      }
    t++;
  }
  for (; t < arguments.length; t++)
    Yh(s, arguments[t]);
  return s;
}
function Yh(s, t) {
  if (typeof t == "string")
    s.appendChild(document.createTextNode(t));
  else if (t != null)
    if (t.nodeType != null)
      s.appendChild(t);
    else if (Array.isArray(t))
      for (var e = 0; e < t.length; e++)
        Yh(s, t[e]);
    else
      throw new RangeError("Unsupported child node: " + t);
}
class ng {
  constructor(t, e, i) {
    this.from = t, this.to = e, this.diagnostic = i;
  }
}
class Se {
  constructor(t, e, i) {
    this.diagnostics = t, this.panel = e, this.selected = i;
  }
  static init(t, e, i) {
    let n = t, r = i.facet(Ve).markerFilter;
    r && (n = r(n));
    let o = D.set(n.map((l) => l.from == l.to || l.from == l.to - 1 && i.doc.lineAt(l.from).to == l.from ? D.widget({
      widget: new dg(l),
      diagnostic: l
    }).range(l.from) : D.mark({
      attributes: { class: "cm-lintRange cm-lintRange-" + l.severity },
      diagnostic: l
    }).range(l.from, l.to)), !0);
    return new Se(o, e, Ue(o));
  }
}
function Ue(s, t = null, e = 0) {
  let i = null;
  return s.between(e, 1e9, (n, r, { spec: o }) => {
    if (!(t && o.diagnostic != t))
      return i = new ng(n, r, o.diagnostic), !1;
  }), i;
}
function sg(s, t) {
  return !!(s.effects.some((e) => e.is(rr)) || s.changes.touchesRange(t.pos));
}
function Zh(s, t) {
  return s.field(vt, !1) ? t : t.concat(F.appendConfig.of([
    vt,
    A.decorations.compute([vt], (e) => {
      let { selected: i, panel: n } = e.field(vt);
      return !i || !n || i.from == i.to ? D.none : D.set([
        og.range(i.from, i.to)
      ]);
    }),
    Eu(lg, { hideOn: sg }),
    gg
  ]));
}
function rg(s, t) {
  return {
    effects: Zh(s, [rr.of(t)])
  };
}
const rr = /* @__PURE__ */ F.define(), or = /* @__PURE__ */ F.define(), ta = /* @__PURE__ */ F.define(), vt = /* @__PURE__ */ Bt.define({
  create() {
    return new Se(D.none, null, null);
  },
  update(s, t) {
    if (t.docChanged) {
      let e = s.diagnostics.map(t.changes), i = null;
      if (s.selected) {
        let n = t.changes.mapPos(s.selected.from, 1);
        i = Ue(e, s.selected.diagnostic, n) || Ue(e, null, n);
      }
      s = new Se(e, s.panel, i);
    }
    for (let e of t.effects)
      e.is(rr) ? s = Se.init(e.value, s.panel, t.state) : e.is(or) ? s = new Se(s.diagnostics, e.value ? Ln.open : null, s.selected) : e.is(ta) && (s = new Se(s.diagnostics, s.panel, e.value));
    return s;
  },
  provide: (s) => [
    Bs.from(s, (t) => t.panel),
    A.decorations.from(s, (t) => t.diagnostics)
  ]
}), og = /* @__PURE__ */ D.mark({ class: "cm-lintRange cm-lintRange-active" });
function lg(s, t, e) {
  let { diagnostics: i } = s.state.field(vt), n = [], r = 2e8, o = 0;
  i.between(t - (e < 0 ? 1 : 0), t + (e > 0 ? 1 : 0), (h, a, { spec: c }) => {
    t >= h && t <= a && (h == a || (t > h || e > 0) && (t < a || e < 0)) && (n.push(c.diagnostic), r = Math.min(h, r), o = Math.max(a, o));
  });
  let l = s.state.facet(Ve).tooltipFilter;
  return l && (n = l(n)), n.length ? {
    pos: r,
    end: o,
    above: s.state.doc.lineAt(r).to < o,
    create() {
      return { dom: hg(s, n) };
    }
  } : null;
}
function hg(s, t) {
  return $t("ul", { class: "cm-tooltip-lint" }, t.map((e) => ia(s, e, !1)));
}
const ag = (s) => {
  let t = s.state.field(vt, !1);
  (!t || !t.panel) && s.dispatch({ effects: Zh(s.state, [or.of(!0)]) });
  let e = Vu(s, Ln.open);
  return e && e.dom.querySelector(".cm-panel-lint ul").focus(), !0;
}, Eo = (s) => {
  let t = s.state.field(vt, !1);
  return !t || !t.panel ? !1 : (s.dispatch({ effects: or.of(!1) }), !0);
}, cg = (s) => {
  let t = s.state.field(vt, !1);
  if (!t)
    return !1;
  let e = s.state.selection.main, i = t.diagnostics.iter(e.to + 1);
  return !i.value && (i = t.diagnostics.iter(0), !i.value || i.from == e.from && i.to == e.to) ? !1 : (s.dispatch({ selection: { anchor: i.from, head: i.to }, scrollIntoView: !0 }), !0);
}, fg = [
  { key: "Mod-Shift-m", run: ag },
  { key: "F8", run: cg }
], ug = /* @__PURE__ */ wt.fromClass(class {
  constructor(s) {
    this.view = s, this.timeout = -1, this.set = !0;
    let { delay: t } = s.state.facet(Ve);
    this.lintTime = Date.now() + t, this.run = this.run.bind(this), this.timeout = setTimeout(this.run, t);
  }
  run() {
    let s = Date.now();
    if (s < this.lintTime - 10)
      setTimeout(this.run, this.lintTime - s);
    else {
      this.set = !1;
      let { state: t } = this.view, { sources: e } = t.facet(Ve);
      Promise.all(e.map((i) => Promise.resolve(i(this.view)))).then((i) => {
        let n = i.reduce((r, o) => r.concat(o));
        this.view.state.doc == t.doc && this.view.dispatch(rg(this.view.state, n));
      }, (i) => {
        zt(this.view.state, i);
      });
    }
  }
  update(s) {
    let t = s.state.facet(Ve);
    (s.docChanged || t != s.startState.facet(Ve)) && (this.lintTime = Date.now() + t.delay, this.set || (this.set = !0, this.timeout = setTimeout(this.run, t.delay)));
  }
  force() {
    this.set && (this.lintTime = Date.now(), this.run());
  }
  destroy() {
    clearTimeout(this.timeout);
  }
}), Ve = /* @__PURE__ */ v.define({
  combine(s) {
    return Object.assign({ sources: s.map((t) => t.source) }, xn(s.map((t) => t.config), {
      delay: 750,
      markerFilter: null,
      tooltipFilter: null
    }));
  },
  enables: ug
});
function ea(s) {
  let t = [];
  if (s)
    t:
      for (let { name: e } of s) {
        for (let i = 0; i < e.length; i++) {
          let n = e[i];
          if (/[a-zA-Z]/.test(n) && !t.some((r) => r.toLowerCase() == n.toLowerCase())) {
            t.push(n);
            continue t;
          }
        }
        t.push("");
      }
  return t;
}
function ia(s, t, e) {
  var i;
  let n = e ? ea(t.actions) : [];
  return $t("li", { class: "cm-diagnostic cm-diagnostic-" + t.severity }, $t("span", { class: "cm-diagnosticText" }, t.renderMessage ? t.renderMessage() : t.message), (i = t.actions) === null || i === void 0 ? void 0 : i.map((r, o) => {
    let l = (f) => {
      f.preventDefault();
      let u = Ue(s.state.field(vt).diagnostics, t);
      u && r.apply(s, u.from, u.to);
    }, { name: h } = r, a = n[o] ? h.indexOf(n[o]) : -1, c = a < 0 ? h : [
      h.slice(0, a),
      $t("u", h.slice(a, a + 1)),
      h.slice(a + 1)
    ];
    return $t("button", {
      type: "button",
      class: "cm-diagnosticAction",
      onclick: l,
      onmousedown: l,
      "aria-label": ` Action: ${h}${a < 0 ? "" : ` (access key "${n[o]})"`}.`
    }, c);
  }), t.source && $t("div", { class: "cm-diagnosticSource" }, t.source));
}
class dg extends ye {
  constructor(t) {
    super(), this.diagnostic = t;
  }
  eq(t) {
    return t.diagnostic == this.diagnostic;
  }
  toDOM() {
    return $t("span", { class: "cm-lintPoint cm-lintPoint-" + this.diagnostic.severity });
  }
}
class No {
  constructor(t, e) {
    this.diagnostic = e, this.id = "item_" + Math.floor(Math.random() * 4294967295).toString(16), this.dom = ia(t, e, !0), this.dom.id = this.id, this.dom.setAttribute("role", "option");
  }
}
class Ln {
  constructor(t) {
    this.view = t, this.items = [];
    let e = (n) => {
      if (n.keyCode == 27)
        Eo(this.view), this.view.focus();
      else if (n.keyCode == 38 || n.keyCode == 33)
        this.moveSelection((this.selectedIndex - 1 + this.items.length) % this.items.length);
      else if (n.keyCode == 40 || n.keyCode == 34)
        this.moveSelection((this.selectedIndex + 1) % this.items.length);
      else if (n.keyCode == 36)
        this.moveSelection(0);
      else if (n.keyCode == 35)
        this.moveSelection(this.items.length - 1);
      else if (n.keyCode == 13)
        this.view.focus();
      else if (n.keyCode >= 65 && n.keyCode <= 90 && this.selectedIndex >= 0) {
        let { diagnostic: r } = this.items[this.selectedIndex], o = ea(r.actions);
        for (let l = 0; l < o.length; l++)
          if (o[l].toUpperCase().charCodeAt(0) == n.keyCode) {
            let h = Ue(this.view.state.field(vt).diagnostics, r);
            h && r.actions[l].apply(t, h.from, h.to);
          }
      } else
        return;
      n.preventDefault();
    }, i = (n) => {
      for (let r = 0; r < this.items.length; r++)
        this.items[r].dom.contains(n.target) && this.moveSelection(r);
    };
    this.list = $t("ul", {
      tabIndex: 0,
      role: "listbox",
      "aria-label": this.view.state.phrase("Diagnostics"),
      onkeydown: e,
      onclick: i
    }), this.dom = $t("div", { class: "cm-panel-lint" }, this.list, $t("button", {
      type: "button",
      name: "close",
      "aria-label": this.view.state.phrase("close"),
      onclick: () => Eo(this.view)
    }, "\xD7")), this.update();
  }
  get selectedIndex() {
    let t = this.view.state.field(vt).selected;
    if (!t)
      return -1;
    for (let e = 0; e < this.items.length; e++)
      if (this.items[e].diagnostic == t.diagnostic)
        return e;
    return -1;
  }
  update() {
    let { diagnostics: t, selected: e } = this.view.state.field(vt), i = 0, n = !1, r = null;
    for (t.between(0, this.view.state.doc.length, (o, l, { spec: h }) => {
      let a = -1, c;
      for (let f = i; f < this.items.length; f++)
        if (this.items[f].diagnostic == h.diagnostic) {
          a = f;
          break;
        }
      a < 0 ? (c = new No(this.view, h.diagnostic), this.items.splice(i, 0, c), n = !0) : (c = this.items[a], a > i && (this.items.splice(i, a - i), n = !0)), e && c.diagnostic == e.diagnostic ? c.dom.hasAttribute("aria-selected") || (c.dom.setAttribute("aria-selected", "true"), r = c) : c.dom.hasAttribute("aria-selected") && c.dom.removeAttribute("aria-selected"), i++;
    }); i < this.items.length && !(this.items.length == 1 && this.items[0].diagnostic.from < 0); )
      n = !0, this.items.pop();
    this.items.length == 0 && (this.items.push(new No(this.view, {
      from: -1,
      to: -1,
      severity: "info",
      message: this.view.state.phrase("No diagnostics")
    })), n = !0), r ? (this.list.setAttribute("aria-activedescendant", r.id), this.view.requestMeasure({
      key: this,
      read: () => ({ sel: r.dom.getBoundingClientRect(), panel: this.list.getBoundingClientRect() }),
      write: ({ sel: o, panel: l }) => {
        o.top < l.top ? this.list.scrollTop -= l.top - o.top : o.bottom > l.bottom && (this.list.scrollTop += o.bottom - l.bottom);
      }
    })) : this.selectedIndex < 0 && this.list.removeAttribute("aria-activedescendant"), n && this.sync();
  }
  sync() {
    let t = this.list.firstChild;
    function e() {
      let i = t;
      t = i.nextSibling, i.remove();
    }
    for (let i of this.items)
      if (i.dom.parentNode == this.list) {
        for (; t != i.dom; )
          e();
        t = i.dom.nextSibling;
      } else
        this.list.insertBefore(i.dom, t);
    for (; t; )
      e();
  }
  moveSelection(t) {
    if (this.selectedIndex < 0)
      return;
    let e = this.view.state.field(vt), i = Ue(e.diagnostics, this.items[t].diagnostic);
    !i || this.view.dispatch({
      selection: { anchor: i.from, head: i.to },
      scrollIntoView: !0,
      effects: ta.of(i)
    });
  }
  static open(t) {
    return new Ln(t);
  }
}
function pg(s, t = 'viewBox="0 0 40 40"') {
  return `url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" ${t}>${encodeURIComponent(s)}</svg>')`;
}
function Zn(s) {
  return pg(`<path d="m0 2.5 l2 -1.5 l1 0 l2 1.5 l1 0" stroke="${s}" fill="none" stroke-width=".7"/>`, 'width="6" height="3"');
}
const gg = /* @__PURE__ */ A.baseTheme({
  ".cm-diagnostic": {
    padding: "3px 6px 3px 8px",
    marginLeft: "-1px",
    display: "block",
    whiteSpace: "pre-wrap"
  },
  ".cm-diagnostic-error": { borderLeft: "5px solid #d11" },
  ".cm-diagnostic-warning": { borderLeft: "5px solid orange" },
  ".cm-diagnostic-info": { borderLeft: "5px solid #999" },
  ".cm-diagnosticAction": {
    font: "inherit",
    border: "none",
    padding: "2px 4px",
    backgroundColor: "#444",
    color: "white",
    borderRadius: "3px",
    marginLeft: "8px"
  },
  ".cm-diagnosticSource": {
    fontSize: "70%",
    opacity: 0.7
  },
  ".cm-lintRange": {
    backgroundPosition: "left bottom",
    backgroundRepeat: "repeat-x",
    paddingBottom: "0.7px"
  },
  ".cm-lintRange-error": { backgroundImage: /* @__PURE__ */ Zn("#d11") },
  ".cm-lintRange-warning": { backgroundImage: /* @__PURE__ */ Zn("orange") },
  ".cm-lintRange-info": { backgroundImage: /* @__PURE__ */ Zn("#999") },
  ".cm-lintRange-active": { backgroundColor: "#ffdd9980" },
  ".cm-tooltip-lint": {
    padding: 0,
    margin: 0
  },
  ".cm-lintPoint": {
    position: "relative",
    "&:after": {
      content: '""',
      position: "absolute",
      bottom: 0,
      left: "-2px",
      borderLeft: "3px solid transparent",
      borderRight: "3px solid transparent",
      borderBottom: "4px solid #d11"
    }
  },
  ".cm-lintPoint-warning": {
    "&:after": { borderBottomColor: "orange" }
  },
  ".cm-lintPoint-info": {
    "&:after": { borderBottomColor: "#999" }
  },
  ".cm-panel.cm-panel-lint": {
    position: "relative",
    "& ul": {
      maxHeight: "100px",
      overflowY: "auto",
      "& [aria-selected]": {
        backgroundColor: "#ddd",
        "& u": { textDecoration: "underline" }
      },
      "&:focus [aria-selected]": {
        background_fallback: "#bdf",
        backgroundColor: "Highlight",
        color_fallback: "white",
        color: "HighlightText"
      },
      "& u": { textDecoration: "none" },
      padding: 0,
      margin: 0
    },
    "& [name=close]": {
      position: "absolute",
      top: "0",
      right: "2px",
      background: "inherit",
      border: "none",
      font: "inherit",
      padding: 0,
      margin: 0
    }
  }
}), mg = "#e5c07b", Vo = "#e06c75", wg = "#56b6c2", yg = "#ffffff", Qi = "#abb2bf", Hs = "#7d8799", bg = "#61afef", kg = "#98c379", Io = "#d19a66", xg = "#c678dd", vg = "#21252b", Ho = "#2c313a", $o = "#282c34", ts = "#353a42", Sg = "#3E4451", Fo = "#528bff", Cg = /* @__PURE__ */ A.theme({
  "&": {
    color: Qi,
    backgroundColor: $o
  },
  ".cm-content": {
    caretColor: Fo
  },
  ".cm-cursor, .cm-dropCursor": { borderLeftColor: Fo },
  "&.cm-focused .cm-selectionBackground, .cm-selectionBackground, .cm-content ::selection": { backgroundColor: Sg },
  ".cm-panels": { backgroundColor: vg, color: Qi },
  ".cm-panels.cm-panels-top": { borderBottom: "2px solid black" },
  ".cm-panels.cm-panels-bottom": { borderTop: "2px solid black" },
  ".cm-searchMatch": {
    backgroundColor: "#72a1ff59",
    outline: "1px solid #457dff"
  },
  ".cm-searchMatch.cm-searchMatch-selected": {
    backgroundColor: "#6199ff2f"
  },
  ".cm-activeLine": { backgroundColor: "#6699ff0b" },
  ".cm-selectionMatch": { backgroundColor: "#aafe661a" },
  "&.cm-focused .cm-matchingBracket, &.cm-focused .cm-nonmatchingBracket": {
    backgroundColor: "#bad0f847",
    outline: "1px solid #515a6b"
  },
  ".cm-gutters": {
    backgroundColor: $o,
    color: Hs,
    border: "none"
  },
  ".cm-activeLineGutter": {
    backgroundColor: Ho
  },
  ".cm-foldPlaceholder": {
    backgroundColor: "transparent",
    border: "none",
    color: "#ddd"
  },
  ".cm-tooltip": {
    border: "none",
    backgroundColor: ts
  },
  ".cm-tooltip .cm-tooltip-arrow:before": {
    borderTopColor: "transparent",
    borderBottomColor: "transparent"
  },
  ".cm-tooltip .cm-tooltip-arrow:after": {
    borderTopColor: ts,
    borderBottomColor: ts
  },
  ".cm-tooltip-autocomplete": {
    "& > ul > li[aria-selected]": {
      backgroundColor: Ho,
      color: Qi
    }
  }
}, { dark: !0 }), Ag = /* @__PURE__ */ vi.define([
  {
    tag: m.keyword,
    color: xg
  },
  {
    tag: [m.name, m.deleted, m.character, m.propertyName, m.macroName],
    color: Vo
  },
  {
    tag: [/* @__PURE__ */ m.function(m.variableName), m.labelName],
    color: bg
  },
  {
    tag: [m.color, /* @__PURE__ */ m.constant(m.name), /* @__PURE__ */ m.standard(m.name)],
    color: Io
  },
  {
    tag: [/* @__PURE__ */ m.definition(m.name), m.separator],
    color: Qi
  },
  {
    tag: [m.typeName, m.className, m.number, m.changed, m.annotation, m.modifier, m.self, m.namespace],
    color: mg
  },
  {
    tag: [m.operator, m.operatorKeyword, m.url, m.escape, m.regexp, m.link, /* @__PURE__ */ m.special(m.string)],
    color: wg
  },
  {
    tag: [m.meta, m.comment],
    color: Hs
  },
  {
    tag: m.strong,
    fontWeight: "bold"
  },
  {
    tag: m.emphasis,
    fontStyle: "italic"
  },
  {
    tag: m.strikethrough,
    textDecoration: "line-through"
  },
  {
    tag: m.link,
    color: Hs,
    textDecoration: "underline"
  },
  {
    tag: m.heading,
    fontWeight: "bold",
    color: Vo
  },
  {
    tag: [m.atom, m.bool, /* @__PURE__ */ m.special(m.variableName)],
    color: Io
  },
  {
    tag: [m.processingInstruction, m.string, m.inserted],
    color: kg
  },
  {
    tag: m.invalid,
    color: yg
  }
]), na = rt(!1);
window.__hst_controls_dark || (window.__hst_controls_dark = []);
window.__hst_controls_dark.push(na);
var zo;
(zo = window.__hst_controls_dark_ready) == null || zo.call(window);
const Og = (s, t) => {
  const e = s.__vccOpts || s;
  for (const [i, n] of t)
    e[i] = n;
  return e;
}, Mg = {
  name: "HstJson",
  inheritAttrs: !1
}, Dg = /* @__PURE__ */ tt({
  ...Mg,
  props: {
    title: null,
    modelValue: null
  },
  emits: {
    "update:modelValue": (s) => !0
  },
  setup(s, { emit: t }) {
    const e = s;
    let i;
    const n = rt(""), r = rt(!1), o = rt(), l = {
      light: [A.baseTheme({}), go(Ed)],
      dark: [Cg, go(Ag)]
    }, h = new yi(), a = [
      qu(),
      Su(),
      wu(),
      ig(),
      zd(),
      wd(),
      Pd(),
      Yl.of([
        ...jp,
        ...Md,
        ...fg
      ]),
      A.updateListener.of((c) => {
        n.value = c.view.state.doc.toString();
      }),
      h.of(l.light)
    ];
    return oa(() => {
      i = new A({
        doc: JSON.stringify(e.modelValue, null, 2),
        extensions: a,
        parent: o.value
      }), la(() => {
        i.dispatch({
          effects: [
            h.reconfigure(l[na.value ? "dark" : "light"])
          ]
        });
      });
    }), Ji(() => e.modelValue, () => {
      let c;
      try {
        c = JSON.stringify(JSON.parse(n.value)) === JSON.stringify(e.modelValue);
      } catch {
        c = !1;
      }
      c || i.dispatch({ changes: [{ from: 0, to: i.state.doc.length, insert: JSON.stringify(e.modelValue, null, 2) }] });
    }, { deep: !0 }), Ji(() => n.value, () => {
      r.value = !1;
      try {
        t("update:modelValue", JSON.parse(n.value));
      } catch {
        r.value = !0;
      }
    }), (c, f) => (S(), Q(jt, {
      title: s.title,
      class: gt(["histoire-json htw-cursor-text", c.$attrs.class]),
      style: Pt(c.$attrs.style)
    }, {
      actions: q(() => [
        r.value ? _t((S(), Q(H($s), {
          key: 0,
          icon: "carbon:warning-alt",
          class: "htw-text-orange-500"
        }, null, 512)), [
          [H(ue), "JSON error"]
        ]) : Jt("", !0),
        ct(c.$slots, "actions", {}, void 0, !0)
      ]),
      default: q(() => [
        B("div", Qe({
          ref_key: "editorElement",
          ref: o,
          class: "__histoire-json-code htw-w-full htw-border htw-border-solid htw-border-black/25 dark:htw-border-white/25 focus-within:htw-border-primary-500 dark:focus-within:htw-border-primary-500 htw-rounded-sm htw-box-border htw-overflow-auto htw-resize-y htw-min-h-32 htw-h-48 htw-relative"
        }, { ...c.$attrs, class: null, style: null }), null, 16)
      ]),
      _: 3
    }, 8, ["title", "class", "style"]));
  }
}), Tg = /* @__PURE__ */ Og(Dg, [["__scopeId", "data-v-7e04a5c8"]]), Pg = jo, Bg = wa, Rg = va, Lg = Oa, Eg = Ta, Ng = Ba, Vg = Na, Ig = Ha, Hg = Ga, $g = ec, Fg = ac, zg = mc, _g = Me, Wg = xc, jg = Tg, Jg = {
  HstButton: Pg,
  HstButtonGroup: Bg,
  HstCheckbox: Rg,
  HstCheckboxList: Lg,
  HstText: Eg,
  HstNumber: Ng,
  HstSlider: Vg,
  HstTextarea: Ig,
  HstSelect: Hg,
  HstColorShades: $g,
  HstTokenList: Fg,
  HstTokenGrid: zg,
  HstCopyIcon: _g,
  HstRadio: Wg,
  HstJson: jg
};
export {
  Pg as HstButton,
  Bg as HstButtonGroup,
  Rg as HstCheckbox,
  Lg as HstCheckboxList,
  $g as HstColorShades,
  _g as HstCopyIcon,
  jg as HstJson,
  Ng as HstNumber,
  Wg as HstRadio,
  Hg as HstSelect,
  Vg as HstSlider,
  Eg as HstText,
  Ig as HstTextarea,
  zg as HstTokenGrid,
  Fg as HstTokenList,
  Jg as components
};
